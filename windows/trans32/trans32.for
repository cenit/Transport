C     Fortran-Source for Digital Visual Fortran (Urs Rohrer, July 1997)
C
      INTEGER*2 FUNCTION TRANS(MODE,CMDLINE)
      INTEGER*2 MODE
      CHARACTER*80 CMDLINE
C
C     MODIFICATION-HISTORY:
C =======================================================================
C
C     ORIGIN: CERN VERSION 1.2, JUNE 21, 1973
C
C     THIS VERSION WAS COMPLETELY REWRITTEN BY DAVID C. CAREY
C
C     1ST VAX VERSION,   SEPT 7, 1979
C
C     MODIFIED FOR PROSPERO FORTRAN-77 COMPILER (ANSI 77) FOR ATARI ST
C     BY URS ROHRER (SIN) IN JANUARY 1987
C
C     ALGEBAIC COMBINATIONS AND NEW SECOND ORDER FIT CAPABILITIES
C     (FERMILAB VERSION RUNNING AT LAMPF) ADDED TO THIS VERSION BY
C     U. ROHRER SIN 23-SEP-1982.
C
C     WIEN FILTER ELEMENT HAS BEEN ADDED TO THIS VERSION BY U.ROHRER
C     SIN 22-SEP-1981 (SEE TM-37-14 BY R.FROSCH, SEPT 1980)
C
C     MISALIGNMENT HAS BEEN TAKEN FROM CERN VERSION FEB 1978 AND ADDED
C     TO THIS VERSION BY U.ROHRER SIN IN APRIL 1982. (SEE CERN 80-04)
C     EXCEPTION: MISALIGNEMENT TABLE IS PRINTED VIA 13. 9. - CARD.
C     ALSO NEW UNITS FROM THIS VERSION.
C
C     NUMBER OF MISALIGNABLE MAGNETS INCREASED FROM 10 TO 20 BY
C     URS ROHRER (PSI), DECEMBER 1992
C
C     PERIODIC SOLUTION HAS BEEN ADDED TO THIS VERSION OF TRANSPORT
C     BY U. ROHRER SIN 26-4-1982 (PROPOSED BY W.JOHO).
C
C     SPACE CHARGE AND BUNCHER CALCULATIONS HAVE BEEN ADDED TO THIS VERSION
C     OF TRANSPORT BY U. ROHRER , SIN , NOV 1979 AND OCT 1981.
C     (SEE CERN NOTE MPS-SI/NOTE-LIN/71-7 BY F.J. SACHERER AND
C     T.R. SHERWOOD, MAY 1971)
C
C     ELECTROSTATIC ACCELERATOR (NON RELATIVISTIC LENS OPTICS) HAS BEEN
C     INCORPORATED TO THIS VERSION OF TRANSPORT BY U. ROHRER, OCT 1981.
C
C     FRINGE FIELD FOR QUADRUPOLE LENSES HAS BEEN INCLUDED LIKE IN PROG
C     GIOS (H. WOLLNIK, GIESSEN) BY U. ROHRER (SIN), JULY 1986
C
C     SOME IMPROVEMENTS FOR SPEEDING UP THE MATRIX ALGEBRA WERE INCLUDED
C     BY U. ROHRER SIN SEP/OCT-82
C
C     SOME OTHER FEATURES HAVE BEEN ADDED BY U. ROHRER ,SIN , SEPT 1979
C
C     13. 5.  PERMANENT PRINTING OF R1 MATRIX AFTER EACH ELEMENT.
C     13. 6.  PERMANENTLY OVERRIDES 13. 5. INSTRUCTION.
C     13. 7.  SUPPRESS PERMANENTLY PRINTING OF ELEMENT DATA.
C     13. 8.  PERMANENTLY OVERRIDES 13. 7. INSTRUCTION.
C
C     5.VVV     THE QUADRUPOLE APERTURE MAY BE VARIED.
C     16.0V     THE MAGNET GAP MAY BE VARIED.
C     10. 7. 7. TOTANG. DTOTANG. ; TOTAL BENDING ANGLE
C                MAY BE IMPOSED AS A CONSTRAINT.
C     -9        AS INDICATOR DEACTIVATES FIT SEQUENCE
C
C     CHARGE AND LITHIUM (PLASMA) LENS ADDED BY U. ROHRER, PSI, JAN 2001
C     ELECTROSTATIC QUADRUPOLE LENS ADDED BY U. ROHRER, PSI, FEB 2001
C     ELECTROSTATIC ACCELERATOR FOCUSSING BEHAVIOR (EXTENDED PLATES)
C     SUGGESTED BY JAY FLANZ (HARVARD UNIVERSITY, BOSTON), FEB 2001
C     TYPE CODE 11: RANDOM FITTING ENABLED BY U. ROHRER, PSI, FEB 2001
C     ELECTROSTATIC PRISM (DEFLECTOR) ADDED BY U. ROHRER, PSI,MAR 2001
C     FLOOR COORDINATES CONSTRAINTS WITH RANDOM FITTING, U. R. FEB 2002
C     OUTPUT OF FLOOR LAYOUT COORDS ON SEPARATE FILE, BY U. R. FEB 2002
C     FLOOR-LAYOUT UPD FOR ELECTROSTATIC ELEMENTS (3), BY U. R. DEC 2003
C     Error in SBR Layout corrected (THETA was wrong), by U. R. JUL 2004
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
C      DESCRIPTION OF FUNCTIONS AND SUBROUTINES
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C SUBROUTINE ACINIT COMPUTES E-FIELD GRADIENT OF ACCELERATOR VOLTAGE.
C SUBROUTINE ACRMAT GETS R-MATRIX FOR TYPE CODE 11 WITH SPACE CHARGE.
C SUBROUTINE ADVANC(I) USES O(1,*,*) X0(1,*) TO ADVANCE OTHER ARRAYS AND
C                  MATRICES ALONG BEAM LINE.
C SUBROUTINE ALTER USES CHANGE DATA IN CA(*,1) AND MODIFIES THE DATA
C                  ARRAY.
C SUBROUTINE ASSESS CALCULATES THE CURRENT VALUE OF A CONSTRAINED
C                  VARIABLE AND PLACES RESULT IN COC.
C SUBROUTINE BEAM CALCULATES THE BEAM MATRIX EITHER FROM PARAMETERS ON
C                  BEAM CARD, OR FROM SI AND RC2.
C ENTRY      CAB(C,A,B) CALCULATES MATRIX PRODUCT C = A X B, SLOW.
C SUBROUTINE CABE(C,A,B) CALCULATES MATRIX PRODUCT C = A X B. A IS
C                  THE E-MATRIX COMPUTED BY SBR EMAT.
C SUBROUTINE CABF(C,A,B) CALCULATES MATRIX PRODUCT C = A X B. A IS
C                  MATRIX FROM DRIFT OR HAS MIDPLANE SYMMETRY.
C SUBROUTINE CABT(C,A,B) CALCULATES MATRIX PRODUCT C = A X B(TRANSPOSE).
C SUBROUTINE CABTT(C,A,B) CALCULATES TRAIANGULAR MATRIX PRODUCT
C                  C = A X B(TRANSPOSE).
C SUBROUTINE CHEK(CKK) SEARCHES FOR THE BENDING MAGNET ASSOCIATED WITH
C                  2. CARD.
C SUBROUTINE CHEKQ(CKK) SEARCHES FOR THE QUAD ASSOCIATED WITH 2. CARD (F.F.)
C SUBROUTINE CLI(LOGIC) CHECKS FOR LIMITS ON 10. CARD.
C SUBROUTINE COMBIN FORMS CONSTRAINTS FROM ALGEBRAIC COMBINATIONS
C                  OF MATRIX ELEMENTS.
C SUBROUTINE CONSEC CALCULATES PARTIALS FOR SECOND ORDER FITTING.
C SUBROUTINE CONSTR CALCULATES PARTIALS AND FIRST ORDER CONSTRAINTS.
C SUBROUTINE CSABT(C,A,B,ISBK) CALCULATES MATRIX PRODUCT C = A(ISBK) X
C                  C = A(ISBK) X B.
C REAL FUNC. DELTA(I,J) KRONECKER DELTA IN UNITY MATRIX.
C REAL FUNC. DEN(X) PREVENTS DIVISION BY ZERO.
C SUBROUTINE DERIVE WALKS THROUGH BEAM LINE AND MULTIPLIES R AND T
C                  MATRICES AND THEIR DERIVATIVES FOR ENTIRE SYSTEM.
C SUBROUTINE DFOCUS CALCULATES DERIVATIVE OF MATRIX ELEMENTS OF QUAD
C                  OR DIPOLE WITH RESPECT TO B OR GRADIENT.
C SUBROUTINE DFOL PARTIALS OF R WITH RESPECT TO LENGTH FOR QUAD AND
C                  DIPOLE.
C SUBROUTINE ELECT FINDS ELECTRIC FIELD OF CHARCHE ELLIPSOID FOR
C                  SPACE CHARGE CALCULATIONS (BUNCHED BEAMS).
C SUBROUTINE ELICIT ACCUMULATES MATRICES WHEN NOT FITTING.
C SUBROUTINE ELMENT(NWK) EVALUATES NUMERICAL EFFECT OF EACH ELEMENT BY
C                  SUBSTITUTION ON ALGEBRAIC EQUATION FROM SLAC 75.
C SUBROUTINE EMAT CALCULATES TRANSFER MATRIX E FOR SPACE CHARGE FORCES.
C SUBROUTINE EXTENT CALCULATES PARTIALS RESULTING FROM A CONSTRAINT ON
C                  BEAM SIZE OR DIFFERENCES BETWEEN DESIRED OR ACTUAL
C                  VALUES.
C SUBROUTINE FITTIN READS IN ALL DATA, UNSCRAMBLES, AND FITS INTO DATA
C                  ARRAY.
C SUBROUTINE FOCUS CALCULATES R MATRIX FOR BENDING MAGNET OR QUADRUPOLE.
C SUBROUTINE FOCUSE CALCULATES R MATRIX FOR A ELECTROSTATIC PRISM.
C SUBROUTINE FORM SETS UP NORMAL EQUATIONS FOR FITTING. SEE PAGES F38 OF
C                  SLAC 91.
C SUBROUTINE GATHER COLLECTS ALL PARTIALS ALONG WITH DIFFERENCES OF
C                  CONSTRAINED QUANTITIES, AND PUTS INTO NORMAL
C                  EQUATIONS.
C SUBROUTINE GETTIT CREATES TITLE FOR EACH TYPE CODE
C SUBROUTINE HUNT2 SEARCHES FOR AN EXIT FRINGE FIELD FOR A BENDING
C                  MAGNET
C SUBROUTINE INITZE INITIALIZES ALL VARIABLES AT THE BEGINNING OF BEAM
C                  LINE TO SPECIFIED VALUES.
C SUBROUTINE INIT1 RESETS PARAMETERS THAT SHOULD BE CHANGED WHEN A BEAM
C                  CARD IS ENCOUNTERED.
C SUBROUTINE INQ INVERTS MATRIX OF NORMAL EQUATIONS FOR FITTING
C                  ROUTINE.  SEE PAGE F38 OF SLAC 91.
C SUBROUTINE IO HANDLES INPUT/OUTPUT OPTIONS VIA 13. TYPE CODE ENTRY.
C INT. FUNC. ISIGNF(K) RETURNS A FLAG ACCORDING TO THE SIGN OF A NUMBER.
C REAL FUNC. LIMIT(TYPE,N,K) IMPOSES LIMITS ON VARIED QUANTITIES.
C SUBROUTINE MADD(A,B,N) ADDS ARRAY B(N) TO A(N).
C SUBROUTINE MALIGN CALCULATES MISALIGNMENTS.
C SUBROUTINE MNEG(A,N) TRANSFORMS ARRAY A(N) INTO - A(N)
C SUBROUTINE MSMPLY(RC,TC,RA,TA,RB,TB) COMPUTES RC AND TC FROM
C                  PRELIMINARY CALCULATION.
C SUBROUTINE MSYM(A) SYMMETRIZATION OF TRIANGULAR MATRIX A.
C ENTRY      MTMPLY(RC,TC,RA,TA,RB,TB) COMPUTES RC AND TC FROM R AND T.
C                  SLOW, FOR ALL ELEMENTS BUT DRIFTS.
C SUBROUTINE MTMPLF(RC,TC,RA,TA,RB,TB) COMPUTES RC AND TC FROM R AND T.
C                  RA AND TA REPRESENT DRIFT, RB HAS MIDPLANE SYMMETRY.
C SUBROUTINE MXMPLY(RC,TC,RA,TA,RB,TB) COMPUTES RCV AND TCV FROM
C                  PRELIMINARY CALCULATIONS.
C INT. FUNC. NIV(TYPE) RETURNS TOTAL NUMBER OF POSSIBLY INDICATED VARIED
C                  PARAMETERS.
C INT. FUNC. NV(TYPE) RETURNS TOTAL NUMBER OF VARIED PARAMETERS FOR A
C                  GIVEN ELEMENT.
C SUBROUTINE OUTFIT MAKES A RUN THROUCH THE BEAM TRANSPORT ELEMENT AND
C                  PRINTS OUTPUT.
C SUBROUTINE PARSEC CALCULATES PARTIALS OF SECOND ORDER MATRIX OF A
C                  SINGLE BEAM ELEMENT WITH RESPECT TO THE VARIED
C                  QUANTITY.
C SUBROUTINE PARTLS CALCULATES PARTIALS OF FIRST ORDER MATRIX OF A
C                  SINGLE BEAM ELEMENT WITH RESPECT TO THE VARIED
C                  QUANTITY.
C SUBROUTINE PERSOL COMPUTES BEAM FOR PERIODIC SOLUTION
C SUBROUTINE PICKUP STORES BEAM MATRIX ON UPDATE FOR USE IN
C                  MISALIGNMENT CALCULATION
C SUBROUTINE PIVOT SETS UP PIVOT POINT ABOUT WHICH MISALIGNMENT IS MADE
C                  FOR AN ELEMENT OR GROUP OF ELEMENTS.
C SUBROUTINE PRINT1  PRINTS OUT THE DATA FOR ONE ELEMENT
C SUBROUTINE QEO PRINTS BEAM ENVELOPE MATRIX, ACCUMULATED LENGTH AND
C                  MAGNET COORDINATES.
C SUBROUTINE RCALC CALCULATES R OR T MATRIX WHEN IT IS TO BE PRINTED VIA
C                  A 13. 4. OR 13. 24. CARD.
C SUBROUTINE RCO PRINTS R OR T MATRICES.
C SUBROUTINE RDELMT   READS AND PRINTS DATA FOR ONE ELEMENT
C SUBROUTINE RDFLT    READS ONE FLOATING-POINT NUMBER
C SUBROUTINE RDFIX    READS ONE INTEGER
C SUBROUTINE RDNEXT   READS NEXT INPUT CHARACTER AND OPTIONALLY SKIPS
C                     BLANK CHARACTERS
C SUBROUTINE RDSTRG   READS A CHARACTER STRING
C SUBROUTINE RDUNIT   FILLS IN INCOMPLETE 15. CARDS
C SUBROUTINE REPEAT(DONE) KEEPS TRACK OF TYPE CODE 9 (REPEAT ELEMENT).
C SUBROUTINE RESET(I) RESETS MATRICES THAT ARE USED FOR MISALIGNMENT.
C SUBROUTINE RMAT COMPUTES R MATRIX FOR TYPES 3.,4.,5.,18. AND 19. .
C SUBROUTINE ROTM(J,K,X,ISBK) DOES PART OF MISALIGNMENT MATRIX
C                  MULTIPLICATION.
C SUBROUTINE SECORD CALCULATES NUMERICAL VALUE OF SECOND ORDER MATRIX
C                  ELEMENTS FROM ALGEBRAIC EQUATIONS GIVEN IN SLAC 75.
C SUBROUTINE SHFT SHIFTS BEAM CENTROID.
C REAL FUNC. SIGNF(K) RETURNS THE SIGN OF A NUMBER OR ZERO.
C SUBROUTINE SOLVE DIRECTS FITTING AND PRINTS OUT RESULTS.
C SUBROUTINE SPACEC COMPUTES R MATRIX FOR SPACE CHARGE CALCULATIONS.
C SUBROUTINE SPESHL(JA) HANDLES TYPE CODE 16. ENTRIES.
C SUBROUTINE STEPS ADVANCING R MATRICES BY ONE STEP IN SPACE CHARGE
C                  CALCULATIONS.
C SUBROUTINE TFL CALCULATES GENERAL CASE OF EQU 5 PAGE A 78 OF SLAC 91
C                  FROM O AND X0.
C SUBROUTINE UCOPY(A,X,N) COPIES N WORDS FROM A INTO X, FAST ROUTINE
C            SAME AS I = LIB$MOVC3(4*N,A,X)
C            UCOPY (MACRO SBR) IS A CERNLIB (HBOOK) LIBRARY ROUTINE.
C SUBROUTINE UNITS MAKES UNITS CHANGES VIA TYPE CODE 15. ENTRIES.
C SUBROUTINE UPDATE RESETS FLAGS SO THAT ACCUMMULATION OF THE R1 MATRIX
C                  WILL BEGIN ANEW.
C SUBROUTINE UPDAT2 SAME AS UPDATE, BUT FOR R2 MATRIX.
C SUBROUTINE UPDAT3 SAME AS UPDATE, BUT FOR R3 MATRIX.
C SUBROUTINE UPMIS UPDATES MISALIGNMENT TABLE
C SUBROUTINE UPSIG UPDATES BEAM MATRIX AND ITS PARTIALS.
C INT. FUNC. VARSEC(TYPE) KEEPS TRACK OF VARIED SECOND ORDER PARAMETERS.
C INT. FUNC. VARGAP(TYPE) USED FOR VARYING THE GAP.
C SUBROUTINE WOBBLE CALCULATES PARTIAL DERIVATIVES OF BEAM MATRIX
C                  WITH RESPECT TO MISALIGNMENT PARAMETERS
C SUBROUTINE WOE PRINTS MISALIGNMENT TABLE
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
C      DESCRIPTION OF COMMON BLOCKS AND VARIABLES
C
C ----------------------------------------------------------------------
C BLOC1               REPRESENTATION OF BEAM LINE
C NEL                    TOTAL NUMBER OF ELEMENTS IN SYSTEM
C NUM                    NUMBER OF ELEMENT CURRENTLY BEING TREATED
C I                      POINTER TO ELEMENT DATA
C IP                     LEVEL OF NESTED REPEAT"S
C ISTOR(NNL)             POINTS TO ELEMENT DATA
C DATA(NND)              STORAGE FOR TYPE CODES AND PARAMETERS
C ----------------------------------------------------------------------
C BLOC2               FORTRAN I/O UNITS
C NIN                    UNIT NUMBER FOR INPUT DATA.
C NOUT                   UNIT NUMBER FOR PRINTOUT.
C FORMIO       LOGICAL   TRUE IF FORMATTED OUTPUT DESIRED
C                        FALSE IF BINARY OUTPUT FOR PLOT.
C ----------------------------------------------------------------------
C BLOC3               PERTAINS TO A SINGLE ELEMENT
C TYPE         INTEGER   ELEMENT TYPE CODE.
C L            REAL      LENGTH OF A GIVEN ELEMENT.
C LV           REAL      DERIVATIVE OF THE LENGTH OF AN ELEMENT WITH
C                        RESPECT TO WHAT IS BEING VARIED.
C ----------------------------------------------------------------------
C BLOC4               ACCUMULATED EFFECT
C LC           REAL      TOTAL ACCUMULATED LENGTH -- PRINTED BEFORE BEAM
C                        ELLIPS.
C TOTANG                 TOTAL ANGLE
C LCV(20)      REAL      DERIVATIVES OF ACCUMULATED LENGTH
C ----------------------------------------------------------------------
C BLOC5               PERTAINS TO VARY CODES OR LABELS
C VSTOR(20)    INTEGER   STORAGE FOR INPUT VARY CODES
C TIE(NND)     INTEGER   INTERNAL (EXTERNAL) VARY CODES. CORRESPONDS
C                        TO THE DATA ARRAY.
C BLOC5A              PERTAINS TO VARY CODES OR LABELS
C LABEL(NNL)   CHAR*4    CONTAINS USER PROVIDED LABELS
C LABM(20)     CHAR*4    LABELS OF MISALIGNED ELEMENTS
C ----------------------------------------------------------------------
C BLOC6               PERIODIC SOLUTION
C PERIDX       LOGICAL   TRUE IF PERIODIC SOLUTION IN X,X' WANTED
C PERIDY       LOGICAL   TRUE IF PERIODIC SOLUTION IN Y,Y' WANTED
C PERIDC       LOGICAL   TRUE IF PERIODIC SOLUTION HAS TO BE COMPUTED
C RCPER        LOGICAL   TRUE IF PERIODIC SOLUTION IS COMPUTED
C EMITX                  HORIZONTAL EMITTANCE
C EMITY                  VERTICAL EMITTANCE
C ----------------------------------------------------------------------
C BLOC11              MATRICES FOR A SINGLE ELEMENT
C R(6,6)                 FIRST ORDER TRANSFER MATRIX.
C RV(6,6)                PARTIALS MATRIX FOR ONE OF THE VARIED
C                        PARAMETERS.
C T(6,6,6)               SECOND ORDER TRANSFER MATRIX.
C TV(6,6,6)              T PARTIALS WITH RESPECT TO ONE OF THE VARIED
C                        PARAMETERS.
C ----------------------------------------------------------------------
C BLOC12              R1 MATRICES
C RC(6,6)                CUMULATIVE R MATRIX FROM LAST R1 UPDATE THROUGH
C                        LAST R2 UPDATE.
C RCV(6,6,20)            CUMULATIVE PARTIALS MATRIX FROM LAST R1 UPDATE
C                        THROUGH LAST R2 UPDATE.
C TC(6,6,6)              CUMULATIVE T MATRIX FROM LAST R1 UPDATE THROUGH
C                        LAST R2 UPDATE.
C RCP          LOGICAL   TRUE IF ACCUMULATION OF RC HAS BEGUN.
C RVP(20)      LOGICAL   TRUE IF ACCUMULATION OF RCV HAS BEGUN
C ----------------------------------------------------------------------
C BLOC13              R2 MATRICES
C RC2(6,6)               CUMULATIVE R MATRIX FROM LAST R2 UPDATE.
C R2V(6,6,20)            CUMULATIVE PARTIALS MATRIX FROM LAST R2 UPDATE
C TC2(6,6,6)             CUMULATIVE T MATRIX FROM LAST R2 UPDATE.
C T2V(216,10)            CUMULATIVE T PARTIALS MATRIX FROM LAST R2
C                        UPDATE.
C R2P          LOGICAL   TRUE IF ACCUMULATION OF RC2 MATRIX HAS BEGUN.
C R2VP(20)     LOGICAL   TRUE IF ACCUMULATION OF R2V HAS BEGUN
C ----------------------------------------------------------------------
C BLOC14              MATRICES USED IN FITTING
C RC3(6,6)               CUMULATIVE R MATRIX BETWEEN VARIED ELEMENTS,
C                        CONSTRAINTS, OR R2 UPDATES.
C TC3(6,6,6)             SAME AS RC3, BUT FOR SECOND ORDER TERMS.
C R3P          LOGICAL   TRUE IF ACCUMULATION OF RC3 MATRIX HAS BEGUN.
C ----------------------------------------------------------------------
C BLOC15              TEMPORARY STORAGE FOR MATRIX MULTIPLY
C RS(6,6)
C RT(6,6)
C TS(6,6,6)
C TT(6,6,6)
C ----------------------------------------------------------------------
C BLOC16              BEAM MATRIX AT LAST R2 UPDATE
C SI(6,6)                SIGMA MATRIX.
C SV(6,6,20)             PARTIALS OF SI WITH RESPECT TO VARIED
C                        PARAMETERS.
C CO(6)                  BEAM CENTROID AT LAST R2 UPDATE.
C COV(6,20)              PARTIALS OF CO
C RI                     BEAM RIGIDITY (MOMENTUM).
C SVP(20)      LOGICAL   TRUE IF THE VARIED PARAMETER AFFECTS THE BEAM
C                        ELLIPSE.
C S1P          LOGICAL   TRUE IF THE BEAM CENTROID MAY BE OFF AXIS.
C ----------------------------------------------------------------------
C BLOC17
C COD(6)                 SHIFT IN BEAM CENTROID.
C ----------------------------------------------------------------------
C BLOC18              DESCRIBES BEAM AT PRESENT LOCATION
C SIT(6,6)               TEMPORARY SIGMA MATRIX, CALCULATED ONLY WHEN
C                        NEEDED.
C CEN(6)                 TEMPORARY CENTRIOD SHIFT, CALCULATED ONLY WHEN
C                        NEEDED.  PRINTED WITH BEAM MATRIX.  (R X CO).
C RECENT       LOGICAL   TRUE IF SIT REPRESENTS THE CURRENT BEAM MATRIX.
C ----------------------------------------------------------------------
C BLOC19              A STEP IN MATRIX MULTIPLICATION
C TR(6,6,6)              PRODUCT OF T X R OVER ONE INDEX ONLY.
C ----------------------------------------------------------------------
C BLOC21              TYPE 2  INPUT PARAMETERS
C EN                     TELLS IF ENTRANCE OR EXIT POLEFACE ROTATION.
C ES                     TELLS IF ENTRANCE OF EXIT POLEFACE ROTATION.
C BE                     ANGLE BETA.
C APB(2)                 PARAMETER ON 16. 4. AND 16. 5. CARDS.
C LAYL         REAL      K(1) ON 16. 7. CARD, PAGE 16-4 SLAC 91.
C LAYX         REAL      K(2) ON 16. 8. CARD, PAGE 16-4 SLAC 91.
C RAB1                   CODE 12 ON PAGE 16-3 SLAC 91.
C RAB2                   CODE 13 ON PAGE 16-3 SLAC 91.
C RINVL                  LIMIT FOR CODE 12,13 WHILE FITTING (16. 21. RINVL)
C ----------------------------------------------------------------------
C BLOC22              TYPE 2  CALCULATED QUANTITIES -- SEE PAGE 2-3 OF
C                        SLAC 91.
C BE1                    BETA - PSI.
C SB                     (1 + SIN(B)**2) / COS(B).
C TB                     TAN (BETA).
C TB1                    TAN(BE1).
C ----------------------------------------------------------------------
C BLOC23              TYPE 4
C H                      1/RADIUS OF CURVATURE.
C AL                     ANGLE OF BEND.
C NB           REAL      NORMALIZED FIELD GRADIENT (SMALL N).
C BDB                    NORMALIZED SECOND DERIVATIVE OF B.
C CHARGE                 CHARGE OF PARTICLE (DEFAULT = 1.0)
C LILENS       LOGICAL   TRUE IF QUAD IS A LITHIUM (PLASMA) LENS
C EQUAD        LOGICAL   TRUE IF QUAD IS A ELECTROSTATIC QUAD
C EBEND        LOGICAL   TRUE IF BEND IS A ELECTROSTATIC PRISM
C ----------------------------------------------------------------------
C BLOC24              TYPES 4 AND 5
C B                      FIELD IN KILOGAUSS.
C KQ2          REAL      K SQUARED TERM IN HARMONIC OSCILATOR EQUATION.
C KVK          REAL      SCALER TO MULTIPLY MATRIX TO GET PARTIAL WITH
C                        RESPECT TO B OR N.
C K2H          REAL      KQ2 FOR HORIZONTAL PLANE.
C K2V          REAL      KQ2 FOR VERTICAL PLANE.
C CS                     COSINE-LIKE FUNCTION USED IN CALCULATING THE
C                        TRANSFER MATRIX FOR A SINGLE ELEMENT.
C SN                     SINE-LIKE FUNCTION.
C CM1N                   (COS(KL) -1) / H**2.
C J                      INDEX TELLING IF HORIZONTAL OR VERTICEL PLANE.
C ----------------------------------------------------------------------
C BLOC25              TYPE 6
C AP                     APERTURE.
C CAP          LOGICAL   TRUE IF 13. 10. IS PRESENT.
C JANET                  SECOND ITEM ON A 6. CARD (ALWAYS ZERO).
C ----------------------------------------------------------------------
C BLOC26              TYPE 8  INPUT OR IMMEDIATELY CALCULATED
C                        QUANTITIES
C O(4,3,3)               TRANSFORMATIONS BETWEEN COORDINATE SYSTEMS.
C X0(4,3)                LOCATION VECTORS WITH RESPECT TO EACH OF THE
C                        FOUR COORDINATE SYSTEMS.
C IR                     INDEX TELLING IF MISALIGNMENT IS SINCE THE LAST
C                        ELEMENT, R1, OR R2 UPDATES.
C RORC         INTEGER   INDEX ON A MISALIGNMENT CARD.
C TYT          INTEGER   PARTIAL DECODING ON INDEX ON MISALIGNMENT CARD.
C ALIGN        LOGICAL   TRUE IF A MISALIGNMENT IS INCLUDED IN THIS RUN.
C TMK          LOGICAL   TRUE IF THE PIVOT POINT OF A MISALIGNMENT IS AS
C                        INDICATED ON A 13. 20/22 CARD.
C ----------------------------------------------------------------------
C BLOC27              TYPE 8  QUANTITIES USED IN MISALIGNMENT
C                        CALCULATIONS
C CT(6,6)                TERM A1 OR QUANTITY (A1-RA0) IN EQUATION (8)
C                        PAGE A-79 SLAC 91.
C CT0(6,6)               TERM A0 IN EQUATION (8) PAGE A-79 SLAC 91.
C CT1(3,3)               MATRIX USED TO EVALUATE CROSS PRODUCT.
C VM(6)                  TERM M IN EQUATION (8) PAGE A-79 SLAC 91.
C DMC           LOGICAL  INDICATOR THAT MISALIGNMENT CALCULATION IS TO
C                        BE DONE
C NM                     NUMBER OF ENTRIES IN MISALIGNMENT TABLE (<=20)
C ----------------------------------------------------------------------
C BLOC28              TYPE 10  INPUT QUANTITIES
C COC                    PRESENT VALUE OF CONSTRAINED QUANTITY.  PRINTED
C                        AFTER 10. CARD.
C DEO                    DESIRED VALUE OF CONSTRAINED QUANTITY AS GIVEN
C                        ON 10. CARD.
C SD                     TOLERANCE.
C CTY          INTEGER   INDICATES UPPER OR LOWER LIMIT OF A CONSTRAINT.
C JV                     INDEX TELLING WHICH PARAMETER OF AN ELEMENT IS
C                        BEING VARIED.
C NC                     NUMBER OF CONSTRAINTS.
C NV1                    NUMBER OF VARIED PARAMETERS ENCOUNTERED SO FAR.
C NV2                    VARIED PARAMETER CURRENTLY BEING DEALT WITH.
C NV3                    EXTRA STORAGE FOR NV1.
C ----------------------------------------------------------------------
C BLOC29              TYPE 10  PARTIALS, ETC.
C A(21)                  DIFFERENCE BETWEEN ACTUAL AND DESIRED VALUES OF
C                        CONSTRAINED QUANTITIES.
C CW                     WEIGHTING = 1/TOLERANCE SQUARED FOR CONSTRAINED
C                        QUANTITY.
C CA(21,21)              MATRIX OF NORMAL EQUATIONS
C SCALE(21)              SCALING FACTOR FOR HESSIAN
C CASAV(21,21)           CA ARRAY AT LOWEST CHI-SQUARED
C PMARQ                  MARQUARDT - LEVENBERG FIT PARAMETER
C CHSMIN                 MINIMUM VALUE OF CHI-SQUARED ENCOUNTERED
C XNORM                  MAGNITUDE OF STEP SIZE
C GNORM                  MAGNITUDE OF GRADIENT OF CHI-SQUARED
C EPS                    CONTRACTION FACTOR FOR MARQUARDT - LEVENBERG
C ----------------------------------------------------------------------
C BLOC30              TYPE 13
C CDB          INTEGER   SECOND ITEM ON A 13 CARD.
C NOR          LOGICAL   TRUE IF BEAM MATRIX IS TO BE PRINTED AFTER EACH
C                        ELEMENT.
C LAY          LOGICAL   TRUE IF A LAYOUT OF COORDINATES IS TO BE DONE
C                        VIA A 13. 12. CARD.
C ----------------------------------------------------------------------
C BLOC31              TYPE 14   ARBITRARY R MATRIX
C J1                     WHICH ROW OF ARBITRARY R MATRIX IS BEING
C                        CONSIDERED.
C TYP1         INTEGER   TYPE CODE ON LAST CARD.
C ----------------------------------------------------------------------
C BLOC32              TYPE 15   UNITS CHANGES
C UNIT(11)               CONVERSION UNITS.
C BLO32A              TYPE 15   UNITS CHANGES
C XDIME(11)    CHAR*4    NAME OF UNIT.
C DSTOR(20)    CHAR*4    NAME OF UNIT ON 15. CARD
C ----------------------------------------------------------------------
C BLOC33              TYPE 16
C FOTILT                 TILT OF FOCAL PLANE ON 16. 15. ELEMENT.
C SM                     MASS OF PARTICLES ON 16. 3. ELEMENT.
C ----------------------------------------------------------------------
C BLOC34              TYPE 17   SECOND ORDER CALCULATIONS
C SEC          LOGICAL   TRUE IF THIS IS A SECOND ORDER RUN.
C SOFA         LOGICAL   TRUE IF BEAM CENTROID IS ACTUALLY OFF AXIS AT
C                        LAST UPDATE OR BEGINNING OF SYSTEM.
C LINEAR       LOGICAL   TELLS IF FITTING PROBLEM IS LINEAR
C ----------------------------------------------------------------------
C BLOC35              TYPE 19   SOLENOID
C KL           REAL      K * LENGTH.
C KO           REAL      K TERM IN HARMONIC OSCILATOR EQUATION.
C SOLSEG       LOGICAL  TRUE IF SOLENOID IS DIVIDED INTO ENTRANCE FRINGE
C                     FIELD, HOMOGENEOUS AND EXIT FRINGE FIELD SECTIONS.
C ----------------------------------------------------------------------
C BLOC36              SECOND ORDER FITTING
C VARS(4)      INTEGER   TELLS IF SECOND ORDER PARAMETER IS BEING
C                        VARIED.
C SEXMAX                 LIMIT ON STRENGTH OF SEXTUPOLE GIVEN ON 10.N
C                        CARD.
C SEXLIM       LOGICAL   TRUE IF A LIMIT HAS BEEN IMPOSED ON THE
C                        SEXTIPOLES STRENGTHS IN A SECOND ORDER RUN.
C ----------------------------------------------------------------------
C BLOC37              INTEGRALS OF SECOND ORDER MATRIX ELEMENTS FOR
C                        BENDING MAGNETS
C INTS(22)     REAL
C ----------------------------------------------------------------------
C BLOC38
C MOR          LOGICAL   TRUE IF PERM R1 PRINT SUPPRESSED
C TOR          LOGICAL   TRUE IF ELEMENT PRINT SUPPRESSED
C ANIN         LOGICAL   TRUE IF BEND MAGNET INPUT DATA IS TO BE ANGLE
C NPFR                   POLE FACE ROTATION ANGLE SPECS OPTION
C ----------------------------------------------------------------------
C BLOC39
C VAR5         INTEGER   USED FOR GAP FITTING
C ----------------------------------------------------------------------
C BLOC40              TYPE 15  UNITS DEFINITIONS
C UORIG(11)              DEFAULT UNIT CONVERSION FACTORS
C UNTAB(21)              CONVERSION FACTORS FOR PREDIFINED UNITS
C BLO40A              TYPE 15  UNITS DEFINITIONS
C XORIG(11)    CHAR*4    DEFAULT UNIT NAMES
C XDTAB(21)    CHAR*4    NAMES FOR PREDIFINED UNITS
C ----------------------------------------------------------------------
C BLOC41              RUN TITLE, INDICATOR, DATA OF LAST ELEMENT READ
C LW                     LENGTH OF TITLE READ
C FLUSH        LOGICAL   INDICATES DATA ERROR
C INDIC                  INDICATOR
C NTYPE                  TYPE CODE OF LAST ELEMENT READ
C LENGTH                 STORAGE LENGTH REQUIRED FOR ELEMENT READ
C NWORD                  NUMBER OF DATA ITEMS READ FOR THIS ELEMENT
C NVARY                  NUMBER OF VARY CODES READ FOR THIS ELEMENT
C VARY(30)     INTEGER   VARY CODES FOR THIS ELEMENT
C DATUM(30)              DATA OF THIS ELEMENT
C BLO41A              RUN TITLE, INDICATOR, DATA OF LAST ELEMENT READ
C IMAGE(80)    CHAR*1    RUN TITLE IN (80A1)
C LABLE        CHAR*1    LABEL OF THIS ELEMENT
C --------------------------------------------------------------------
C BLOC42              CHARACTER CODES USED FOR FREE-FORMAT DECODING
C TABLE(36)    CHAR*1    DIGTS AND LETTERS
C PLUS(2)      CHAR*1    + &
C MINUS        CHAR*1    -
C BLANK        CHAR*1    BLANK SPACE
C PERIOD       CHAR*1    .
C SEMI(5)      CHAR*1    ; , * ! ?
C QUOTE(6)     CHAR*1    / ' # $ = "
C PAR1(2)      CHAR*1    ( <
C PAR2(2)      CHAR*1    ) >
C --------------------------------------------------------------------
C BLOC43              CONTAINS CURRENT INPUT CARD (LINE)
C NCD                    NUMBER OF CURRENT CARD
C MC                     CURRENT CHARACTER POSITION
C EMPTY        LOGICAL   TRUE IF CURRENT CARD HAS BEEN TERMINATED
C BLO43A              CONTAINS CURRENT INPUT CARD (LINE)
C CARD(120)    CHAR*1    CARD IMAGE, 1 CHARACTER PER MACHINE WORD
C ITEM         CHAR*1    CURRENT CHARACTER VALUE
C ----------------------------------------------------------------------
C BLOC44              LONGITUDINAL POSITIONS OF MISALIGNED SECTIONS
C BEGM(3)                BEGIN OF MISALIGNED SECTIONS (R0,R1,R2)
C BEGMS(20)              BEGIN OF MISALIGNED SECTIONS FOR TABLE
C ENDMS(20)              END OF MISALIGNED SECTIONS FOR TABLE
C ----------------------------------------------------------------------
C BLOC45              BEAM MATRIX AT BEGINNING OF MISALIGNED SECTIONS
C SIOL(3,6,6)            SAVED SIGMA MATRIX
C COLD(3,6)              SAVED BEAM CENTROID
C SPO          LOGICAL   TRUE IF SAVED BEAM CENTROID MAY BE OFF AXIS
C ----------------------------------------------------------------------
C BLOC46             INTERMEDIATE QUANTITIES IN MISALIGNMENT CALCULATION
C XM(6)                  LINEAR CENTROID DISPLACEMENT TERM
C XMB(6)                 BILINEAR CENTROID DISPLACEMENT TERM
C DXM(6)                 POSSIBLE CENTROID SHIFT WITHIN MISALIGNED
C                        SECTION
C GXXM(6)                BILINEAR MATRIX FOLDED WITH SIGMA MATRIX AND
C                        MISALIGNMENT PARAMETERS
C ---------------------------------------------------------------------
C BLOC47             STORAGE REGISTERS FOR ALGEBRAIC COMBINATIONS
C                    OF MATRIX ELEMENTS
C REG(10)                VALUES IN REGISTERS
C DREG(10,20)            PARTIAL DERIVATIVES OF VALUES IN REGISTERS
C LREG(10)               TRUE IF REGISTER HAS VALUE IN IT
C ---------------------------------------------------------------------
C BLOC48              MATRIX MULTIPLICATION
C MPS                    DEGREE OF MIDPLANE SYMMETRY (0 MEANS NO MID
C                        PLANE SYMMETRY, 1 MEANS MIDPLANE SYMMETRY.)
C DRIFT        LOGICAL   TRUE IF R AND T REPRESENT A DRIFT.
C ---------------------------------------------------------------------
C BLOC49              FITTING INFORMATION
C NL                     NUMBER OF ELEMENTS WITH VARIED PARAMETERS
C FAILED       LOGICAL   TRUE IF FIT-RUN FAILED
C ITER                   MAXIMUM NUMBER OF FIT ITERATIONS
C BLO49A              FITTING INFORMATION
C LABS(20)     CHAR*4    LABELS OF ELEMENTS WITH VARIED PARAMETERS
C ---------------------------------------------------------------------
C BLOC50              FRINGE FIELD INTEGRALS FOR QUADS
C XI1          REAL   SEE NUCL. INST. AND METH. 103 (1972) P.117-124
C XI2          REAL
C XI3          REAL
C ---------------------------------------------------------------------
C BLOC58              E-FIELD OF ELECTROSTATIC PRISM
C FIELD        REAL
C ---------------------------------------------------------------------
C BLOC59              SLITS INSTEAD OF UPDATE
C SLITS        LOGICAL   TRUE IF TYPE CODE 6 ARE SLITS
C ---------------------------------------------------------------------
C BLOC60              CONTAINS DATA FOR PLOTFILE
C ALONG        REAL      CUMULATIVE LENGTH
C CENUN(6)     REAL      BEAM CENTER
C SIUN(6)      REAL      BEAM SIZE
C R12          REAL      CORRELATION X, XP
C R34          REAL      CORRELATION Y, YP
C R56          REAL      CORRELATION L, dp/p
C R13          REAL      CORRELATION X,  Y
C R24          REAL      CORRELATION XP, YP
C
C RMTX(13)     REAL      SOME TRANSFORM*1 MATRIX-ELEMENTS
C SRMTX(105)   REAL      SECOND ORDER TRAJECTORIES
C PLOT         LOGICAL   TRUE IF IN PLOT-SECTION
C TOTROT       REAL      TOTAL ROTATION ANGLE OF BEAMLINE
C ---------------------------------------------------------------------
C BLOC62              FOR SPACEC, STEPS AND RMAT
C RL                     TOTAL LENGTH OF ELEMENT
C EFLAG        LOGICAL   TRUE IF E MATRIX HAS TO BE MULTIPLIED
C ---------------------------------------------------------------------
C BLOC63              MATRIX HANDLING
C Z216(216)           6*6*6 ZERO MATRIX
C U36(36)             6*6 UNITY MATRIX
C ---------------------------------------------------------------------
C BLOC70              FOR RANDOM OPTIMIZER
C RANOPT       LOGICAL   TRUE FOR RANDOM OPTIMIZER BEING USED
C NITER        INTEGER   NUMBER OF RANDOM ITERATIONS
C ALOW(20)     REAL      LOW LIMITS OF RANGES FOR SEARCH
C AHIGH(20)    REAL      HIGH LIMITS OF RANGES FOR SEARCH
C ---------------------------------------------------------------------
C BLOC77              FOR MISALIGNMENT
C COM(6,6,20)  REAL
C SIM(36,6,20) REAL
C ---------------------------------------------------------------------
C BLOC78              FOR ELECTROSTATIC ACCELERATOR FOCUSSING BEHAVIOR
C ICONF               0 FOR STANDARD, 1 FOR NO F IN X, 3 FOR NO F IN Y
C ---------------------------------------------------------------------
C SC                  SPACE CHARGE
C STEP                   DISTANCE BETWEEN THIN LENSES.
C AMP                    BEEM CURRENT IN AMPS.
C BFREQ                  BUNCH FREQUENCY IN MHZ.
C GAMMA                  =M/M0
C CAPPA                  SPACE CHARGE FACTOR.
C IPTFQ                  PRINT FREQUENCY FOR INTERMEDIATE OUTPUT.
C SC1P         LOGICAL   TRUE IF SPACE CHARGE CALCULATIONS.
C SC3P         LOGICAL   FALSE WHILE FITTING.
C ---------------------------------------------------------------------
C FIRST               ONE SHOT FLAGS FOR FLOW CONTROL 
C FIRST1       LOGICAL FLAG IN ACINIT (FIRST TIME TRUE, THEN FALSE)
C FIRST2       LOGICAL FLAG IN ELMENT (FIRST TIME TRUE, THEN FALSE)
C FIRST3       LOGICAL FLAG IN PLOTFL (FIRST TIME TRUE, THEN FALSE)
C FIRST3       LOGICAL FLAG IN PLOTFL (FIRST TIME TRUE, THEN FALSE)
C ---------------------------------------------------------------------
C ---------------------------------------------------------------------
C
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC3/ TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC4/ LC, TOTANG, LCV(20)
      REAL LC, LCV
      COMMON /BLOC5/ VSTOR(20), TIE(NND)
      INTEGER VSTOR, TIE
      COMMON /BLOC5A/ LABEL(NNL), LABM(20)
      CHARACTER       LABEL*4, LABM*4
      COMMON /BLOC6/ PERIDX, PERIDY, PERIDC, RCPER, EMITX, EMITY
      LOGICAL PERIDX, PERIDY, PERIDC, RCPER
      COMMON /BLOC11/ R(6,6), RV(6,6), T(6,6,6), TV(6,6,6)
      COMMON /BLOC12/ RC(6,6), RCV(6,6,20), TC(6,6,6), RCP, RVP(20)
      LOGICAL RCP, RVP
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     A                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC14/ RC3(6,6), TC3(6,6,6), R3P
      LOGICAL R3P
      COMMON /BLOC15/ RS(6,6), RT(6,6), TS(6,6,6), TT(6,6,6)
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC17/ COD(6)
      COMMON /BLOC18/ SIT(6,6), CEN(6), RECENT
      LOGICAL RECENT
      COMMON /BLOC19/ TR(6,6,6)
      COMMON /BLOC21/ EN, ES, BE, APB(2), LAYL, LAYX, RAB1,RAB2,RINVL
      REAL LAYL, LAYX
      COMMON /BLOC22/ BE1, SB, TB, TB1
      COMMON /BLOC23/ H, AL, NB, BDB, CHARGE, LILENS, EQUAD, EBEND
      REAL NB
      LOGICAL LILENS, EQUAD, EBEND
      COMMON /BLOC24/ B, KQ2, KVK, K2H, K2V, CS, SN, CM1N, J
      REAL KQ2, KVK, K2H, K2V
      COMMON /BLOC25/ AP, CAP, JANET
      LOGICAL CAP
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC27/ CT(6,6), CT0(6,6), CT1(3,3), VM(6), DMC, NM
      LOGICAL DMC
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC29/ A(21), CW, CA(21,21), SCALE(21), CASAV(21,21),
     1                PMARQ, CHSMIN, XNORM, GNORM, EPS
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
      COMMON /BLOC31/ J1, TYP1
      INTEGER TYP1
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC33/ FOTILT, SM
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      COMMON /BLOC35/ KL, KO, SOLSEG
      REAL KL, KO
      LOGICAL SOLSEG
      COMMON /BLOC36/ VARS(4), SEXMAX, SEXLIM
      INTEGER VARS
      LOGICAL SEXLIM
      COMMON /BLOC37/ INT1(2), INT2(2), INT3(2), INT4(2), INT5(2),
     A                INT6(2), INT7(2), INT8(2), INT9(2), INT10(2),
     B                INT11(2)
      REAL INT1, INT2, INT3, INT4, INT5, INT6, INT7, INT8, INT9, INT10,
     A     INT11
      COMMON /BLOC38/ MOR,TOR,ANIN,NPFR
      LOGICAL MOR,TOR,ANIN
      COMMON /BLOC40/ UORIG(11), UNTAB(21)
      COMMON /BLO40A/ XORIG(11), XDTAB(21)
      CHARACTER*4     XORIG,     XDTAB
      COMMON /BLOC41/ LW, FLUSH, INDIC, NTYPE, LENGTH,
     A                NWORD, NVARY, DATUM(30), VARY(30)
      INTEGER VARY
      LOGICAL FLUSH
      COMMON /BLO41A/ IMAGE(80), LABLE
      CHARACTER       IMAGE*1, LABLE*4
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
      COMMON /BLOC43/ NCD, MC, EMPTY
      LOGICAL EMPTY
      COMMON /BLO43A/ CARD(120), ITEM
      CHARACTER*1     CARD, ITEM
      COMMON /BLOC44/ BEGM(3), BEGMS(20), ENDMS(20)
      COMMON /BLOC45/ SIOL(3,6,6), COLD(3,6), SPO(3)
      LOGICAL SPO
      COMMON /BLOC46/ XM(6), XMB(6), DXM(6), GXXM(6,6)
      COMMON /BLOC47/ REG(10), DREG(10,20), LREG(10)
      LOGICAL LREG
      COMMON /BLOC70/ RANOPT, NITER, ALOW(20), AHIGH(20)
      LOGICAL RANOPT
      COMMON /BLOC77/ COM(6,6,20), SIM(36,6,20)
      COMMON /BLOC78/ ICONF
      COMMON/SC/STEP,AMP,BFREQ,GAMMA,CAPPA,IPTFQ,SC1P,SC3P
      LOGICAL SC1P,SC3P
C
      COMMON /FIRST/ FIRST1, FIRST2, FIRST3, FIRST4, SNTNL
      LOGICAL FIRST1, FIRST2, FIRST3, FIRST4, SNTNL
      COMMON /NNN/ NUC
C
      COMMON /SCDIR/ DIR, LDIR
      CHARACTER*80  DIR
C
      COMMON /EXITFLAG/ NNFLAG
C
      ICONF  = 0
      CHARGE = 1.0
      EQUAD  = .FALSE.
      EBEND  = .FALSE.
      LILENS = .FALSE.
      FIRST1 = .TRUE.
      FIRST2 = .TRUE.
      FIRST3 = .TRUE.
      FIRST4 = .TRUE.
      SNTNL  = .FALSE.
      NUC    = 0
      RANOPT = .FALSE.
      NNFLAG = 0
C
C     GET LENGTH OF TRANSFERRED COMMAND LINE (CONTAINS SCRATCH DIRECTORY)
C
      DIR = CMDLINE
      DO 20 J = 1, 80
       IF (ICHAR(DIR(J:J)) .EQ. 0) GO TO 21
   20 CONTINUE
   21 LDIR = J - 1
C
      NV3 = 20
C
C     OPEN OUTPUT FILE
C
      FORMIO = .TRUE.
      IF (MODE .EQ. 0) FORMIO = .FALSE.
      IF (FORMIO) THEN
       OPEN(UNIT=NOUT,FILE=DIR(1:LDIR)//'FOR002.DAT',
     *      STATUS='UNKNOWN',FORM='FORMATTED')
       REWIND NOUT
       CALL ABOUT
      ELSE
       OPEN(UNIT=NOUT+1,FILE=DIR(1:LDIR)//'FOR002.DAT',
     *      FORM='FORMATTED',STATUS='UNKNOWN')
       REWIND NOUT+1
      ENDIF
C
C     OPEN INPUT FILE
C
      OPEN (UNIT=NIN,FILE=DIR(1:LDIR)//'FOR001.DAT',
     *      STATUS='OLD',ERR=60)
      GO TO 1
   60 IF (FORMIO) WRITE(NOUT,5001)
 5001 FORMAT(' Transport Input_file not found.')
      CALL MENU(2)
      GO TO 4
C
    1 CONTINUE
      CALL FITTIN
      IF (NNFLAG .NE. 0) GO TO 4
      CALL RANINI
      NV3 = NV1
      IF(NV1 * NC .EQ. 0) GO TO 3
      IF(INDIC .LT. 0) GO TO 2
      NSAVE = NV1
      SC3P = .TRUE.
      CALL OUTFIT
      IF (NNFLAG .NE. 0) GO TO 4
      NV1 = NSAVE
    2 SC3P = .FALSE.
      IF (RANOPT) THEN
       CALL SOLVER
      ELSE
       CALL SOLVE
      ENDIF
      IF (NNFLAG .NE. 0) GO TO 4
    3 SC3P = .TRUE.
      CALL OUTFIT
      IF (NNFLAG .NE. 0) GO TO 4
      GO TO 1
C
    4 CONTINUE
      CLOSE(UNIT=0)
      CLOSE(UNIT=5)
      CLOSE(UNIT=6)
      CLOSE(UNIT=7)
      CLOSE(UNIT=29)
      TRANS = NNFLAG - 1
      RETURN
      END

      BLOCK DATA
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC27/ CT(6,6), CT0(6,6), CT1(3,3), VM(6), DMC, NM
      LOGICAL DMC
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC40/ UORIG(11), UNTAB(21)
      COMMON /BLO40A/ XORIG(11), XDTAB(21)
      CHARACTER*4     XORIG,     XDTAB
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
      COMMON /BLOC50/ XI1, XI2, XI3
      COMMON /BLOC63/ Z216(216), U36(36)
C
      DATA NIN, NOUT /5,6/
      DATA CT, CT0, CT1, VM /36*0.0,36*0.0,9*0.0,6*0.0/
      DATA   UNIT   / .01, .001, .01, .001, .01, .01, .0174533, 1.,
     A                .1, 1.704523E-3, 3.335641/
      DATA   XDIME  / 'CM  ', 'MR  ', 'CM  ', 'MR  ', 'CM  ', 'PC  ',
     A                'DEG ', 'M   ', 'KG  ', 'MO  ', 'GEV ' /
      DATA   UORIG  / .01, .001, .01, .001, .01, .01, .0174533, 1.,
     A                .1, 1.704523E-3, 3.335641/
      DATA   XORIG  / 'CM  ', 'MR  ', 'CM  ', 'MR  ', 'CM  ', 'PC  ',
     A                'DEG ', 'M   ', 'KG  ', 'MO  ', 'GEV ' /
      DATA UNTAB / 0.001, 0.01, 1.0, 1000.0, 0.0254, 0.3048,
     A             1.0, 0.001, 0.0174532925,
     B             1.0, 0.01, 0.001, 0.001, 1.0E-6,
     C             0.0001, 0.1, 1.0,
     D             3.335641E-6, 3.335641E-3, 3.335641, 1.704523E-3 /
      DATA XDTAB / 'MM  ', 'CM  ', 'M   ', 'KM  ', 'IN  ', 'FT  ',
     A             'R   ', 'MR  ', 'DEG ',
     B             'N   ', 'PC  ', 'PM  ', 'P/10', 'PPM ',
     C             'G   ', 'KG  ', 'T   ',
     D             'KEV ', 'MEV ', 'GEV ', 'MO  ' /
      DATA    TABLE / '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
     A                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
     B                'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
     C                'U', 'V', 'W', 'X', 'Y', 'Z'  /
      DATA    PLUS  / '+', '&' /
      DATA    MINUS / '-' /
      DATA    BLANK / ' ' /
      DATA    PERIOD/ '.' /
      DATA    SEMI  / ';', ',', '*', '!', '?' /
      DATA    QUOTE / '/', '''', '#', '$', '=', '"' /
      DATA    PAR1  / '(', '<' /
      DATA    PAR2  / ')', '>' /
      DATA Z216 /216*0.0/
      DATA U36  /1.,6*0.,1.,6*0.,1.,6*0.,1.,6*0.,1.,6*0.,1./
      DATA XI1, XI2, XI3 /0.209, -0.0768, 0.0552/
      END
      SUBROUTINE ACINIT(FINV,P0,PGRAD)
C
C     NEW SUBROUTINE FOR SPACE CHARGE . GETS E-FIELD-GRADIENT FOR
C     THE POTENTIAL DISTRIBUTION OF ELEMENTS OF TYPE CODE 11.
C
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC3/ TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC23/ H, AL, NB, BDB, CHARGE, LILENS, EQUAD, EBEND
      REAL NB
      LOGICAL LILENS, EQUAD, EBEND
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC33/ FOTILT, SM
      COMMON/SC/STEP,AMP,BFREQ,GAMMA,CAPPA,IPTFQ,SC1P,SC3P
      LOGICAL SC1P,SC3P
      COMMON /FIRST/ FIRST1, FIRST2, FIRST3, FIRST4, SNTNL
      LOGICAL FIRST1, FIRST2, FIRST3, FIRST4, SNTNL
C
      IF (TYPE .NE. 11) RETURN
      IF(.NOT.FIRST1) GO TO 1110
C
C     FIRST CARD GIVES ZERO LENGTH AND DEVICE VOLTAGE (KV)
C
      L=DATA(I+1)*UNIT(8)
      IF(L.NE.0.0) GO TO 1160
      VOLTS=DATA(I+2)*UNIT(11)
      E0=RI**2/((1.+GAMMA)*SM)
      E1=E0
      POT0=0.
      POT1=0.
      XPOLD=1.0
      FIRST1=.FALSE.
      GO TO 1115
C
C     ALL OTHER CARDS GIVE INCREMENT AND VOLTAGE FRACTION.
C
 1110 L=DATA(I+2)*UNIT(8)
      POT1=VOLTS*DATA(I+2)
      E1=(POT1-POT0)*CHARGE+E0
C
C     ONE INTERVENING TYPE CODE IS ALLOWED
C
 1115 ITYP1=IFIX(DATA(ISTOR(NUM+1)))
      ITYP2=IFIX(DATA(ISTOR(NUM+2)))
      IF(ITYP1.NE.11 .AND. ITYP2.NE.11) GO TO 1120
      IF(ITYP1.NE.11) GO TO 1118
      II=ISTOR(NUM+1)
      GO TO 1119
 1118 II=ISTOR(NUM+2)
C
C     GET POTENTIAL OF NEXT 11. TYPE CODE CARD
C
 1119 POT2=VOLTS*DATA(II+2)
      E2=(POT2-POT1)*CHARGE+E0
      IF(E2.LE.0.0) GO TO 1140
      XP=DATA(II+1)*UNIT(8)
      GO TO 1130
C
C     LAST ELEMENT OF TYPE CODE 11. SERIES
C
 1120 XP=1.0
      POT2=POT1
      FIRST1=.TRUE.
C
C     FINV IS NOW RELATIVISTIC (1/F=-DELTAEFIELD/2*P*V)
C
 1130 P1V1 = (E1*(2.*SM+E1)) / (SM+E1)
      FINV=-((POT2-POT1)/XP-(POT1-POT0)/XPOLD)/(2.*P1V1)
      P0=E0
      PGRAD=(E1-E0)/XPOLD
      POT0=POT1
      POT1=POT2
      E0=E1
      XPOLD=XP
      RETURN
 1140 IF (FORMIO) WRITE(NOUT,1150)
 1150 FORMAT(' PARTICLE KINETIC ENERGY GOT BELOW ZERO, TRANSPORT STOPS.
     X')
      CALL MENU(1)
      RETURN
 1160 IF (FORMIO) WRITE(NOUT,1170)
 1170 FORMAT(' FIRST LENGTH MUST BE 0.0 ,2ND ENTRY = DEVICE VOLTAGE.')
      CALL MENU(1)
      RETURN
      END
      SUBROUTINE ACRMAT(FINV,P0,PGRAD)
C
C     NEW SUBROUTINE FOR SPACE CHARGE . GETS THE R-MATRIX
C     FOR ELEMENTS OF TYPE CODE 11.
C
      COMMON /BLOC3/ TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC11/ R(6,6), RV(6,6), T(6,6,6), TV(6,6,6)
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC18/ SIT(6,6), CEN(6), RECENT
      LOGICAL RECENT
      COMMON /BLOC23/ H, AL, NB, BDB, CHARGE, LILENS, EQUAD, EBEND
      REAL NB
      LOGICAL LILENS, EQUAD, EBEND
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC33/ FOTILT, SM
      COMMON /BLOC78/ ICONF
      COMMON/SC/STEP,AMP,BFREQ,GAMMA,CAPPA,IPTFQ,SC1P,SC3P
      REAL*8 GAMMA0,GAMMA1,GAMMA2,BETO0,BETA1,BGS 
      LOGICAL SC1P,SC3P
C
C     ONLY LAST R HAS 1/F TERM, OHERWISE UNIFORM E-FIELD
C
      IF (TYPE .NE. 11) RETURN
      P1=P0+PGRAD*L
      ROLD=RI
      RI=SQRT(P1*(2.*SM+P1))

      GAMMA0 = DSQRT(1.0D00 + (DBLE(ROLD) / DBLE(SM))**2)
      BETA0  = DSQRT(GAMMA0*GAMMA0-1.0D0)/GAMMA0
      GAMMA1 = DSQRT(1.0D0+(DBLE(RI) / DBLE(SM))**2)
      BETA1  = DSQRT(GAMMA1*GAMMA1-1.0D0)/GAMMA1

      PDP=ROLD/RI
C     PDP2 IS THE INTEGRAL OF 1/MOMENTUM ,KINETIC ENERGY IS LINEARLY RISING
      RATIO=(P1+SM+RI)/(P0+SM+ROLD)
      IF(ABS(RATIO-1.).LT.0.0001 .OR. PGRAD.EQ.0.0) GO TO 10
      PDP2=ROLD/(PGRAD*L)*ALOG(RATIO)
      GO TO 20
   10 PDP2=1.0
   20 CONTINUE
C
      R(1,1)=1.
      R(1,2)=L*PDP2
      IF (ICONF .EQ. 1) THEN
       R(2,1)=0.
      ELSE
       R(2,1)=FINV
      ENDIF
      R(2,2)=PDP+L*FINV*PDP2
C
      R(3,3)=R(1,1)
      R(3,4)=R(1,2)
      IF (ICONF .EQ. 3) THEN
       R(4,3)=0.
      ELSE
       R(4,3)=FINV
      ENDIF
      R(4,4)=R(2,2)
C
      R(5,5) = BETA1 / BETA0
      R(5,6)= L / (GAMMA0*GAMMA1)
      R(6,6) = PDP * (BETA0 / BETA1)
      RECENT=.FALSE.
C
C     UPDATE POTENTIAL, GAMMA AND CAPPA
C
      P0=P1
      GAMMA2 = DSQRT(1.0D00 + (DBLE(ROLD) / DBLE(SM))**2)
      IF (CAPPA.EQ.0.0) RETURN
      BGS = GAMMA2 * GAMMA2 -1.0D0
      FMASS=1836.7267*UNIT(10)/SM
      IF (BFREQ.EQ.0.0)
     X CAPPA = .1275D-6*DBLE(AMP*CHARGE)*DBLE(FMASS)/(BGS*DSQRT(BGS))
      IF (BFREQ.NE.0.0)
     X CAPPA = 20.7D-6*DBLE(AMP*CHARGE)*DBLE(FMASS)/(DBLE(BFREQ)*BGS)

      GAMMA = GAMMA2
      RETURN
      END
      SUBROUTINE ADVANC(I)
      COMMON /BLOC12/ RC(6,6), RCV(6,6,20), TC(6,6,6), RCP, RVP(20)
      LOGICAL RCP, RVP
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     A                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC14/ RC3(6,6), TC3(6,6,6), R3P
      LOGICAL R3P
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      REAL O1(3,3)
C
      IF (I .EQ. 3 .AND. .NOT. (R2P .OR. R3P)) GO TO 10
      IF (I .EQ. 2 .AND. .NOT. (RCP .OR. R2P .OR. R3P)) GO TO 10
C
      DO 3 J = 1, 3
      S = 0.0
      DO  2  K =  1,3,1
      S1 = 0.0
      DO 1 L = 1, 3
      S1 = S1 + O(1,J,L)*O(I,L,K)
    1 CONTINUE
      O1(J,K)  =  S1
      S = S + O(I,K,J)*X0(1,K)
    2 CONTINUE
      X0(I,J) = X0(I,J) + S
    3 CONTINUE
      DO  4  J = 1,3,1
      DO  4  J1= 1,3,1
      O(I,J1,J) = O1(J1,J)
    4 CONTINUE
      RETURN
C
   10 DO 11 J = 1, 3
      X0(3,J) = X0(1,J)
      DO 11 K = 1, 3
      O(3,J,K) = O(1,J,K)
   11 CONTINUE
      RETURN
      END
      SUBROUTINE ALTER(CHANGE)
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC5/ VSTOR(20), TIE(NND)
      INTEGER VSTOR, TIE
      COMMON /BLOC5A/ LABEL(NNL), LABM(20)
      CHARACTER       LABEL*4, LABM*4
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC29/ A(21), CW, CA(21,21), SCALE(21), CASAV(21,21),
     1                PMARQ, CHSMIN, XNORM, GNORM, EPS
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
      INTEGER TYPE, VARY
      REAL CHANGE(21)
      REAL LIMIT
C
C     CHANGE VARIED PARAMETERS TO NEW VALUES
C
      DO 80 IRU = 1, 2
      DO 70 NUM = 1, NEL
      I = ISTOR(NUM)
      TYPE = DATA(I)
      IF (TYPE .LE. 0) GO TO 70
      NVT = NIV(TYPE)
      IF (NVT .LT. 1) GO TO 70
      DO 60 J = 1, NVT
      IPLUSJ = I + J
      VARY = TIE(IPLUSJ)
      IF (VARY .EQ. 0) GO TO 60
      IVARY = IABS(VARY)
      SIG = SIGNF(VARY)
      X2 = DATA(IPLUSJ) + SIG*CHANGE(IVARY+1)
      IF (IRU .EQ. 2) GO TO 50
C
C     LOWER LIMIT TEST
C
      SI = LIMIT(TYPE,J,2)
      IF (SI .EQ. 0.0) GO TO 30
      SI = LIMIT(TYPE,J,1)
      IF (X2 .GE. SI) GO TO 30
      X2 = MAX(X2,SI)
      GO TO 40
C
C     UPPER LIMIT TEST
C
   30 SI = LIMIT(TYPE,J,4)
      IF (SI .EQ. 0.0) GO TO 60
      SI = LIMIT(TYPE,J,3)
      IF (X2 .LE. SI) GO TO 60
      X2 = MIN(X2,SI)
   40 CHANGE(IVARY+1) = (X2 - DATA(IPLUSJ))*SIG
      GO TO 60
   50 DATA(IPLUSJ) = X2
   60 CONTINUE
   70 CONTINUE
   80 CONTINUE
C
C     PRINT OUT CHANGES APPLIED
C
      IF (.NOT.FORMIO) RETURN
      WRITE (NOUT,1000) EPS, CA(1,1), (CHANGE(J+1), J = 1, NV1)
 1000 FORMAT (1X,E12.5,1X,'(',E12.5,')',10F10.4/28X,10F10.4)
      RETURN
      END
      SUBROUTINE ASSESS
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC4/  LC, TOTANG, LCV(20)
      REAL LC, LCV
      COMMON /BLOC12/ RC(6,6), RCV(6,6,20), TC(6,6,6), RCP, RVP(20)
      LOGICAL RCP, RVP
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     1                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     1                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC18/ SIT(6,6), CEN(6), RECENT
      LOGICAL RECENT
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC47/ REG(10), DREG(10,20), LREG(10)
      LOGICAL LREG
      DIMENSION TS2(6,6)
      DATA PI /3.141592654/
C
      J = DATA(I + 1)
      K = DATA(I + 2)
      IF (J .EQ. 7 .AND. K .EQ. 7) GO TO 10
      IF (J .EQ. 0 .AND. K .EQ. 0) GO TO 50
      IF (J .EQ. 8) GO TO 60
      IF (J .EQ. 9) GO TO 95
      IF (J .EQ. 18) GO TO 1150
      IF (J .EQ. 100) GO TO 1200
      IF (J .LT. - 20) GO TO 100
      IF (J .LT. - 10) GO TO 150
      IF (J .LT. 0) GO TO 200
      GO TO 250
C
C     TOTAL BENDING ANGLE CONSTRAINT
C
   10 COC = TOTANG / UNIT(7)
      RETURN
C
C     SYSTEM LENGTH CONSTRAINT
C
   50 COC = LC / UNIT(8)
      RETURN
C
C     FLOOR COORDINATE CONSTRAINT
C
   60 IF (K .GE. 4) GO TO 70
      COC = X0(4,K)/UNIT(8)
      RETURN
C
   70 IF (K .EQ. 5) GO TO 80
      IF (K .EQ. 6) GO TO 90
C
      THETA = ATAN(O(4,3,1)/O(4,3,3))
      IF (O(4,3,3) .GE. 0.0) GO TO 72
      SHIFT = SIGN(PI,O(4,3,1))
      THETA = SHIFT - THETA
   72 COC = THETA/UNIT(7)
      RETURN
C
   80 COC = ASIN(O(4,3,2))/UNIT(7)
      RETURN
C
   90 PITCH = ATAN(O(4,1,2)/O(4,2,2))
      IF (O(4,2,2) .GE. 0.0) GO TO 92
      SHIFT = SIGN(PI,O(4,1,2))
      PITCH = SHIFT - PITCH
   92 COC = PITCH/UNIT(7)
      RETURN
C
C     CONSTRAINT ON ALGEBRAIC COMBINATION OF MATRIX ELEMENTS
C
   95 COC = 0.0
      IF (K .GT. 10) RETURN
      IF (LREG(K)) COC = REG(K)
      RETURN
C
C     R2 MATRIX CONSTRAINT
C
  100 JMIN2  =  -( J + 20 )
      IF (K .GT. 10) GO TO 1050
      COC = RC2(JMIN2,K) * UNIT(K) / UNIT(JMIN2)
      RETURN
C
C     AGS MACHINE CONSTRAINT
C
  150 JMIN1  =  -(10 + J)
      IF (RCP) GO TO 155
      COC = 0.5*(RC2(JMIN1,JMIN1) + RC2(K,K))
      GO TO 170
  155 IF (R2P) GO TO 160
      COC  =  0.5 * ( RC(JMIN1,JMIN1) + RC(K,K)  )
      GO TO 170
  160 COC = 0.0
      DO 165 L1 = 1, 6
      COC = COC + RC2(JMIN1,L1)*RC(L1,JMIN1) + RC2(K,L1)*RC(L1,K)
  165 CONTINUE
      COC = 0.5*COC
  170 IF (ABS(COC) .LE. 1.0) GO TO 180
      IF (FORMIO) WRITE (NOUT,9010)
 9010 FORMAT('       ARGUMENT OF ARCCOSINE GREATER THAN ONE')
      COC = 0.0
      RETURN
  180 COC = ACOS(COC)/6.28318
      RETURN
C
C     R MATRIX CONSTRAINT
C
  200 JMIN  =  -J
      IF (K .GT. 10) GO TO 1050
      IF (RCP) GO TO 210
      COC = RC2(JMIN,K)*UNIT(K)/UNIT(JMIN)
      RETURN
  210 IF (R2P) GO TO 220
      COC  =  RC(JMIN,K) * UNIT(K) / UNIT(JMIN)
      RETURN
  220 COC = 0.0
      DO 230 L1 = 1, 6
      COC = COC + RC2(JMIN,L1)*RC(L1,K)
  230 CONTINUE
      COC = COC*UNIT(K)/UNIT(JMIN)
      RETURN
C
C     CONSTRAINTS ON BEAM MATRIX
C
  250 IF (.NOT. RECENT) CALL BEAM
      IF (J .EQ. K) GO TO 300
      IF (J .GT. 10) GO TO 350
      IF (J .EQ. 0 .OR. J .EQ. 7) GO TO 450
      GO TO 400
C
C     BEAM SIZE CONSTRAINT
C
  300 COC = SIT(J,J)
      IF (S1P) COC = COC - CEN(J)*CEN(K)
      COC = SQRT(COC)/UNIT(J)
      RETURN
C
C     BEAM CORRELATION CONSTRAINT
C
  350 JMIN = J - 10
      SIJK = SIT(JMIN,K)
      SIJJ = SIT(JMIN,JMIN)
      SIKK = SIT(K,K)
      IF (.NOT. S1P) GO TO 360
      SIJK = SIJK - CEN(J)*CEN(K)
      SIJJ = SIJJ - CEN(J)**2
      SIKK = SIKK - CEN(K)**2
  360 COC = SIJK/SQRT(SIJJ*SIKK)
      RETURN
C
C     BEAM MATRIX CONSTRAINT
C
  400 COC = SIT(J,K)
      IF (S1P) COC = COC - CEN(J)*CEN(K)
      COC = COC/(UNIT(J)*UNIT(K))
      RETURN
C
C     FIRST MOMENT CONSTRAINT
C
  450 COC = CEN(K)/UNIT(K)
      RETURN
C
C     T MATRIX CONSTRAINT
C
 1050 KM = K
      K = KM/10
      M = KM-10*K
      IF (J .LT. - 20) J = J + 20
      J = - J
      COC = TC2(J,K,M)*UNIT(K)*UNIT(M)/UNIT(J)
      IF (K .NE. M) COC = 2.0*COC
      RETURN
C
C     LIMITATIONS ON SEXTUPOLE STRENGTH
C
 1150 COC = 0.0
      RETURN
C
C     NUMERICAL CONSTANT
C
 1200 COC = DATA(I+2)
      RETURN
      END
      SUBROUTINE BEAM
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     A                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC14/ RC3(6,6), TC3(6,6,6), R3P
      LOGICAL R3P
      COMMON /BLOC15/ RS(6,6), RT(6,6), TS(6,6,6), TT(6,6,6)
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC18/ SIT(6,6), CEN(6), RECENT
      LOGICAL RECENT
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      COMMON /BLOC63/ Z216(216), U36(36)
      DIMENSION CIM(6), CIM1(6)
C
      IF (R3P) CALL UPDAT3
      CALL UCOPY(Z216,CEN,6)
      IF (R2P) GO TO 200
      CALL UCOPY(SI,SIT,36)
      IF (SOFA) CALL UCOPY(CO,CEN,6)
      RETURN
C
C     FIRST ORDER BEAM MATRIX
C
  200 CALL CAB(RS,RC2,SI)
      CALL CABTT(SIT,RS,RC2)
      IF (.NOT. SOFA) GO TO 300
      DO 260 J = 1, 6
      SS = 0.0
      DO 255 K = 1, 6
      SS = SS + RC2(J,K)*CO(K)
  255 CONTINUE
      CEN(J) = SS
  260 CONTINUE
  300 IF (.NOT. SEC) GO TO 500
C
C     SECOND ORDER CONTRIBUTIONS
C
      IF (SOFA) CALL UCOPY(CEN,CIM1,6)
  350 DO 360 J = 1, 5
      SS = 0.0
      DO 355 K = 1, 6
      DO 355 L1 = 1, 6
      SS = SS + TC2(J,K,L1)*SI(K,L1)
  355 CONTINUE
      CEN(J) = SS
  360 CONTINUE
      IF (SOFA) CALL MADD(CEN,CIM1,6)
  400 DO 410 J = 1, 5
      DO 410 K = 1, 6
      DO 410 L1 = 1, 6
      SS = 0.0
      DO 405 L2 = 1, 6
      SS = SS + TC2(J,K,L2)*SI(L1,L2)
  405 CONTINUE
      TS(J,K,L1) = SS
  410 CONTINUE
      IF (.NOT. SOFA) GO TO 430
      DO 420 J = 1, 6
      DO 420 K = 1, 6
      DO 420 L1 = 1, 6
      TS(J,K,L1) = TS(J,K,L1) + RC2(J,K)*CO(L1)
  420 CONTINUE
  430 DO 450 J = 1, 6
      DO 450 K = 1, J
      TSST = 0.0
      DO 440 L1 = 1, 6
      DO 440 L2 = 1, 6
      TSST = TSST + TS(J,L1,L2)*TS(K,L2,L1)
  440 CONTINUE
      SIT(J,K) = SIT(J,K) + CEN(J)*CEN(K) + 2.0*TSST
  450 CONTINUE
      IF (.NOT. SOFA) GO TO 500
      DO 460 J = 1, 6
      SS = 0.0
      DO 455 K = 1, 6
      SS = SS + RC2(J,K)*CO(K)
      DO 455 L1 = 1, 6
      SS = SS + TC2(J,K,L1)*CO(K)*CO(L1)
  455 CONTINUE
      CIM(J) = SS
  460 CONTINUE
      DO 480 J = 1, 6
      DO 480 K = 1, J
      SIT(J,K) = SIT(J,K) - 2.0*CIM(J)*CIM(K) - CIM1(J)*CIM1(K)
  480 CONTINUE
C
C     SYMMETRIZATION OF RESULT
C
  500 CALL MSYM(SIT)
      RECENT = .TRUE.
      RETURN
      END
      SUBROUTINE CABE(C,A,B)
      COMMON/SC/STEP,AMP,BFREQ,GAMMA,CAPPA,IPTFQ,SC1P,SC3P
      LOGICAL SC1P,SC3P
      DIMENSION C(36), A(36), B(36)
      CALL UCOPY(B,C,36)
      C( 2) = A( 2) * B( 1) + B( 2) + A(14) * B( 3)
      C( 8) = A( 2) * B( 7) + B( 8) + A(14) * B( 9)
      C(14) = A( 2) * B(13) + B(14) + A(14) * B(15)
      C(20) = A( 2) * B(19) + B(20) + A(14) * B(21)
      C(26) = A( 2) * B(25) + B(26) + A(14) * B(27)
      C(32) = A( 2) * B(31) + B(32) + A(14) * B(33)
C
      C( 4) = A( 4) * B( 1) + A(16) * B( 3) + B( 4)
      C(10) = A( 4) * B( 7) + A(16) * B( 9) + B(10)
      C(16) = A( 4) * B(13) + A(16) * B(15) + B(16)
      C(22) = A( 4) * B(19) + A(16) * B(21) + B(22)
      C(28) = A( 4) * B(25) + A(16) * B(27) + B(28)
      C(34) = A( 4) * B(31) + A(16) * B(33) + B(34)
C
      IF (BFREQ.EQ.0.) RETURN
C
      C( 2) = C( 2) + A(26) * B( 5)
      C( 8) = C( 8) + A(26) * B(11)
      C(14) = C(14) + A(26) * B(17)
      C(20) = C(20) + A(26) * B(23)
      C(26) = C(26) + A(26) * B(29)
      C(32) = C(32) + A(26) * B(35)
C
      C( 4) = C( 4) + A(28) * B( 5)
      C(10) = C(10) + A(28) * B(11)
      C(16) = C(16) + A(28) * B(17)
      C(22) = C(22) + A(28) * B(23)
      C(28) = C(28) + A(28) * B(29)
      C(34) = C(34) + A(28) * B(35)
C
      C( 6) = A( 6) * B( 1) + A(18) * B( 3) + A(30) * B( 5) + B( 6)
      C(12) = A( 6) * B( 7) + A(18) * B( 9) + A(30) * B(11) + B(12)
      C(18) = A( 6) * B(13) + A(18) * B(15) + A(30) * B(17) + B(18)
      C(24) = A( 6) * B(19) + A(18) * B(21) + A(30) * B(23) + B(24)
      C(30) = A( 6) * B(25) + A(18) * B(27) + A(30) * B(29) + B(30)
      C(36) = A( 6) * B(31) + A(18) * B(33) + A(30) * B(35) + B(36)
      RETURN
      END
      SUBROUTINE CABF(C,A,B)
      COMMON /BLOC3/ TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC48/ MPS, DRIFT
      LOGICAL DRIFT
      COMMON /BLOC63/ Z216(216), U36(36)
      DIMENSION C(36), A(36), B(36)
C
      IF (DRIFT) GO TO 20
      IF (MPS .EQ. 1) GO TO 10
C     ----------------
      ENTRY CAB(C,A,B)
C     ----------------
      C( 1) = A( 1) * B( 1) + A( 7) * B( 2) + A(13) * B( 3)
     X      + A(19) * B( 4) + A(25) * B( 5) + A(31) * B( 6)
      C( 2) = A( 2) * B( 1) + A( 8) * B( 2) + A(14) * B( 3)
     X      + A(20) * B( 4) + A(26) * B( 5) + A(32) * B( 6)
      C( 3) = A( 3) * B( 1) + A( 9) * B( 2) + A(15) * B( 3)
     X      + A(21) * B( 4) + A(27) * B( 5) + A(33) * B( 6)
      C( 4) = A( 4) * B( 1) + A(10) * B( 2) + A(16) * B( 3)
     X      + A(22) * B( 4) + A(28) * B( 5) + A(34) * B( 6)
      C( 5) = A( 5) * B( 1) + A(11) * B( 2) + A(17) * B( 3)
     X      + A(23) * B( 4) + A(29) * B( 5) + A(35) * B( 6)
      C( 6) = A( 6) * B( 1) + A(12) * B( 2) + A(18) * B( 3)
     X      + A(24) * B( 4) + A(30) * B( 5) + A(36) * B( 6)
C
      C( 7) = A( 1) * B( 7) + A( 7) * B( 8) + A(13) * B( 9)
     X      + A(19) * B(10) + A(25) * B(11) + A(31) * B(12)
      C( 8) = A( 2) * B( 7) + A( 8) * B( 8) + A(14) * B( 9)
     X      + A(20) * B(10) + A(26) * B(11) + A(32) * B(12)
      C( 9) = A( 3) * B( 7) + A( 9) * B( 8) + A(15) * B( 9)
     X      + A(21) * B(10) + A(27) * B(11) + A(33) * B(12)
      C(10) = A( 4) * B( 7) + A(10) * B( 8) + A(16) * B( 9)
     X      + A(22) * B(10) + A(28) * B(11) + A(34) * B(12)
      C(11) = A( 5) * B( 7) + A(11) * B( 8) + A(17) * B( 9)
     X      + A(23) * B(10) + A(29) * B(11) + A(35) * B(12)
      C(12) = A( 6) * B( 7) + A(12) * B( 8) + A(18) * B( 9)
     X      + A(24) * B(10) + A(30) * B(11) + A(36) * B(12)
C
      C(13) = A( 1) * B(13) + A( 7) * B(14) + A(13) * B(15)
     X      + A(19) * B(16) + A(25) * B(17) + A(31) * B(18)
      C(14) = A( 2) * B(13) + A( 8) * B(14) + A(14) * B(15)
     X      + A(20) * B(16) + A(26) * B(17) + A(32) * B(18)
      C(15) = A( 3) * B(13) + A( 9) * B(14) + A(15) * B(15)
     X      + A(21) * B(16) + A(27) * B(17) + A(33) * B(18)
      C(16) = A( 4) * B(13) + A(10) * B(14) + A(16) * B(15)
     X      + A(22) * B(16) + A(28) * B(17) + A(34) * B(18)
      C(17) = A( 5) * B(13) + A(11) * B(14) + A(17) * B(15)
     X      + A(23) * B(16) + A(29) * B(17) + A(35) * B(18)
      C(18) = A( 6) * B(13) + A(12) * B(14) + A(18) * B(15)
     X      + A(24) * B(16) + A(30) * B(17) + A(36) * B(18)
C
      C(19) = A( 1) * B(19) + A( 7) * B(20) + A(13) * B(21)
     X      + A(19) * B(22) + A(25) * B(23) + A(31) * B(24)
      C(20) = A( 2) * B(19) + A( 8) * B(20) + A(14) * B(21)
     X      + A(20) * B(22) + A(26) * B(23) + A(32) * B(24)
      C(21) = A( 3) * B(19) + A( 9) * B(20) + A(15) * B(21)
     X      + A(21) * B(22) + A(27) * B(23) + A(33) * B(24)
      C(22) = A( 4) * B(19) + A(10) * B(20) + A(16) * B(21)
     X      + A(22) * B(22) + A(28) * B(23) + A(34) * B(24)
      C(23) = A( 5) * B(19) + A(11) * B(20) + A(17) * B(21)
     X      + A(23) * B(22) + A(29) * B(23) + A(35) * B(24)
      C(24) = A( 6) * B(19) + A(12) * B(20) + A(18) * B(21)
     X      + A(24) * B(22) + A(30) * B(23) + A(36) * B(24)
C
      C(25) = A( 1) * B(25) + A( 7) * B(26) + A(13) * B(27)
     X      + A(19) * B(28) + A(25) * B(29) + A(31) * B(30)
      C(26) = A( 2) * B(25) + A( 8) * B(26) + A(14) * B(27)
     X      + A(20) * B(28) + A(26) * B(29) + A(32) * B(30)
      C(27) = A( 3) * B(25) + A( 9) * B(26) + A(15) * B(27)
     X      + A(21) * B(28) + A(27) * B(29) + A(33) * B(30)
      C(28) = A( 4) * B(25) + A(10) * B(26) + A(16) * B(27)
     X      + A(22) * B(28) + A(28) * B(29) + A(34) * B(30)
      C(29) = A( 5) * B(25) + A(11) * B(26) + A(17) * B(27)
     X      + A(23) * B(28) + A(29) * B(29) + A(35) * B(30)
      C(30) = A( 6) * B(25) + A(12) * B(26) + A(18) * B(27)
     X      + A(24) * B(28) + A(30) * B(29) + A(36) * B(30)
C
      C(31) = A( 1) * B(31) + A( 7) * B(32) + A(13) * B(33)
     X      + A(19) * B(34) + A(25) * B(35) + A(31) * B(36)
      C(32) = A( 2) * B(31) + A( 8) * B(32) + A(14) * B(33)
     X      + A(20) * B(34) + A(26) * B(35) + A(32) * B(36)
      C(33) = A( 3) * B(31) + A( 9) * B(32) + A(15) * B(33)
     X      + A(21) * B(34) + A(27) * B(35) + A(33) * B(36)
      C(34) = A( 4) * B(31) + A(10) * B(32) + A(16) * B(33)
     X      + A(22) * B(34) + A(28) * B(35) + A(34) * B(36)
      C(35) = A( 5) * B(31) + A(11) * B(32) + A(17) * B(33)
     X      + A(23) * B(34) + A(29) * B(35) + A(35) * B(36)
      C(36) = A( 6) * B(31) + A(12) * B(32) + A(18) * B(33)
     X      + A(24) * B(34) + A(30) * B(35) + A(36) * B(36)
      RETURN
C
   10 CALL UCOPY(Z216,C,36)
C
      C( 1) = A( 1) * B( 1) + A( 7) * B( 2)
      C( 2) = A( 2) * B( 1) + A( 8) * B( 2)
      C( 5) = A( 5) * B( 1) + A(11) * B( 2) + A(29) * B( 5)
C
      C( 7) = A( 1) * B( 7) + A( 7) * B( 8)
      C( 8) = A( 2) * B( 7) + A( 8) * B( 8)
      C(11) = A( 5) * B( 7) + A(11) * B( 8) + A(29) * B(11)
C
      C(15) = A(15) * B(15) + A(21) * B(16)
      C(16) = A(16) * B(15) + A(22) * B(16)
C
      C(21) = A(15) * B(21) + A(21) * B(22)
      C(22) = A(16) * B(21) + A(22) * B(22)
C
      C(29) = A(29) * B(29)
C
      C(31) = A( 1) * B(31) + A( 7) * B(32) + A(31) * B(36)
      C(32) = A( 2) * B(31) + A( 8) * B(32) + A(32) * B(36)
      C(35) = A( 5) * B(31) + A(11) * B(32)
     X      + A(29) * B(35) + A(35) * B(36)
      C(36) = A(36) * B(36)
      RETURN
C
   20 CALL UCOPY(B,C,36)
C
      C( 1) = C( 1) + L * C( 2)
      C( 3) = C( 3) + L * C( 4)
      C( 7) = C( 7) + L * C( 8)
      C( 9) = C( 9) + L * C(10)
      C(13) = C(13) + L * C(14)
      C(15) = C(15) + L * C(16)
      C(19) = C(19) + L * C(20)
      C(21) = C(21) + L * C(22)
      C(25) = C(25) + L * C(26)
      C(27) = C(27) + L * C(28)
      C(31) = C(31) + L * C(32)
      C(33) = C(33) + L * C(34)
C
      X = A(35)
      IF (X .EQ. 0.) RETURN
      C( 5) = C( 5) + X * C( 6)
      C(11) = C(11) + X * C(12)
      C(17) = C(17) + X * C(18)
      C(23) = C(23) + X * C(24)
      C(29) = C(29) + X * C(30)
      C(35) = C(35) + X * C(36)
      RETURN
      END
      SUBROUTINE CABT(C,A,B)
      DIMENSION C(6,6), A(6,6), B(6,6)
C
      DO 1 I = 1, 6
      DO 1 J = 1, I
      S = 0.0
      DO 4 K = 1, 6
      S = S + A(I,K) * B(J,K)
    4 CONTINUE
      C(I,J) = S
      C(J,I)  =  S
    1 CONTINUE
      RETURN
      END
      SUBROUTINE CABTT(C,A,B)
      DIMENSION C(36), A(36), B(36)
C
      C( 1) = A( 1) * B( 1) + A( 7) * B( 7) + A(13) * B(13)
     X      + A(19) * B(19) + A(25) * B(25) + A(31) * B(31)
      C( 2) = A( 2) * B( 1) + A( 8) * B( 7) + A(14) * B(13)
     X      + A(20) * B(19) + A(26) * B(25) + A(32) * B(31)
      C( 3) = A( 3) * B( 1) + A( 9) * B( 7) + A(15) * B(13)
     X      + A(21) * B(19) + A(27) * B(25) + A(33) * B(31)
      C( 4) = A( 4) * B( 1) + A(10) * B( 7) + A(16) * B(13)
     X      + A(22) * B(19) + A(28) * B(25) + A(34) * B(31)
      C( 5) = A( 5) * B( 1) + A(11) * B( 7) + A(17) * B(13)
     X      + A(23) * B(19) + A(29) * B(25) + A(35) * B(31)
      C( 6) = A( 6) * B( 1) + A(12) * B( 7) + A(18) * B(13)
     X      + A(24) * B(19) + A(30) * B(25) + A(36) * B(31)
C
      C( 8) = A( 2) * B( 2) + A( 8) * B( 8) + A(14) * B(14)
     X      + A(20) * B(20) + A(26) * B(26) + A(32) * B(32)
      C( 9) = A( 3) * B( 2) + A( 9) * B( 8) + A(15) * B(14)
     X      + A(21) * B(20) + A(27) * B(26) + A(33) * B(32)
      C(10) = A( 4) * B( 2) + A(10) * B( 8) + A(16) * B(14)
     X      + A(22) * B(20) + A(28) * B(26) + A(34) * B(32)
      C(11) = A( 5) * B( 2) + A(11) * B( 8) + A(17) * B(14)
     X      + A(23) * B(20) + A(29) * B(26) + A(35) * B(32)
      C(12) = A( 6) * B( 2) + A(12) * B( 8) + A(18) * B(14)
     X      + A(24) * B(20) + A(30) * B(26) + A(36) * B(32)
C
      C(15) = A( 3) * B( 3) + A( 9) * B( 9) + A(15) * B(15)
     X      + A(21) * B(21) + A(27) * B(27) + A(33) * B(33)
      C(16) = A( 4) * B( 3) + A(10) * B( 9) + A(16) * B(15)
     X      + A(22) * B(21) + A(28) * B(27) + A(34) * B(33)
      C(17) = A( 5) * B( 3) + A(11) * B( 9) + A(17) * B(15)
     X      + A(23) * B(21) + A(29) * B(27) + A(35) * B(33)
      C(18) = A( 6) * B( 3) + A(12) * B( 9) + A(18) * B(15)
     X      + A(24) * B(21) + A(30) * B(27) + A(36) * B(33)
C
      C(22) = A( 4) * B( 4) + A(10) * B(10) + A(16) * B(16)
     X      + A(22) * B(22) + A(28) * B(28) + A(34) * B(34)
      C(23) = A( 5) * B( 4) + A(11) * B(10) + A(17) * B(16)
     X      + A(23) * B(22) + A(29) * B(28) + A(35) * B(34)
      C(24) = A( 6) * B( 4) + A(12) * B(10) + A(18) * B(16)
     X      + A(24) * B(22) + A(30) * B(28) + A(36) * B(34)
C
      C(29) = A( 5) * B( 5) + A(11) * B(11) + A(17) * B(17)
     X      + A(23) * B(23) + A(29) * B(29) + A(35) * B(35)
      C(30) = A( 6) * B( 5) + A(12) * B(11) + A(18) * B(17)
     X      + A(24) * B(23) + A(30) * B(29) + A(36) * B(35)
C
      C(36) = A( 6) * B( 6) + A(12) * B(12) + A(18) * B(18)
     X      + A(24) * B(24) + A(30) * B(30) + A(36) * B(36)
      RETURN
      END
      SUBROUTINE CHEK (CKK)
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC21/ EN, ES, BE, APB(2), LAYL, LAYX, RAB1,RAB2,RINVL
      REAL LAYL, LAYX
      COMMON /BLOC23/ H, AL, NB, BDB, CHARGE, LILENS, EQUAD, EBEND
      REAL NB
      LOGICAL LILENS, EQUAD, EBEND
      COMMON /BLOC24/ B, KQ2, KVK, K2H, K2V, CS, SN, CM1N, J
      REAL KQ2, KVK, K2H, K2V
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC38/ MOR,TOR,ANIN,NPFR
      LOGICAL MOR,TOR,ANIN
      REAL L
      CKK = 1.
C
C* CHEK TO SEE IF INTERVENING CARDS ARE I/O CONTROLS
C
      J = NUM
      DO 10 K = 1, 5
      J = J + 1
      IF(J .GT. NEL) GO TO 20
      II = ISTOR(J)
      IF(DATA(II) .EQ. 4.0) GO TO 50
      IF(DATA(II) .NE. 13.0) GO TO 20
   10 CONTINUE
   20 J = NUM
      DO 30 K = 1, 5
      J = J - 1
      IF(J .LE. 0) GO TO 40
      II = ISTOR(J)
      IF(DATA(II) .EQ. 4.0) GO TO 60
      IF(DATA(II) .NE. 13.0) GO TO 40
   30 CONTINUE
   40 IF (FORMIO) WRITE (NOUT, 140)
  140 FORMAT('0*** 4. TYPE CODE NOT FOUND FOR 2. TYPE CODE')
      CKK = 0.
      RETURN
C
C     SET FRINGING FIELD PARAMETERS
C
   50 ES = 1.0
      EN = 1.0
      GO TO 70
   60 ES = - 1.0
      EN = 0.0
   70 L = DATA(II+1) * UNIT(8)
      IF(.NOT.ANIN) THEN
      B  = DATA(II+2) * UNIT(9)
      H = B*CHARGE/RI
      AL = H * L
      ELSE
      AL = DATA(II+2) * UNIT(7)
      H = AL/L
      B = RI * H / CHARGE
      END IF
      NB = DATA(II+3)
      IF (NPFR .EQ. 0) RETURN
      IF (NPFR .EQ. 1) BE = 0.5 * AL
      IF (NPFR .EQ. 2 .AND. ES .EQ. 1.0) BE = 0.0
      IF (NPFR .EQ. 2 .AND. ES .EQ. - 1.0) BE = AL
      IF (NPFR .EQ. 3 .AND. ES .EQ. 1.0) BE = AL
      IF (NPFR .EQ. 3 .AND. ES .EQ. - 1.0) BE = 0.0
      DATA(I+1) = BE/UNIT(7)
      RETURN
      END
      SUBROUTINE CHEKQ (CKK)
C
C     COMPILED BY U. ROHRER (SIN) JULY, 1986
C     FOR MAGNETIC FRINGE FIELD CARD
C
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC21/ EN, ES, BE, APB(2), LAYL, LAYX, RAB1,RAB2,RINVL
      REAL LAYL, LAYX
      COMMON /BLOC23/ H, AL, NB, BDB, CHARGE, LILENS, EQUAD, EBEND
      REAL NB
      LOGICAL LILENS, EQUAD, EBEND
      COMMON /BLOC24/ B, KQ2, KVK, K2H, K2V, CS, SN, CM1N, J
      REAL KQ2, KVK, K2H, K2V
      COMMON /BLOC25/ AP, CAP, JANET
      LOGICAL CAP
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC33/ FOTILT, SM
C
      CKK = 1.
C
C     SEE IF INTERVENING CARDS ARE I/O CONTROLS OR PARAMETER CONTROLS
C
      J = NUM
      DO 10 K = 1, 6
      J = J + 1
      IF(J .GT. NEL) GO TO 20
      II = ISTOR(J)
      IF(DATA(II) .EQ. 5.0) GO TO 50
      IF(DATA(II).NE.13.0 .AND. DATA(II).NE.16.0) GO TO 20
   10 CONTINUE
   20 J = NUM
      DO 30 K = 1, 6
      J = J - 1
      IF(J .LE. 0) GO TO 40
      II = ISTOR(J)
      IF(DATA(II) .EQ. 5.0) GO TO 60
      IF(DATA(II).NE.13.0 .AND. DATA(II).NE.16.0) GO TO 40
   30 CONTINUE
C
   40 IF (FORMIO) WRITE (NOUT, 140)
  140 FORMAT('0*** 5. TYPE CODE NOT FOUND FOR 2. TYPE CODE')
      CKK = 0.
      RETURN
C
C     SET FRINGING FIELD PARAMETERS
C
   50 ES  = 1.0
      EN  = 1.0
      GO TO 70
   60 ES  = - 1.0
      EN  = 0.0
c
   70 CONTINUE
      IF (EQUAD) THEN
        B = DATA (II+2) * 3.335641 * 0.0001  ! EFIELD-GRADIENT (KV/CM --> GV/M)
      ELSE
        B = DATA (II+2) * UNIT(9)
      ENDIF
      AP  = DATA(II+3) * UNIT(1)
      IF (EQUAD) THEN
        GAMMA = SQRT(1.0 + (RI / SM)**2)
        E = RI**2 / ((1. + GAMMA) * SM)
        RIE = E * (1. + GAMMA) / GAMMA
        KQ2 = B * CHARGE /(AP * RIE)
      ELSE
        KQ2 = B * CHARGE /(AP * RI)
      ENDIF
c
      RETURN
      END

      SUBROUTINE CLI(LOGIC)
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC29/ A(21), CW, CA(21,21), SCALE(21), CASAV(21,21),
     1                PMARQ, CHSMIN, XNORM, GNORM, EPS
      LOGICAL LOGIC
C
      LOGIC  =  .FALSE.
      IF(  CTY  .EQ.  0  )   RETURN
      IF ((CTY .EQ. 1) .AND. (A(1) .GT. 0.0)) RETURN
      IF ((CTY .EQ. 2) .AND. (A(1) .LT. 0.0)) RETURN
      A(1) = 0.0
      NC = NC - 1
      LOGIC  =  .TRUE.
      RETURN
      END
      SUBROUTINE COMBIN(ID)
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC47/ REG(10), DREG(10,20), LREG(10)
      LOGICAL LREG
C
      K1 = DATA(I+1)
      K2 = DATA(I+2)
      IOP = DATA(I+3)
      J = DATA(I+4)
      IF (J .GT. 10 .OR. K1 .GT. 10) RETURN
      IF (.NOT. LREG(K1)) RETURN
      IF (NV1 .GE. 20) GO TO 6
      NP1 = NV1 + 1
      DO 5 JJ = NP1, 20
    5 DREG(J,JJ) = 0.0
    6 GO TO (10,20,30,40,50), IOP
C
C     ADDITION
C
   10 IF (K2 .GT. 10) RETURN
      IF (.NOT. LREG(K2)) RETURN
      REG(J) = REG(K1) + REG(K2)
      LREG(J) = .TRUE.
      IF (ID .EQ. 0) RETURN
      DO 15 N = 1, NV1
   15 DREG(J,N) = DREG(K1,N) + DREG(K2,N)
      RETURN
C
C     SUBTRACTION
C
   20 IF (K2 .GT. 10) RETURN
      IF (.NOT. LREG(K2)) RETURN
      REG(J) = REG(K1) - REG(K2)
      LREG(J) = .TRUE.
      IF (ID .EQ. 0) RETURN
      DO 25 N = 1, NV1
   25 DREG(J,N) = DREG(K1,N) - DREG(K2,N)
      RETURN
C
C     MULTIPLICATION
C
   30 IF (K2 .GT. 10) RETURN
      IF (.NOT. LREG(K2)) RETURN
      PROD = REG(K1)*REG(K2)
      IF (ID .EQ. 0) GO TO 38
      DO 35 N = 1, NV1
   35 DREG(J,N) = REG(K1)*DREG(K2,N) + DREG(K1,N)*REG(K2)
   38 REG(J) = PROD
      LREG(J) = .TRUE.
      RETURN
C
C     DIVISION
C
   40 IF (K2 .GT. 10) RETURN
      IF (.NOT. LREG(K2)) RETURN
      QUOT = REG(K1)/REG(K2)
      IF (ID .EQ. 0) GO TO 48
      DO 45 N = 1, NV1
   45 DREG(J,N) = (REG(K2)*DREG(K1,N) - REG(K1)*DREG(K2,N))/REG(K2)**2
   48 REG(J) = QUOT
      LREG(J) = .TRUE.
      RETURN
C
C     SQUARE ROOT
C
   50 CONTINUE
      ROOT = SQRT(REG(K1))
      IF (ID .EQ. 0) GO TO 58
      DO 55 N = 1, NV1
   55 DREG(J,N) = 0.5*DREG(K1,N)/ROOT
   58 REG(J) = ROOT
      LREG(J) = .TRUE.
      RETURN
      END
      SUBROUTINE CONSEC
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC3/ TYPE, L ,LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     A                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC14/ RC3(6,6), TC3(6,6,6), R3P
      LOGICAL R3P
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC29/ A(21), CW, CA(21,21), SCALE(21), CASAV(21,21),
     1                PMARQ, CHSMIN, XNORM, GNORM, EPS
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC36/ VARS(4), SEXMAX, SEXLIM
      INTEGER VARS
      LOGICAL SEXLIM
      REAL TCS(11), TCSX(6,6,11)
C
      J = DATA(I+1)
      K = DATA(I+2)
      IF (TYPE .EQ. 10) THEN
      DEO = DATA(I+3)
      SD = DATA(I+4)
      NC = NC + 1
      ELSE
      DEO = 0.0
      SD = 1.0
      END IF
      NP1 = NV1 + 1
      IF (J .EQ. 18) GO TO 300
      IF (R3P) CALL UPDAT3
      IF (J .LT. 0) GO TO 70
      GO TO 200
C
C     SECOND ORDER MATRIX ELEMENT CONSTRAINT
C
   70 J = - J
      KM = K
      K = KM/10
      M = KM-10*K
      DO 80 L1 = 1, NP1
   80 A(L1) = 0.0
      CW = 1.0/SD**2
      FAC = UNIT(K)*UNIT(M)/UNIT(J)
      A(1) = - TC2(J,K,M) * FAC
      IF (K .NE. M) A(1) = 2.0 * A(1)
      A(1) = DEO + A(1)
      IF (NV1 .LT. 1) GO TO 120
      JKM = J + 6 * (K + 6 * M) - 42
      DO 110 N = 1, NV1
      IF (.NOT. R2VP(N)) GO TO 110
      IF (R2VP(N)) A(N+1) = T2V(JKM,N) * FAC
      IF (K .NE. M) A(N+1) = 2.0 * A(N+1)
  110 CONTINUE
  120 CALL GATHER
      RETURN
C
C     MINIMIZATION OF CONTRIBUTION OF ABERRATIONS TO BEAM
C
  200 CW = 1.0/(SD*UNIT(J))**2
      SS = 0.0
      DO 210 L1 = 1, 6
      DO 210 L2 = 1, 6
      SS = SS + TC2(J,L1,L2)*SI(L1,L2)
  210 CONTINUE
      TCS(1) = - SS
C
      IF (NV1 .LT. 1) GO TO 225
      DO 220 N = 1, NV1
      SS = 0.0
      IF (.NOT. R2VP(N)) GO TO 217
      DO 215 L1 = 1, 6
      DO 215 L2 = 1, 6
      JL12 = J + 6 * (L1 + 6 * L2) - 42
      SS = SS + T2V(JL12   ,N)*SI(L1,L2)
  215 CONTINUE
  217 TCS(N+1) = SS
  220 CONTINUE
C
  225 DO 230 L1 = 1, 6
      DO 230 L2 = 1, 6
      SS = 0.0
      DO 227 L3 = 1, 6
      SS = SS + TC2(J,L1,L3)*SI(L2,L3)
  227 CONTINUE
      TCSX(L1,L2,1) = - SS
  230 CONTINUE
C
      IF (NV1 .LT. 1) GO TO 241
      DO 240 N = 1, NV1
      DO 240 L1 = 1, 6
      DO 240 L2 = 1, 6
      SS = 0.0
      IF (.NOT. R2VP(N)) GO TO 236
      DO 235 L3 = 1, 6
      JL13 = J + 6 * (L1 + 6 * L3) - 42
      SS = SS + T2V(JL13   ,N)*SI(L2,L3)
  235 CONTINUE
  236 TCSX(L1,L2,N+1) = SS
  240 CONTINUE
C
  241 DO 250 L1 = 1, NP1
      DO 250 L2 = 1, L1
      SS = 0.0
      DO 245 L3 = 1, 6
      DO 245 L4 = 1, 6
      SS = SS + TCSX(L3,L4,L1)*TCSX(L4,L3,L2)
  245 CONTINUE
      CA(L1,L2) = CA(L1,L2) + (TCS(L1)*TCS(L2) + 2.0*SS)*CW
  250 CONTINUE
      RETURN
C
C     LIMITATIONS ON SEXTUPOLE STRENGTH
C
  300 SEXLIM = .TRUE.
      SEXMAX = SD*UNIT(9)
      RETURN
      END
      SUBROUTINE CONSTR
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC3/ TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC4/ LC, TOTANG, LCV(20)
      REAL LC, LCV
      COMMON /BLOC5/ VSTOR(20), TIE(NND)
      INTEGER VSTOR, TIE
      COMMON /BLOC5A/ LABEL(NNL), LABM(20)
      CHARACTER       LABEL*4, LABM*4
      COMMON /BLOC12/ RC(6,6), RCV(6,6,20), TC(6,6,6), RCP, RVP(20)
      LOGICAL RCP, RVP
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     A                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC14/ RC3(6,6), TC3(6,6,6), R3P
      LOGICAL R3P
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC18/ SIT(6,6), CEN(6), RECENT
      LOGICAL RECENT
      COMMON /BLOC24/ B, KQ2, KVK, K2H, K2V, CS, SN, CM1N, J
      REAL KQ2, KVK, K2H, K2V
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC29/ A(21), CW, CA(21,21), SCALE(21), CASAV(21,21),
     1                PMARQ, CHSMIN, XNORM, GNORM, EPS
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      COMMON /BLOC47/ REG(10), DREG(10,20), LREG(10)
      LOGICAL LREG
      LOGICAL LOGIC
C
      CTY = TIE(I+1)
      IF(CTY .EQ. 21) CTY = 1
      IF(CTY .EQ. 30) CTY = 2
      J  =  DATA(I + 1)
      K  =  DATA(I + 2)
      IF (TYPE .EQ. 10) THEN
       DEO = DATA(I + 3)
       SD  =  DATA(I + 4)
       IF(SD.EQ.0.) THEN
        IF (FORMIO) WRITE(NOUT,10)
   10   FORMAT(' Desired accuracy of fit has to be nonzero.')
        CALL MENU(1)
        RETURN
       END IF
       NC = NC + 1
      ELSE
       DEO = 0.0
       SD = 1.0
      END IF
      NP1 = NV1 + 1
      DO 80 L1 = 1, NP1
   80 A(L1) = 0.0
      IF (J .EQ. 0 .AND. K .EQ. 0) GO TO 100
      IF (J .EQ. 7 .AND. K .EQ. 7) GO TO 90
      IF (J .EQ. 9) GO TO 115
      IF (J .EQ. 18) GO TO 500
      IF (J .EQ. 100) GO TO 550
      GO TO 120
C
C     TOTAL BENDING ANGLE CONSTRAINT
C
   90 CW = 1.0/SD**2
      A(1) = DEO - TOTANG/UNIT(7)
      CALL CLI (LOGIC)
      IF (LOGIC) RETURN
      IF (NV1 .LT. 1) GO TO 96
      DO 95 N = 1, NV1, 1
      A(N+1) = LCV(N)/UNIT(7)
   95 CONTINUE
   96 CALL GATHER
      RETURN
C
C     SYSTEM LENGTH CONSTRAINT
C
  100 CW = 1.0/SD**2
      A(1) = DEO - LC/UNIT(8)
      CALL CLI (LOGIC)
      IF (LOGIC) RETURN
      IF (NV1 .LT. 1) GO TO 111
      DO 110 N = 1, NV1, 1
      A(N+1) = LCV(N)/UNIT(8)
  110 CONTINUE
  111 CALL GATHER
      RETURN
C
C     CONSTRAINT ON ALGEBRAIC COMBINATION OF MATRIX ELEMENTS
C
  115 IF (K .GT. 10) RETURN
      IF (.NOT. LREG(K)) RETURN
      CW = 1.0/SD**2
      A(1) = DEO - REG(K)
      IF (NV1 .LT. 1) GO TO 117
      DO 116 N = 1, NV1
  116 A(N+1) = DREG(K,N)
  117 CALL GATHER
      RETURN
C
C     TRANSFER MATRIX CONSTRAINTS
C
  120 IF (R3P) CALL UPDAT3
      IF (J .LT. - 20) GO TO 150
      IF (J .LT. - 10) GO TO 200
      IF (J .LT. 0) GO TO 250
      GO TO 300
C
C     R2 MATRIX CONSTRAINT
C
  150 IF (K .GT. 10) GO TO 180
      J  =  - (J+ 20)
      CW = 1.0/SD**2
      FAC = UNIT(K)/UNIT(J)
      A(1) = DEO - RC2(J,K) * FAC
      CALL CLI(LOGIC)
      IF (LOGIC) RETURN
      IF (NV1 .LT. 1) GO TO 161
      DO 160 N = 1, NV1
      IF (.NOT. R2VP(N)) GO TO 160
      A(N+1) = R2V(J,K,N) * FAC
  160 CONTINUE
  161 CALL GATHER
      RETURN
C
C     T2 MATRIX CONSTRAINT
C
  180 IF (SEC) CALL CONSEC
      RETURN
C
C     AGS MACHINE CONSTRAINT
C
  200 J  =  - (J + 10)
      IF (RCP) GO TO 201
      RCT = RC2(J,J) + RC2(K,K)
      GO TO 205
  201 IF (R2P) GO TO 202
      RCT = RC(J,J) + RC(K,K)
      GO TO 205
  202 RCT = 0.0
      DO 203 L1 = 1, 6
      RCT = RCT + RC2(J,L1)*RC(L1,J) + RC2(K,L1)*RC(L1,K)
  203 CONTINUE
  205 A(1) = 2.0 * COS(6.2831853 * DEO) - RCT
      CALL CLI(LOGIC)
      IF (LOGIC) RETURN
      CW = 1.0 / (12.5663706 * SIN(6.2831853 * DEO) * SD) ** 2
      IF (NV1 .LT. 1) GO TO 235
      DO 230 N = 1, NV1
      RCTV = 0.0
      IF (RVP(N) .OR. R2VP(N)) GO TO 211
      GO TO 230
  211 IF (RCP) GO TO 212
      RCTV = R2V(J,J,N) + R2V(K,K,N)
      GO TO 220
  212 IF (R2P) GO TO 213
      RCTV = RCV(J,J,N) + RCV(K,K,N)
      GO TO 220
  213 IF (R2VP(N)) GO TO 215
      DO 214 L1 = 1, 6
      RCTV = RCTV + RC2(J,L1)*RCV(L1,J,N) + RC2(K,L1)*RCV(L1,K,N)
  214 CONTINUE
      GO TO 220
  215 IF (RVP(N)) GO TO 217
      DO 216 L1 = 1, 6
      RCTV = RCTV + R2V(J,L1,N)*RC(L1,J) + R2V(K,L1,N)*RC(L1,K)
  216 CONTINUE
      GO TO 220
  217 DO 218 L1 = 1, 6
      RCTV = RCTV + R2V(J,L1,N)*RC(L1,J) + R2V(K,L1,N)*RC(L1,K)
     A + RC2(J,L1)*RCV(L1,J,N) + RC2(K,L1)*RCV(L1,K,N)
  218 CONTINUE
  220 A(N+1) = RCTV
  230 CONTINUE
  235 CALL GATHER
      RETURN
C
C     R MATRIX CONSTRAINT
C
  250 IF (K .GT. 10) GO TO 290
      J  =  - J
      CW = 1.0/SD**2
      FAC = UNIT(K)/UNIT(J)
      IF (RCP) GO TO 251
      RCT = RC2(J,K)
      GO TO 255
  251 IF (R2P) GO TO 252
      RCT = RC(J,K)
      GO TO 255
  252 RCT = 0.0
      DO 253 L1 = 1, 6
      RCT = RCT + RC2(J,L1)*RC(L1,K)
  253 CONTINUE
  255 A(1) = DEO - RCT * FAC
      CALL CLI(LOGIC)
      IF (LOGIC) RETURN
      IF (NV1 .LT. 1) GO TO 285
      DO 280 N = 1, NV1
      RCTV = 0.0
      IF (RVP(N) .OR. R2VP(N)) GO TO 261
      GO TO 270
  261 IF (RCP) GO TO 262
      RCTV = R2V(J,K,N)
      GO TO 270
  262 IF (R2P) GO TO 263
      RCTV = RCV(J,K,N)
      GO TO 270
  263 IF (R2VP(N)) GO TO 265
      DO 264 L1 = 1, 6
      RCTV = RCTV + RC2(J,L1)*RCV(L1,K,N)
  264 CONTINUE
      GO TO 270
  265 IF (RVP(N)) GO TO 267
      DO 266 L1 = 1, 6
      RCTV = RCTV + R2V(J,L1,N)*RC(L1,K)
  266 CONTINUE
      GO TO 270
  267 DO 268 L1 = 1, 6
      RCTV = RCTV + R2V(J,L1,N)*RC(L1,K) + RC2(J,L1)*RCV(L1,K,N)
  268 CONTINUE
  270 A(N+1) = RCTV * FAC
  280 CONTINUE
  285 CALL GATHER
      RETURN
C
C     T MATRIX CONSTRAINT
C
  290 IF (SEC) CALL CONSEC
      RETURN
C
C     BEAM CONSTRAINTS
C
  300 IF (.NOT. RECENT) CALL BEAM
      IF (J .EQ. K) GO TO 350
      IF (J .GT. 10) GO TO 400
      IF (J .EQ. 0 .OR. J .EQ. 7) GO TO 450
C
C     BEAM MATRIX CONSTRAINT
C
      CW = 1.0/SD**2
      FAC = 1.0/(UNIT(J)*UNIT(K))
      ANC = DEO - SIT(J,K) * FAC
      IF (S1P) ANC = ANC + CEN(J)*CEN(K) * FAC
      A(1) = ANC
      CALL CLI(LOGIC)
      IF (LOGIC) RETURN
      IF (NV1 .LT. 1) GO TO 345
      IF (FORMIO .AND. (J.GT.6 .OR. K.GT.6)) WRITE (NOUT,3000) J, K
      DO 340 N = 1, NV1
      IF (R2P) GO TO 310
      IF (.NOT. SVP(N)) GO TO 340
      SVJK = SV(J,K,N)
      IF (.NOT. S1P) GO TO 330
      COVJ = COV(J,N)
      COVK = COV(K,N)
      GO TO 330
  310 SVJK = 0.0
      COVJ = 0.0
      COVK = 0.0
      IF (.NOT. SVP(N)) GO TO 320
      DO 311 L1 = 1, 6
      DO 311 L2 = 1, 6
      SVJK = SVJK + RC2(J,L1)*SV(L1,L2,N)*RC2(K,L2)
  311 CONTINUE
      IF (.NOT. S1P) GO TO 320
      DO 313 L1 = 1, 6
      COVJ = COVJ + RC2(J,L1)*COV(L1,N)
      COVK = COVK + RC2(K,L1)*COV(L1,N)
  313 CONTINUE
  320 IF (.NOT. R2VP(N)) GO TO 330
      DO 321 L1 = 1, 6
      DO 321 L2 = 1, 6
      SVJK = SVJK + R2V(J,L1,N)*SI(L1,L2)*RC2(K,L2)
     A + RC2(J,L1)*SI(L1,L2)*R2V(K,L2,N)
  321 CONTINUE
      IF (.NOT. S1P) GO TO 330
      DO 323 L1 = 1, 6
      COVJ = COVJ + R2V(J,L1,N)*CO(L1)
      COVK = COVK + R2V(K,L1,N)*CO(L1)
  323 CONTINUE
  330 ANC = SVJK
      IF (S1P) ANC = ANC - (COVJ*CEN(K) + COVK*CEN(J))
      A(N+1) = ANC * FAC
  340 CONTINUE
  345 CALL GATHER
      RETURN
C
C     BEAM SIZE CONSTRAINT
C
  350 CALL EXTENT
      RETURN
C
C     BEAM CORRELATION CONSTRAINT
C
  400 J  =  J - 10
      SIJJ = SIT(J,J)
      SIKK = SIT(K,K)
      SIJK = SIT(J,K)
      IF (.NOT. S1P) GO TO 405
      COJ = CEN(J)
      COK = CEN(K)
      SIJJ = SIJJ - COJ**2
      SIKK = SIKK - COK**2
      SIJK = SIJK - COJ*COK
  405 W = SIJK/SQRT(SIJJ*SIKK)
      CW = (1/SD)**2
      A(1) = DEO - W
      CALL CLI(LOGIC)
      IF (LOGIC) RETURN
      IF (NV1 .LT. 1) GO TO 445
      IF (FORMIO .AND. (J.GT.6 .OR. K.GT.6))  WRITE(NOUT,3000)J,K
 3000 FORMAT ('3  NO BEAM MATRIX ELEMENT',2I6)
      DO 440 N = 1, NV1
      IF (R2P) GO TO 410
      IF (.NOT. SVP(N)) GO TO 440
      SVJJ = SV(J,J,N)
      SVKK = SV(K,K,N)
      SVJK = SV(J,K,N)
      IF (.NOT. S1P) GO TO 430
      COVJ = COV(J,N)
      COVK = COV(K,N)
      GO TO 430
  410 SVJJ = 0.0
      SVKK = 0.0
      SVJK = 0.0
      COVJ = 0.0
      COVK = 0.0
      IF (.NOT. SVP(N)) GO TO 420
      DO 411 L1 = 1, 6
      DO 411 L2 = 1, 6
      SVJJ = SVJJ + RC2(J,L1)*SV(L1,L2,N)*RC2(J,L2)
      SVKK = SVKK + RC2(K,L1)*SV(L1,L2,N)*RC2(K,L2)
      SVJK = SVJK + RC2(J,L1)*SV(L1,L2,N)*RC2(K,L2)
  411 CONTINUE
      IF (.NOT. S1P) GO TO 420
      DO 413 L1 = 1, 6
      COVJ = COVJ + RC2(J,L1)*COV(L1,N)
      COVK = COVK + RC2(K,L1)*COV(L1,N)
  413 CONTINUE
  420 IF (.NOT. R2VP(N)) GO TO 430
      DO 421 L1 = 1, 6
      DO 421 L2 = 1, 6
      SVJJ = SVJJ + 2.0*R2V(J,L1,N)*SI(L1,L2)*RC2(J,L2)
      SVKK = SVKK + 2.0*R2V(K,L1,N)*SI(L1,L2)*RC2(K,L2)
      SVJK = SVJK + R2V(J,L1,N)*SI(L1,L2)*RC2(K,L2)
     A + RC2(J,L1)*SI(L1,L2)*R2V(K,L2,N)
  421 CONTINUE
      IF (.NOT. S1P) GO TO 430
      DO 423 L1 = 1, 6
      COVJ = COVJ + R2V(J,L1,N)*CO(L1)
      COVK = COVK + R2V(K,L1,N)*CO(L1)
  423 CONTINUE
  430 IF (.NOT. S1P) GO TO 435
      SVJJ = SVJJ - 2.0*COJ*COVJ
      SVKK = SVKK - 2.0*COK*COVK
      SVJK = SVJK - (COJ*COVK + COVJ*COK)
  435 ANC = SVJK/SIJK - 0.5*(SVJJ/SIJJ + SVKK/SIKK)
      A(N+1) = ANC * W
  440 CONTINUE
  445 CALL GATHER
      RETURN
C
C     FIRST MOMENT CONSTRAINT
C
  450 CW = 1.0/SD**2
      IF (.NOT. S1P) RETURN
      A(1) = DEO - CEN(K)/UNIT(K)
      CALL CLI(LOGIC)
      IF(LOGIC) RETURN
      IF (NV1 .LT. 1) GO TO 495
      DO 490 N=1,NV1
      IF(R2P) GOTO 455
      IF (.NOT. SVP(N)) GO TO 490
      COTV = COV(K,N)
      GO TO 485
  455 COTV = 0.0
      IF (.NOT. SVP(N)) GO TO 470
      DO 460 L1 = 1, 6
      COTV = COTV + RC2(K,L1)*COV(L1,N)
  460 CONTINUE
  470 IF (.NOT. R2VP(N)) GO TO 485
      DO 480 L1 = 1, 6
      COTV = COTV + R2V(K,L1,N)*CO(L1)
  480 CONTINUE
  485 A(N+1) = COTV/UNIT(K)
  490 CONTINUE
  495 CALL GATHER
      RETURN
C
C     SEXTUPOLE STRENGTH LIMITS
C
  500 CALL CONSEC
      RETURN
C
C     NUMERICAL CONSTANT
C
  550 A(1) = - DATA(I+2)
      DO 560 N = 1, 20
  560 A(N+1) = 0.0
      CALL GATHER
      RETURN
      END
      SUBROUTINE CSABT(C,A,B,ISBK)
      DIMENSION C(6,6), A(6,6,10), B(6,6)
C
      DO 2 I = 1, 6
      DO 2 J = 1, 6
      S = 0.0
      DO 1 K = 1, 6
      S = S + A(I,K,ISBK) * B(J,K)
    1 CONTINUE
      C(I,J)  =  S
    2 CONTINUE
      RETURN
      END
      REAL FUNCTION  DELTA(I,J)
C
      IF(  I  .EQ.  J)  GO TO 1
      DELTA = 0.0
      RETURN
    1 DELTA =  1.
      RETURN
      END
      REAL FUNCTION  DEN(X)
C
      IF( X  .NE.  0.  ) GO TO 1
      DEN  =  (1.E-16)
      RETURN
    1 DEN  =  X
      RETURN
      END
      SUBROUTINE DERIVE
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC3/ TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC4/ LC, TOTANG, LCV(20)
      REAL LC, LCV
      COMMON /BLOC5/ VSTOR(20), TIE(NND)
      INTEGER VSTOR, TIE
      COMMON /BLOC5A/ LABEL(NNL), LABM(20)
      CHARACTER       LABEL*4, LABM*4
      COMMON /BLOC6/ PERIDX, PERIDY, PERIDC, RCPER, EMITX, EMITY
      LOGICAL PERIDX, PERIDY, PERIDC, RCPER
      COMMON /BLOC11/ R(6,6), RV(6,6), T(6,6,6), TV(6,6,6)
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     A                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC14/ RC3(6,6), TC3(6,6,6), R3P
      LOGICAL R3P
      COMMON /BLOC15/ RS(6,6), RT(6,6), TS(6,6,6), TT(6,6,6)
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC19/ TR(6,6,6)
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC27/ CT(6,6), CT0(6,6), CT1(3,3), VM(6), DMC, NM
      LOGICAL DMC
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC29/ A(21), CW, CA(21,21), SCALE(21), CASAV(21,21),
     1                PMARQ, CHSMIN, XNORM, GNORM, EPS
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      COMMON /BLOC63/ Z216(216), U36(36)
      DIMENSION    R2VL(36,20), TRL(36,6), TL(36,6)
      EQUIVALENCE  (R2V,R2VL),  (TRL,TR),  (TL,T)
      INTEGER VARSEC
      INTEGER VARGAP
      LOGICAL VARLET
C
      CALL INITZE
    1 CONTINUE
      I = ISTOR(NUM)
      TYPE = DATA(I)
      IF(TYPE .EQ. 9) CALL REPEAT
      IF(TYPE .LE. 0) GO TO 810
      CALL ELMENT(NWK)
      PERIDX = .FALSE.
      PERIDY = .FALSE.
      IF (TYPE .EQ. 50) GO TO 810
      GO TO (150,200,200,200,200,810,150,150,810,700,200,100,810,200,
     A 810,810,810,200,200,200,200,810,200,700,750), TYPE
C
C     ELEMENTS AFFECTING THE BEAM MATRIX BUT HAVING NO TRANSFER MATRIX
C
  100 DO 120 N = 1, NV1
      IF (.NOT. SVP(N)) GO TO 120
      DO 110 J = 2, 6
      JMIN1 = J - 1
      DO 110 K = 1, JMIN1
      DSV = 0.0
      IF (SI(J,J) .NE. 0.0 .AND. SI(K,K) .NE. 0.0)
     1 DSV = 0.5*SI(J,K)*(SV(J,J,N)/SI(J,J) + SV(K,K,N)/SI(K,K))
      SV(J,K,N) = DSV
      SV(K,J,N) = DSV
  110 CONTINUE
  120 CONTINUE
C
  150 NVTYPE = NV(TYPE)
      DO 170 JV = 1, NVTYPE
      IPLJV = I + JV
      NV2 = TIE(IPLJV)
      IF (NV2 .EQ. 0) GO TO 170
      NV1 = MAX(NV1,IABS(NV2))
      CALL PARTLS
  170 CONTINUE
      GO TO 810
C
C     ELEMENTS HAVING A TRANSFER MATRIX
C
  200 NVTYPE = NV(TYPE)
      NVSHOW = NIV(TYPE)
      IF (NVTYPE .LT. 1) GO TO 250
      DO 210 JV = 1, NVTYPE
      IF (JV .GT. NVSHOW) GO TO 205
      IPLJV = I + JV
      NV2 = TIE(IPLJV)
      IF (NV2 .NE. 0) GO TO 300
      GO TO 210
  205 IF (VARSEC(TYPE) .NE. 0) GO TO 300
  210 CONTINUE
C     VARYING THE MAGNET GAP (FIRST ORDER RUN ONLY)
      IF (VARGAP(TYPE) .NE. 0) GO TO 300
      IF (NV1 .LT. 1) GO TO 250
      DO 220 N = 1, NV1
      IF (SVP(N)) GO TO 300
  220 CONTINUE
C
C     UNVARIED ELEMENT
C
  250 IF (NWK .NE. 1) GO TO 810
      VARLET = .FALSE.
      IF (R3P) GO TO 270
      IF (.NOT. ALIGN) R3P = .TRUE.
      CALL UCOPY(R,RC3,36)
      IF (SEC) CALL UCOPY(T,TC3,216)
      GO TO 800
C
  270 IF (.NOT. SEC) CALL CABF(RS,R,RC3)
      IF (SEC) CALL MTMPLF(RS,TS,R,T,RC3,TC3)
      CALL UCOPY(RS,RC3,36)
      IF (SEC) CALL UCOPY(TS,TC3,216)
      GO TO 800
C
C     VARIED ELEMENT
C
  300 VARLET = .TRUE.
      IF (R3P) CALL UPDAT3
      IF (.NOT. SEC .OR. .NOT. R2P) GO TO 308
      DO 305 M = 1, 6
  305 CALL CAB(TRL(1,M),TL(1,M),RC2)
  308 IF (NV1 .LT. 1) GO TO 400
C
C     R TIMES DERIVATIVE OF ACCUMULATED R2
C
      IF (NWK .NE. 1) GO TO 400
      DO 350 N = 1, NV1
      IF (.NOT. R2VP(N)) GO TO 350
      IF (.NOT. SEC) CALL CABF(RS,R,R2VL(1,N))
      IF (SEC) CALL MXMPLY(RS,TS,R,T,R2VL(1,N),T2V(1,N))
      CALL UCOPY(RS,R2VL(1,N),36)
      IF (SEC) CALL UCOPY(TS,T2V(1,N),216)
  350 CONTINUE
C
C     DERIVATIVE OF R TIMES ACCUMULATED R2
C
  400 NVTYPE = NV(TYPE)
      NVSHOW = NIV(TYPE)
      NVV = VARGAP(TYPE)
      IF (NVV .NE. 0) NVTYPE = 2
      DO 520 JV = 1, NVTYPE
      IF (JV .GT. NVSHOW) GO TO 401
      IF (JV .EQ. 2 .AND. NVV .NE. 0) GO TO 403
      IPLJV  =  I + JV
      NV2 = TIE(IPLJV)
      GO TO 402
  403 NV2 = NVV
      GO TO 402
  401 NV2 = VARSEC(TYPE)
  402 IF (NV2 .EQ. 0) GO TO 520
      LV = 0.0
      CALL UCOPY(Z216,RV,36)
      IF (SEC) CALL UCOPY(Z216,TV,216)
C
  415 NV1 = MAX(NV1,IABS(NV2))
      CALL PARTLS
      IF (TYPE .EQ. 8) GO TO 520
      IF (NV2 .GT. 0) GO TO 430
      NV2 = IABS(NV2)
      LV = - LV
      CALL MNEG(RV,36)
      IF (SEC) CALL MNEG(TV,216)
C
  430 IF (R2P) GO TO 460
      CALL UCOPY(RV,R2VL(1,NV2),36)
      IF (SEC) CALL UCOPY(TV,T2V(1,NV2),216)
      GO TO 500
C
  460 IF (.NOT. SEC) CALL CAB(RS,RV,RC2)
      IF (SEC) CALL MTMPLY(RS,TS,RV,TV,RC2,TC2)
      IF (R2VP(NV2)) GO TO 480
C
      CALL UCOPY(RS,R2VL(1,NV2),36)
      IF (SEC) CALL UCOPY(TS,T2V(1,NV2),216)
      GO TO 500
C
  480 CALL MADD(R2VL(1,NV2),RS,36)
      IF (SEC) CALL MADD(T2V(1,NV2),TS,216)
  500 R2VP(NV2) = .TRUE.
      LCV(NV2) = LCV(NV2) + LV
  520 CONTINUE
C
C     ACCUMULATED R2 MATRIX
C
  600 IF (NWK .NE. 1) GO TO 810
      IF (R2P) GO TO 630
      IF (.NOT. ALIGN) R2P = .TRUE.
      CALL UCOPY(R,RC2,36)
      IF (SEC) CALL UCOPY(T,TC2,216)
      GO TO 800
C
  630 IF (.NOT. SEC) CALL CABF(RS,R,RC2)
      IF (SEC) CALL MSMPLY(RS,TS,R,T,RC2,TC2)
      CALL UCOPY(RS,RC2,36)
      IF (SEC) CALL UCOPY(TS,TC2,216)
      GO TO 800
C
C     CONSTRAINT
C
  700 CALL CONSTR
      GO TO 810
C
C     ALGEBRAIC COMBINATIONS
C
  750 CALL COMBIN(1)
      GO TO 810
C
C     ADVANCE TO NEXT ELEMENT
C
  800 IF (.NOT. ALIGN) GO TO 805
      CALL ADVANC(2)
      CALL ADVANC(3)
  805 IF (.NOT. VARLET) R3P = .TRUE.
      IF (VARLET) R2P = .TRUE.
      IF (DMC) CALL MALIGN
  810 NUM = NUM + 1
      IF(NUM .LE. NEL) GO TO 1
      RETURN
      END
      SUBROUTINE DFOCUS
      COMMON /BLOC3/  TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC11/ R(6,6), RV(6,6), T(6,6,6), TV(6,6,6)
      COMMON /BLOC24/ B, KQ2, KVK, K2H, K2V, CS, SN, CM1N, J
      REAL KQ2, KVK, K2H, K2V
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
C
      RV(J,J) = L * R(J+1,J)*KVK
      RV(J+1,J+1) = RV(J,J)
      RV(J,J+1) = (-R(J,J+1)+ L * R(J,J)) * KVK
      RV(J+1,J) = (R(J+1,J) - KQ2 * L * R(J,J)) * KVK
      IF (.NOT.SEC  .OR. TYPE .NE. 5) RETURN
C
C     SECOND ORDER DERIVATIVE TERMS FOR QUADS
C
      AUX = 0.25*(KQ2*L**2*R(J,J) - L*R(J+1,J))*KVK
      TV(J,J,6) = AUX
      TV(J,6,J) = AUX
      TV(J+1,J+1,6) = AUX
      TV(J+1,6,J+1) = AUX
      AUX = 0.25*( - R(J,J+1) + L*R(J,J) + KQ2*L**2*R(J,J+1))*KVK
      TV(J,J+1,6) = AUX
      TV(J,6,J+1) = AUX
      AUX = 0.25*(-R(J+1,J)+3.0*KQ2*L*R(J,J)-KQ2*L**2*R(J+1,J))*KVK
      TV(J+1,J,6) = AUX
      TV(J+1,6,J) = AUX
      RETURN
      END
      SUBROUTINE DFOL
      COMMON /BLOC3/  TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC11/ R(6,6), RV(6,6), T(6,6,6), TV(6,6,6)
      COMMON /BLOC24/ B, KQ2, KVK, K2H, K2V, CS, SN, CM1N, J
      REAL KQ2, KVK, K2H, K2V
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      COMMON /BLOC38/ MOR,TOR,ANIN,NPFR
      LOGICAL MOR,TOR,ANIN
C
      IF (TYPE .EQ. 4 .AND. ANIN) GO TO 200
      RV(J,J+1) = R(J,J) * UNIT(8)
      RV(J+1,J) = -KQ2 * RV(J,J+1)
      RV(J+1,J+1) = R(J+1,J) * UNIT(8)
      RV(J,J) = RV(J+1,J+1)
      IF (.NOT.SEC .OR. TYPE .NE. 5) RETURN
C
C     SECOND ORDER DERIVATIVE TERMS FOR QUADS
C
      AUX = 0.25*( - R(J+1,J) + KQ2*L*R(J,J))*UNIT(8)
      TV(J,J,6) = AUX
      TV(J,6,J) = AUX
      TV(J+1,J+1,6) = AUX
      TV(J+1,6,J+1) = AUX
      AUX = - 0.25*L*R(J+1,J)*UNIT(8)
      TV(J,J+1,6) = AUX
      TV(J,6,J+1) = AUX
      AUX = 0.25*(2.0*KQ2*R(J,J) + KQ2*L*R(J+1,J))*UNIT(8)
      TV(J+1,J,6) = AUX
      TV(J+1,6,J) = AUX
      RETURN
C
  200 RV(J,J+1) = R(J,J+1)*UNIT(8)/L
      RV(J+1,J) = - R(J+1,J)*UNIT(8)/L
      RETURN
      END
      SUBROUTINE ELECT(X,EE)
C
C     NEW SUBROUTINE FOR SPACE CHARGE
C     FINDS ELECTRIC FIELD OF CHARGE ELLIPSOID WITH AXES SQRT(X(I)),
C     I = 1,3 .
C
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      DOUBLE PRECISION T(20),W(20),X(3),XF(3),R(3),EE(3)
      DOUBLE PRECISION FACT,U,FA,FAC
C     DATA FOR 20 POINT GAUSSIAN QUADRATURE
      DATA T( 1) / 3.45190D-03/, W( 1) / 8.86790D-03/
      DATA T( 2) / 1.83455D-02/, W( 2) / 2.10522D-02/
      DATA T( 3) / 4.58993D-02/, W( 3) / 3.42786D-02/
      DATA T( 4) / 8.74766D-02/, W( 4) / 4.92413D-02/
      DATA T( 5) / 1.45259D-01/, W( 5) / 6.68466D-02/
      DATA T( 6) / 2.22457D-01/, W( 6) / 8.83153D-02/
      DATA T( 7) / 3.23741D-01/, W( 7) / 1.15380D-01/
      DATA T( 8) / 4.55916D-01/, W( 8) / 1.50600D-01/
      DATA T( 9) / 6.28948D-01/, W( 9) / 1.97910D-01/
      DATA T(10) / 8.57828D-01/, W(10) / 2.63616D-01/
      DATA T(11) / 1.16574D+00/, W(11) / 3.58237D-01/
      DATA T(12) / 1.58995D+00/, W(12) / 5.00315D-01/
      DATA T(13) / 2.19339D+00/, W(13) / 7.24528D-01/
      DATA T(14) / 3.08887D+00/, W(14) / 1.10084D+00/
      DATA T(15) / 4.49532D+00/, W(15) / 1.78464D+00/
      DATA T(16) / 6.88426D+00/, W(16) / 3.16806D+00/
      DATA T(17) / 1.14314D+01/, W(17) / 6.43480D+00/
      DATA T(18) / 2.17880D+01/, W(18) / 1.62725D+01/
      DATA T(19) / 5.45124D+01/, W(19) / 6.25585D+01/
      DATA T(20) / 2.89697D+02/, W(20) / 7.44237D+02/
C     SCALE X(I) SO THAT SMALLEST X EQUALS 0.5
      IF(X(3) .NE. 0.0) GO TO 100
      IF (FORMIO) WRITE(NOUT,1000)
 1000 FORMAT(
     X' YOUR BEAM IS BUNCHED, PLEASE ENTER A NON_ZERO LONGITUDINAL'/
     X' BEAM EXTENT OR MOMENTUM SPREAD ON THE BEAM CARD.')
      CALL MENU(1)
      RETURN
  100 IF(X(1) .LE. X(2)) GO TO 1
      IF(X(2) .LE. X(3)) GO TO 2
      FACT = X(3)*2.0
      GO TO 3
    1 CONTINUE
      IF(X(1) .LE. X(3)) GO TO 4
      FACT = X(3)*2.0
      GO TO 3
    4 CONTINUE
      FACT = X(1)*2.0
      GO TO 3
    2 CONTINUE
      FACT = X(2)*2.0
    3 CONTINUE
      FAC = 1.0/FACT
      DO 5 I=1,3
      XF(I) = X(I)*FAC
      EE(I) = 0.0
    5 CONTINUE
C     FIND ELECTRIC FIELD BY 20 POINT GAUSSIAN QUADRATURE
      DO 6 I=1,20
      DO 7 J=1,3
      R(J) = 1.0/(XF(J)+T(I))
    7 CONTINUE
      U = 0.5*W(I)*SQRT(R(1)*R(2)*R(3))
      DO 8 J=1,3
      EE(J) = EE(J) + U*R(J)
    8 CONTINUE
    6 CONTINUE
      FA = FAC*SQRT(FAC)
      DO 9 J=1,3
      EE(J) = FA*EE(J)
    9 CONTINUE
      RETURN
      END
      SUBROUTINE ELICIT
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC3/ TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC11/ R(6,6), RV(6,6), T(6,6,6), TV(6,6,6)
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     A                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC15/ RS(6,6), RT(6,6), TS(6,6,6), TT(6,6,6)
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC27/ CT(6,6), CT0(6,6), CT1(3,3), VM(6), DMC, NM
      LOGICAL DMC
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
C
C     DETERMINE EFFECT OF ELEMENT
C
      CALL ELMENT(NWK)
      IF (TYPE .EQ. 16 .AND.
     1 (IFIX(DATA(I+1)) .EQ. 19 .OR. IFIX(DATA(I+1)) .EQ. 20))
     2 GO TO 310
      IF (NWK .NE. 1) RETURN
C
C     MULTIPLY TRANSFER MATRICES
C
      IF (R2P) GO TO 200
      CALL UCOPY(R,RC2,36)
      IF (SEC) CALL UCOPY(T,TC2,216)
      GO TO 300
C
  200 IF (.NOT. SEC) CALL CABF(RS,R,RC2)
      IF (SEC) CALL MTMPLF(RS,TS,R,T,RC2,TC2)
      CALL UCOPY(RS,RC2,36)
      IF (SEC) CALL UCOPY(TS,TC2,216)
C
  300 CONTINUE
      IF (.NOT. ALIGN) GO TO 305
      CALL ADVANC(2)
      CALL ADVANC(3)
  305 R2P = .TRUE.
  310 IF (LAY) CALL ADVANC(4)
      IF (DMC) CALL MALIGN
      RETURN
      END
      SUBROUTINE ELMENT(NWK)
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC3/ TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC4/ LC, TOTANG, LCV(20)
      REAL LC, LCV
      COMMON /BLOC5/ VSTOR(20), TIE(NND)
      INTEGER VSTOR, TIE
      COMMON /BLOC5A/ LABEL(NNL), LABM(20)
      CHARACTER       LABEL*4, LABM*4
      COMMON /BLOC6/ PERIDX, PERIDY, PERIDC, RCPER, EMITX, EMITY
      LOGICAL PERIDX, PERIDY, PERIDC, RCPER
      COMMON /BLOC11/ R(6,6), RV(6,6), T(6,6,6), TV(6,6,6)
      COMMON /BLOC12/ RC(6,6), RCV(6,6,20), TC(6,6,6), RCP, RVP(20)
      LOGICAL RCP, RVP
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     A                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC14/ RC3(6,6), TC3(6,6,6), R3P
      LOGICAL R3P
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC17/ COD(6)
      COMMON /BLOC18/ SIT(6,6), CEN(6), RECENT
      LOGICAL RECENT
      COMMON /BLOC21/ EN, ES, BE, APB(2), LAYL, LAYX, RAB1,RAB2,RINVL
      REAL LAYL, LAYX
      COMMON /BLOC22/ BE1, SB, TB, TB1
      COMMON /BLOC23/ H, AL, NB, BDB, CHARGE, LILENS, EQUAD, EBEND
      REAL NB
      LOGICAL LILENS, EQUAD, EBEND
      COMMON /BLOC24/ B, KQ2, KVK, K2H, K2V, CS, SN, CM1N, J
      REAL KQ2, KVK, K2H, K2V
      COMMON /BLOC25/ AP, CAP, JANET
      LOGICAL CAP
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC27/ CT(6,6), CT0(6,6), CT1(3,3), VM(6), DMC, NM
      LOGICAL DMC
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
      COMMON /BLOC31/ J1, TYP1
      INTEGER TYP1
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC33/ FOTILT, SM
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      COMMON /BLOC35/ KL, KO, SOLSEG
      REAL KL, KO
      LOGICAL SOLSEG
      COMMON /BLOC38/ MOR,TOR,ANIN,NPFR
      LOGICAL MOR,TOR,ANIN
      COMMON /BLOC48/ MPS, DRIFT
      LOGICAL DRIFT
      COMMON /BLOC50/ XI1, XI2, XI3
      COMMON /BLOC59/ SLITS
      LOGICAL SLITS
      COMMON /BLOC63/ Z216(216), U36(36)
      COMMON /BLOC70/ RANOPT, NITER, ALOW(20), AHIGH(20)
      LOGICAL RANOPT
      COMMON /BLOC78/ ICONF
      COMMON/SC/STEP,AMP,BFREQ,GAMMA,CAPPA,IPTFQ,SC1P,SC3P
      LOGICAL SC1P,SC3P
      COMMON /FIRST/ FIRST1, FIRST2, FIRST3, FIRST4, SNTNL
      LOGICAL FIRST1, FIRST2, FIRST3, FIRST4, SNTNL
C
      REAL*8 GAMMA0,GAMMA1,GAMMA2,BETO0,BETA1,BGS
      DIMENSION MASK(6,6), SWTCH1(25), SWTCH2(25)
      DATA MASK/
     A 2*0,2*1,0,1,
     B 2*0,2*1,0,1,
     C 2*1,2*0,2*1,
     D 2*1,2*0,2*1,
     E 4*1,0,1,
     F 2*0,2*1,2*0/
      DATA SWTCH1 /2*0,3*1,5*0,1,6*0,2*1,0,1,4*0/
      DATA SWTCH2 /0,4*1,5*0,1,6*0,4*1,0,1,2*0/
C
      DRIFT = .FALSE.
      IF (.NOT. SC1P) GO TO 10
      IF (SWTCH1(TYPE) .NE. 1) GO TO 10
      CALL SPACEC
      NWK=1
      RETURN
C
   10 IF (SWTCH2(TYPE) .EQ. 1) GO TO 50
      IF (TYPE .EQ. 14 .AND. .NOT. (TYP1 .EQ. 14)) GO TO 50
      GO TO 80
   50 L = 0.0
      CALL UCOPY(U36,R,36)
      IF (.NOT.(ALIGN .OR. LAY)) GO TO 80
      CALL RESET(1)
      IF (TYPE .EQ. 16) GO TO 80
      CALL PICKUP(1)
      IF (.NOT. RCP .AND. .NOT. R2P .AND. .NOT. R3P) CALL PICKUP(2)
      IF (.NOT. R2P .AND. .NOT. R3P) CALL PICKUP(3)
   80 NWK = 0
      IF (TYPE .EQ. 50) GO TO 5000
      GO TO (100,200,300,400,500,600,700,800,5003,5003,1100,1200,1300,
     A 1400,1500,1600,1700,1800,1900,2000,2100,2200,2300,5003,5003)
     A , TYPE
C
C     1. -- BEAM
C
  100 IF (R3P) CALL UPDAT3
      IF (R2P) CALL UPDAT2
      IF(ISTOR(NUM+1) .GT. I + 8) GO TO 130
      RI = DATA(I+7)*UNIT(11)
      IF (RI.EQ.0.) THEN
       IF (FORMIO) WRITE(NOUT,105)
  105  FORMAT(' Initial particle momentum has to be nonzero.')
       CALL MENU(1)
       RETURN
      END IF
      CALL UCOPY(Z216,SI,36)
      DO 110 J = 1, 6
      IPLUSJ  =  I+J
      SI(J,J) = (DATA(IPLUSJ)*UNIT(J))**2
  110 CONTINUE
      CALL UCOPY(Z216,CO,6)
      CALL INIT2
      CALL INIT1
      GO TO 5003
C
  130 RI = RI + DATA(I+7)*UNIT(11)
      DO 140 J = 1, 6
      IPLUSJ = I + J
      SI(J,J) = SI(J,J) + (DATA(IPLUSJ)*UNIT(J))**2
  140 CONTINUE
      RECENT = .FALSE.
      GO TO 5003
C
C     2. -- POLE FACE ROTATION
C
  200 CONTINUE
      IF (DATA(I+1) .GE. 1000.) GO TO 240
      IF (EBEND) GO TO 5003
      BE = DATA(I+1) * UNIT(7)
      TB = TAN(BE)
      CB = COS(BE)
      SB = (1.0 + SIN(BE)**2)/CB
C
C* CHEK TO SEE IF INTERVENING CARDS ARE I/O CONTROLS
C
      CALL CHEK    (CKK)
      IF (CKK.EQ. 0.  ) RETURN
      IF (RORC .NE. 3 .AND. RORC .NE. 4) GO TO 230
      IF(NM .GE. 20) GO TO 230
      IF(ES .NE. 1.0) GO TO 225
      IF (R3P) CALL UPDAT3
      IF (R2P) CALL UPDAT2
      CALL PICKUP(3)
  225 IR = 3
      DMC = ES .EQ. - 1.0
  230 H = B*CHARGE/RI
      TCOR = 2.0*H*APB(2)*LAYL
      BE1 = BE -TCOR* SB* (  1. -LAYX*TCOR * TB )
      TB1  =  TAN(BE1)
      R(2,1) = H*TB
      R(4,3) = - H*TB1
      SB = 1.0/CB
      GO TO 5001
C
C     QUAD FRINGE FIELD
C
  240 CONTINUE
      CALL CHEKQ(CKK)
      IF (CKK. EQ. 0.) RETURN
      C      = KQ2 * XI1 * AP * AP * ES
      AP3    = AP * AP * AP
      R(1,1) = 1. - C
      R(1,2) = -2. * KQ2 * XI2 * AP3
      R(2,1) = -1. * KQ2 * KQ2 * XI3 * AP3
      R(2,2) = 1. + C
      R(3,3) = R(2,2)
      R(3,4) = -R(1,2)
      R(4,3) = R(2,1)
      R(4,4) = R(1,1)
      GO TO 5001
C
C     3. -- DRIFT SPACE
C
  300 L = DATA(I+1)*UNIT(8)
      DRIFT = .TRUE.
      R(1,2)  = L
      R(3,4) = L
      IF (.NOT. (ALIGN .OR. LAY)) GO TO 5001
      X0(1,3)  = L
      GO TO 5001
C
C     4. -- BENDING MAGNET
C
  400 CONTINUE
      IF (EBEND) GO TO 420
      IF (RORC .NE. 3 .AND. RORC .NE. 4) GO TO 402
      IF (NM .GE. 20) GO TO 402
      CALL HUNT2
      IF (IR .NE. 1 .OR. DMC) GO TO 401
      IF (R3P) CALL UPDAT3
      IF (R2P) CALL UPDAT2
      CALL PICKUP(3)
  401 LABM(NM+1) = LABEL(NUM)
  402 L  =  DATA(I+1) * UNIT(8)
      IF(.NOT.ANIN) THEN
       B = DATA(I+2) * UNIT(9)
       H = B * CHARGE / RI
       AL = H*L
      ELSE
       AL = DATA(I+2) * UNIT(7)
       H = AL/L
       B = RI * H / CHARGE
      END IF
      NB = DATA(I+3)
      IF (NB .EQ. 1.0) NB = 1.000001
      TOTANG = TOTANG + AL
      J = 1
      KQ2 = H**2*(1.0 - NB)
      K2H = KQ2
      CALL FOCUS
      SNH = SN
      IF (ABS(K2H*L**2) .GT. 0.0005) GO TO 403
      CM1N = - 0.5*(1.0 - NB)*L**2
      GO TO 404
  403 CM1N = (CS - 1.0)/H**2
  404 CONTINUE
      R(1,6) = - H*CM1N/(1.0 - NB)
      R(5,2) = - R(1,6)
      R(2,6) = H*R(1,2)
      R(5,1) = - R(2,6)
      R(5,6) = - (L - R(1,2))/(1.0 - NB)
      J = 3
      KQ2 = H**2*NB
      K2V = KQ2
      CALL FOCUS
      SN = SNH
      IF (.NOT. (ALIGN .OR. LAY)) GO TO 5001
      GO TO 421
C
C     ELECTROSTATIC PRISM
C
  420 CONTINUE
      IF (SM .EQ. 0.0) GO TO 1180
      L  = DATA(I+1) * UNIT(8)
      AL = DATA(I+2) * UNIT(7)
      H  = AL / L
      NB = DATA(I+3)
      CALL FOCUSE(L,AL,NB)
      TOTANG = TOTANG + AL
      IF (.NOT. (ALIGN .OR. LAY)) GO TO 5001
C
C     ALIGN AND LAY FOR BEND AND EPRISM (TYPE CODE 4)
C
  421 O(1,1,1) = COS(AL)
      O(1,3,3) = O(1,1,1)
      O(1,1,3) = SIN(AL)
      O(1,3,1) = - O(1,1,3)
      IF (ABS(H*L) .LT. 0.01) GO TO 422
      X0(1,1) = - (1.0 - O(1,1,1))/H
      X0(1,3) = O(1,1,3)/H
      GO TO 5001
  422 X0(1,1) = - 0.5*H*L**2
      X0(1,3) = L - H**2*L**3/6.0
      GO TO 5001
C
C     5. -- QUADRUPOLE
C
  500 IF(RORC .NE. 3 .AND. RORC .NE. 5) GO TO 501
      IF (NM .GE. 20) GO TO 501
      LABM(NM+1) = LABEL(NUM)
      DMC = .TRUE.
  501 L  =  DATA(I+1) * UNIT(8)
      IF (EQUAD) THEN
        B = DATA (I+2) * 3.335641 * 0.0001  ! EFIELD-GRADIENT (KV/CM --> GV/M)
      ELSE
        B = DATA (I+2) * UNIT(9)
      ENDIF
      AP =  DATA(I+3) * UNIT(1)
      J  =  1
      IF (EQUAD) THEN
        IF (SM .EQ. 0.0) GO TO 1180
        GAMMA = SQRT(1.0 + (RI / SM)**2)
        E = RI**2 / ((1. + GAMMA) * SM)
        RIE = E * (1. + GAMMA) / GAMMA
        KQ2 = B * CHARGE /(AP * RIE)
      ELSE
        KQ2 = B * CHARGE /(AP * RI)
      ENDIF
      K2H = KQ2
      CALL FOCUS
      J  =  3
      IF (.NOT. LILENS) THEN
       KQ2  =  - KQ2
      ENDIF
      K2V = KQ2
      CALL FOCUS
      IF (.NOT. (ALIGN .OR. LAY)) GO TO 5001
      X0(1,3) = L
      GO TO 5001
C
C     6. -- UPDATE (SLITS)
C
  600 IF(SLITS) GO TO 5003
      JANET = DATA(I+1)
      IF (R3P) CALL UPDAT3
      IF (JANET .NE. 0) GO TO 5003
      K  =  DATA(I+2)
      IF (K .EQ. 1) GO TO 610
      IF (K .EQ. 2) GO TO 620
      GO TO 5003
  610 IF (RCP .OR. R2P) CALL UPDATE
      GO TO 5003
  620 IF (R2P) CALL UPDAT2
      GO TO 5003
C
C     7. -- BEAM CENTROID SHIFT
C
  700 IF (R3P) CALL UPDAT3
      IF (R2P) CALL UPDAT2
      DO 710 J = 1, 6
      IPLUSJ = I + J
      COD(J) = DATA(IPLUSJ)*UNIT(J)
  710 CONTINUE
      CALL  SHFT
      GO TO 5003
C
C     8. -- MAGNET MISALIGNMENT
C
  800 DO 810 J = 1, 6
      IPLUSJ = I + J
      I2MOD =  2  -  MOD(J,2)
      VM(J) = DATA(IPLUSJ)*UNIT(I2MOD)
  810 CONTINUE
      TYT  =  DATA(I+7)
      RORC = MOD(TYT,10)
      IF(RORC .GE. 3) GO TO 5003
      IR = RORC + 1
      IF (MOD(TYT/10,10) .EQ. 1 .AND. NM .GE. 20) GO TO 5003
      IF (MOD(TYT/10,10) .EQ. 0) GO TO 820
      LABM(NM+1) = LABEL(NUM)
  820 CALL MALIGN
      GO TO 5003
C
C     11. -- ELECTROSTATIC ACCELERATOR
C
 1100 IF(.NOT.FIRST2) GO TO 1110
      IF(SM.EQ.0.0) GO TO 1180
      L=DATA(I+1)*UNIT(8)
      IF(L.NE.0.0) GO TO 1160
      VOLTS=DATA(I+2)*UNIT(11)
      E0=RI**2/((1.+GAMMA)*SM)
      E1=E0
      POT0=0.
      POT1=0.
      XPOLD=1.0
      FIRST2=.FALSE.
      GO TO 1115

 1110 L=DATA(I+1)*UNIT(8)
      POT1=VOLTS*DATA(I+2)
      E1=(POT1-POT0)*CHARGE+E0
 1115 ITYP1=IFIX(DATA(ISTOR(NUM+1)))
      ITYP2=IFIX(DATA(ISTOR(NUM+2)))
      IF(ITYP1.NE.11 .AND. ITYP2.NE.11) GO TO 1120
      IF(ITYP1.NE.11) GO TO 1118
      II=ISTOR(NUM+1)
      GO TO 1119
 1118 II=ISTOR(NUM+2)
 1119 POT2=VOLTS*DATA(II+2)
      E2=(POT2-POT1)*CHARGE+E0
      IF(E2.LE.0.0) GO TO 1140
      XP=DATA(II+1)*UNIT(8)
      GO TO 1130
 1120 XP=1.0
      POT2=POT1
      FIRST2=.TRUE.
C     FINV IS NOW RELATIVISTIC (1/F=-DELTAEFIELD/2*P*V)
 1130 P1V1 = (E1*(2.*SM+E1)) / (SM+E1)
      FINV=-((POT2-POT1)/XP-(POT1-POT0)/XPOLD)/(2.*P1V1)
      ROLD=RI
      RI=SQRT(E1*(2.*SM+E1))

      GAMMA0 = DSQRT(1.0D00 + (DBLE(ROLD) / DBLE(SM))**2)
      BETA0  = DSQRT(GAMMA0*GAMMA0-1.0D0)/GAMMA0
      GAMMA1 = DSQRT(1.0D0+(DBLE(RI) / DBLE(SM))**2)
      BETA1  = DSQRT(GAMMA1*GAMMA1-1.0D0)/GAMMA1

      PDP=ROLD/RI
C     PDP2 IS THE INTEGRAL OF 1/MOMENTUM ,LINEARLY RISING KINETIC ENERGY
      RATIO=(E1+SM+RI)/(E0+SM+ROLD)
      IF(ABS(RATIO-1.).LT.0.0001 .OR. POT0.EQ.POT1) GO TO 1132
      PDP2=ROLD/(E1-E0)*ALOG(RATIO)
      GO TO 1135
 1132 PDP2=1.0
 1135 POT0=POT1
      POT1=POT2
      E0=E1
      XPOLD=XP
C
      R(1,1)=1.
      R(1,2)=L*PDP2
      IF (ICONF .EQ. 1) THEN
       R(2,1)=0.0
      ELSE
       R(2,1)=FINV
      ENDIF
      R(2,2)=PDP+L*FINV*PDP2
C
      R(3,3)=R(1,1)
      R(3,4)=R(1,2)
      IF (ICONF .EQ. 3) THEN
       R(4,3)=0.0
      ELSE
       R(4,3)=FINV
      ENDIF
      R(4,4)=R(2,2)
C
      R(5,5)=BETA1/BETA0
      R(5,6)=L/(GAMMA0*GAMMA1)
      R(6,6)=PDP*BETA0/BETA1
C
      GAMMA=SQRT(1.0+(RI/SM)**2)
      NWK=1
      RECENT=.FALSE.
      IF (.NOT. (ALIGN .OR. LAY)) GO TO 5002
      X0(1,3) = L
      GO TO 5002
C
 1140 IF (FORMIO) WRITE(NOUT,1150)
 1150 FORMAT(' PARTICLE KINETIC ENERGY GOT BELOW ZERO, TRANSPORT STOPS.
     X')
      CALL MENU(1)
      RETURN
 1160 IF (FORMIO) WRITE(NOUT,1170)
 1170 FORMAT(' FIRST LENGTH HAS TO BE 0.0, 2ND ENTRY = DEVICE VOLTAGE.')
      CALL MENU(1)
      RETURN
 1180 IF (FORMIO) WRITE(NOUT,1190)
 1190 FORMAT(' PARTICLE MASS, IN ELECTRON UNITS, MUST BE GIVEN VIA A
     X 16. 3. M. ; CARD BEFORE AN ELECTROSTATIC DEVICE IS USED.')
      CALL MENU(1)
      RETURN
C
C     12. -- CORRELATIONS IN BEAM ELLIPSE
C
 1200 N  =  0
      DO 1210 J = 2, 6, 1
      JMIN1 = J - 1
      DO 1210 K = 1, JMIN1, 1
      N = N + 1
      IPLUSN = I + N
      SI(K,J)  = DATA(IPLUSN)*  SQRT( SI(J,J) * SI(K,K))
      SI( J,K )  =  SI( K,J )
 1210 CONTINUE
      GO TO 5003
C
C     13. -- INPUT-OUTPUT OPTIONS
C
 1300 CDB  =  DATA(I+1)
      IF ((CDB .GE. 20) .AND. (CDB .LE. 22)) GO TO 1320
      IF ((CDB .GE. 40) .AND. (CDB .LE. 43)) GO TO 1340
      IF ( CDB .EQ. 47) GO TO 1347
      IF ( CDB .EQ. 48) GO TO 1348
      GO TO 5003
C
C     MISALIGNMENT PIVOT
C
 1320 CALL PIVOT
      GO TO 5003
C
C     POLE FACE ROTATION ANGLE SPECS
C
 1340 NPFR = CDB - 40
      GO TO 5003
C
C     BENDING MAGNET SPECIFIED BY FIELD
C
 1347 ANIN = .FALSE.
      GO TO 5003
C
C     BENDING MAGNET SPECIFIED BY ANGLE
C
 1348 ANIN = .TRUE.
      GO TO 5003
C
C     14. -- ARBITRARY MATRIX
C
 1400 IF((PERIDX.OR.PERIDY) .AND. .NOT.RCPER) GO TO 5003
      J1 = DATA(I+7)
      DO 1410 K = 1, 6
      AUX = DATA(I+K)
      R(J1,K) = AUX * UNIT(J1) / UNIT(K)
      IF ( AUX * MASK(J1,K) .NE. 0.) MPS = 0
 1410 CONTINUE
      IF (.NOT. SEC .OR. J1 .NE. 6) GO TO 1480
      IF (R(6,1) .EQ. 0. .AND. R(6,2) .EQ. 0. .AND.
     X    R(6,3) .EQ. 0. .AND. R(6,4) .EQ. 0. .AND.
     X    R(6,5) .EQ. 0.) GO TO 1480
      IF (FORMIO) WRITE(NOUT, 1450)
 1450 FORMAT(' R(6,K), K=1, 5 MUST BE ZERO FOR SECOND ORDER RUNS.')
      CALL MENU(1)
      RETURN
 1480 IPNOTY = ISTOR(NUM+1)
      IF (IFIX(DATA(IPNOTY)) .EQ. TYPE) GO TO 5002
      GO TO 5001
C
C     15. -- UNITS
C
 1500 J = DATA(I+1) + 0.0001
      CALL UNITS (J)
      GO TO 5003
C
C     16. -- SPECIAL PARAMETERS
C
 1600 J =  DATA(I+1)
      IF (J. EQ. 40) GO TO 1611
      IF (J. EQ. 93 .OR. J. EQ. 94) GO TO 1611 
      IF (J. EQ. 95 .OR. J. EQ. 96) GO TO 1611 
      IF (J. EQ. 97 .OR. J. EQ. 98) GO TO 1611 
      IF (J .LE. 0 .OR. J .GT. 39) GO TO 1699
 1611 CALL SPESHL(J)
      GO TO 5003
 1699 IF (FORMIO) WRITE(NOUT, 3390)
 3390 FORMAT ('0  ERROR - CHECK INPUT DATA TYPE 16')
      GO TO 5003
C
C     17. -- SECOND ORDER CALCULATION
C
 1700 SEC = .TRUE.
      S1P  =  .TRUE.
      LINEAR = .TRUE.
      IF (SC1P) GO TO 2250
      GO TO 5003
C
C     18. -- SEXTUPOLE
C
 1800 L = DATA(I+1)*UNIT(8)
      R(1,2) = L
      R(3,4) = L
      IF (.NOT. (ALIGN .OR. LAY)) GO TO 5001
      X0(1,3) = L
      GO TO 5001
C
C     19. -- SOLENOID
C
 1900 L  =  DATA(I+1) * UNIT(8)
      B  =  DATA(I+2) * UNIT(9)
      KO = DEN (B * CHARGE / RI)
      IF (L .NE. 0.) GO TO 1910
C
C     ENTRANCE OR EXIT FRINGE FIELD ALONE (L=0)
C
      IF (SOLSEG) KO = - KO
      IF (B .NE. 0.) MPS = 0
      R(2,3) = KO / 2.0
      R(4,1) = - R(2,3)
      IF (SOLSEG) THEN
       SOLSEG = .FALSE.
      ELSE
       SOLSEG = .TRUE.
      ENDIF
      GO TO 1990
C
 1910 KL = KO*L
      SN  = SIN(KL)
      CS = COS(KL)
      IF (.NOT.SOLSEG) GO TO 1920
C
C     WITHOUT FRINGE FIELD
C
      R(2,2) = CS
      R(4,4) = R(2,2)
      IF (B .NE. 0.) MPS = 0
      R(1,4) = (1.0 - CS) / KO
      R(3,2) = - R(1,4)
      R(2,4) = SN
      R(4,2) = - R(2,4)
      R(1,2) = SN / KO
      R(3,4) = R(1,2)
      GO TO 1990
C
C     WITH FRINGE FIELD
C
 1920 R(4,4)  =  0.5 + 0.5*CS
      R(3,3)   = R(4,4)
      R(2,2)   = R(4,4)
      R(1,1)   = R(4,4)
      IF (B .NE. 0.) MPS = 0
      R(1,4)    =   (1.- CS)/KO
      R(3,2)    =  -R(1,4)
      R(4,1)    =  0.25*KO*(1.- CS)
      R(2,3)    =  -R(4,1)
      R(4,2)    =  -0.5*SN
      R(3,1)    =  R(4,2)
      R(2,4)    =  -R(3,1)
      R(1,3)    =  R(2,4)
      R(3,4)    =  R(1,3)*2./KO
      R(1,2)    =  R(3,4)
      R(4,3)    =  -0.25*KO*SN
      R(2,1)    =  R(4,3)
 1990 IF (.NOT. (ALIGN .OR. LAY)) GO TO 5001
      X0(1,3)  =  L
      GO TO 5001
C
C     20. -- BEAM ROTATION
C
 2000 TH  =  0.0174532925  *  DATA(I+1)
      R(4,4)  =  COS(TH)
      R( 3,3 )  =    R( 4,4  )
      R( 2,2 )  =    R( 4,4  )
      R( 1,1 )  =    R( 4,4  )
      AUX = SIN(TH)
      IF (ABS(AUX) .GT. 1.E-7) MPS = 0
      R(2,4)  =  AUX
      R( 1,3 ) =  AUX
      R( 4,2 ) = - AUX
      R( 3,1 ) = - AUX
      IF (.NOT. (ALIGN .OR. LAY)) GO TO 5001
      O(1,1,1) = R(1,1)
      O(1,2,1) = R(3,1)
      O(1,1,2) = R(1,3)
      O(1,2,2) = R(3,3)
      IF(RORC .LT. 3) GO TO 5001
      VM3 = R(3,1)*VM(1) + R(3,3)*VM(3)
      VM(1) = R(1,1)*VM(1) + R(1,3)*VM(3)
      VM(3) = VM3
      VM4 = R(4,2)*VM(2) + R(4,4)*VM(4)
      VM(2) = R(2,2)*VM(2) + R(2,4)*VM(4)
      VM(4) = VM4
      GO TO 5001
C
C     21. -- WIEN FILTER
C
 2100 L=DATA(I+1)*UNIT(8)
      B=DATA(I+2)*UNIT(9)
      IF(SM.NE.0.0) GO TO 2140
      IF (FORMIO) WRITE(NOUT,2130)
 2130 FORMAT(' PARTICLE MASS - IN ELECTRON UNITS - MUST BE GIVEN VIA A 16.
     X CARD BEFORE A 21. CARD IS USED.')
      CALL MENU(1)
      RETURN
 2140 GAMMA=SQRT(1.0+(RI/SM)**2)
      H=B*CHARGE/RI
      J=1
      KQ2=(H/GAMMA)**2
      CALL FOCUS
      R(1,6)=-(1-CS)/H
      R(2,6)=-SN/GAMMA
      R(3,4)=L
      IF (.NOT. (ALIGN .OR. LAY)) GO TO 5001
      X0(1,3) = L
      GO TO 5001
C
C     22. -- SPACE CHARGE
C
 2200 SC1P=.TRUE.
      IF(SEC) GO TO 2250
      STEP=DATA(I+1) * UNIT(8)
      AMP=DATA(I+2)
      IF (AMP .NE. 0.) MPS = 0
      BFREQ=DATA(I+3)
      IPTFQ=DATA(I+4)+.00001
      IF(IPTFQ.EQ.0) IPTFQ=1000000
      CAPPA=0.
      IF (AMP .EQ. 0.) GO TO 5003
      IF (SM .EQ. 0.0) GOTO 2220
      GAMMA2 = DSQRT(1.0D00 + (DBLE(RI) / DBLE(SM))**2)
      IF (GAMMA2 .EQ. 1.0D00) GO TO 2235
      BGS = GAMMA2 * GAMMA2 - 1.0D00
      FMASS=1836.7267*UNIT(10)/SM
      IF (BFREQ.NE.0.) GO TO 2240
      CAPPA=.1275D-6*DBLE(AMP)*DBLE(CHARGE)*DBLE(FMASS)/(BGS*DSQRT(BGS))
      GO TO 5003
 2240 CAPPA=20.7D-6*DBLE(AMP)*DBLE(CHARGE)*DBLE(FMASS)/(DBLE(BFREQ)*BGS)
      GO TO 5003
C
 2220 IF (FORMIO) WRITE(NOUT,2230)
 2230 FORMAT(' PARTICLE MASS, IN ELECTRON UNITS, MUST BE GIVEN VIA A
     X 16. CARD'/' BEFORE A 22. CARD IS USED. BOTH MUST BE PRECEDED
     X BY A TYPE 1. CARD')
      CALL MENU(1)
      RETURN
C
 2235 IF (FORMIO) WRITE(NOUT,2236)
 2236 FORMAT(' Beta=0, Gamma=1 (particles to slow for space
     X charge computation)')
      CALL MENU(1)
      RETURN
C
 2250 IF (FORMIO) WRITE(NOUT,2260)
 2260 FORMAT(' ATTEMPT TO RUN BOTH SECOND ORDER AND SPACE CHARGE
     X SIMULTANEOUSLY.')
      CALL MENU(1)
      RETURN
C
C     23. -- RF-CAVITY
C
 2300 VOLTS=DATA(I+1)
      IF (SEC) GO TO 2330
      RFPH=DATA(I+2)
      RFFREQ=DATA(I+3)
      IF(ABS(RFPH).GT.0.1) RFPH=180.0
      DATA(I+2)=RFPH
      IF(GAMMA.EQ.1.0) GO TO 2310
      BETAV=SQRT(GAMMA*GAMMA-1.0)/GAMMA
      RFPH=RFPH/57.29578
      MPS = 0
      R(6,5)=(COS(RFPH)*VOLTS*6.2831853*RFFREQ)/(89875.8289*SM*GAMMA
     X       *BETAV**3)
      R(4,3)=-(R(6,5)/(2.*GAMMA*GAMMA))
      R(2,1)=R(4,3)
      GO TO 5001
 2310 IF (FORMIO) WRITE(NOUT,2320)
 2320 FORMAT(' PARTICLE MASS, IN ELECTRON UNITS, MUST BE GIVEN VIA A
     X 16. CARD BEFORE A 23. CARD IS USED. BOTH MUST BE PRECEDED BY A
     X TYPE 1. CARD')
      CALL MENU(1)
      RETURN
 2330 IF (FORMIO) WRITE(NOUT,2340)
 2340 FORMAT(' NO SECOND ORDER WITH RF-CAVITY')
      CALL MENU(1)
      RETURN
C
C     50. -- LOWER AND UPPER LIMITS FOR RANDOM OPTIMIZER
C
 5000 J = DATA(I+1)
      IF (J.GE.1 .AND. J.LE.20) THEN
        ALOW(J)  = DATA(I+2)
        AHIGH(J) = DATA(I+3)
        IF (ALOW(J) .GT. AHIGH(J)) THEN
          XXX      = ALOW(J)
          ALOW(J)  = AHIGH(J)
          AHIGH(J) = XXX
        ENDIF
      ENDIF
      GO TO 5003
C
C     INDICATE WHETHER ELEMENT HAS MATRIX
C
 5001 NWK = 1
      R(5,6) = R(5,6)  +  L * SM**2/(RI**2 + SM**2)
      RECENT = .FALSE.
 5002 IF (SEC) CALL SECORD
      TYP1  =  TYPE
      LC  =  LC  +  L
      RETURN
C
 5003 NWK = 2
      RETURN
      END
      SUBROUTINE EMAT(E)
C
C     NEW SUBROUTINE FOR SPACE CHARGE. IT CALCULATES THE E MATRIX,
C     WHICH IS THE TRANSFER MATRIX FOR THE SPACE CHARGE FORCES FOR
C     THE LENGTH STEP IN THE IMPULSE APPROXIMATION
C
      COMMON /BLOC3/ TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC14/ RC3(6,6), TC3(6,6,6), R3P
      LOGICAL R3P
      COMMON /BLOC18/ SIT(6,6),CEN(6),RECENT
      LOGICAL RECENT
      COMMON /BLOC63/ Z216(216), U36(36)
      COMMON/SC/STEP,AMP,BFREQ,GAMMA,SCAPPA,IPTFQ,SC1P,SC3P
      LOGICAL SC1P,SC3P
C
      DIMENSION SIGMA(6,6),E(6,6)
      EQUIVALENCE(SIT,SIGMA)
      DOUBLE PRECISION A(3,3),H(3,3),G(3,3),X(3),EX,EY,DIS,CAPPA
      DOUBLE PRECISION EE(3),BT(3,3),GSQ,P,Q,R,S,U,V,PHI,AB
      LOGICAL REM3P
C
C     GET CURRENT SIGMA MATRIX ( DO NOT RUN UPDAT3 IN SBR BEAM)
C
      REM3P = R3P
      R3P = .FALSE.
      CALL BEAM
      R3P = REM3P
      RECENT=.FALSE.
      CAPPA=SCAPPA*L
      CALL UCOPY(U36,E,36)
      IF(BFREQ.GT.0.0) GO TO 30
C
C     BEAM IS CONTINUOUS
C
      IF(SIGMA(3,1) .NE. 0.0) GO TO 31
C
C     CHARGE ELLIPSE IS IN PRINCIPLE AXES
C
      XX = SQRT(SIGMA(1,1))
      YY = SQRT(SIGMA(3,3))
      E(2,1) = CAPPA/(XX*(XX+YY))
      E(4,3) = CAPPA/(YY*(XX+YY))
      RETURN
C
C     CHARGE ELLIPSE IS NOT IN PRINCIPLE AXES
C
   31 P = SIGMA(1,1)
      U = SIGMA(3,3)
      Q = P - U
      R = P + U
      S = SIGMA(3,1)
      DIS = SQRT(Q**2 + 4.0 * S**2)
C     EIGENVALUES
      X(1) = 0.5 * (R + DIS)
      X(2) = 0.5 * (R - DIS)
C     EIGENVECTORS
      H(2,1) = (X(1) - P) / S
      H(1,1) = 1.0 / SQRT(1.0 + H(2,1) * H(2,1))
      H(2,1) = H(1,1) * H(2,1)
      H(2,2) = (X(2) - P) / S
      H(1,2) = 1.0 / SQRT(1.0 + H(2,2) * H(2,2))
      H(2,2) = H(1,2) * H(2,2)
      XX = SQRT(X(1))
      YY = SQRT(X(2))
C     ELECTRIC FIELD IN ROTATED SYSTEM
      EX = CAPPA/(XX*(XX+YY))
      EY = CAPPA/(YY*(XX+YY))
C     ROTATE BACK TO ORIGINAL DIRECTION AND CONSTRUCT E MATRIX
      E(4,1) = EX * H(1,1) * H(2,1) + EY * H(1,2) * H(2,2)
      E(2,1) = EX * H(1,1)**2 + EY * H(1,2)**2
      E(4,3) = EX * H(2,1)**2 + EY * H(2,2)**2
      E(2,3) = E(4,1)
      RETURN
C
C     BEAM IS BUNCHED
C
   30 CONTINUE
      GSQ = GAMMA*GAMMA
      IF(SIGMA(3,1) .NE. 0.0) GO TO 5
      IF(SIGMA(5,1) .NE. 0.0) GO TO 5
      IF(SIGMA(5,3) .NE. 0.0) GO TO 5
C     CHARGE ELLIPSOID IS IN PRINCIPAL AXES
      DO 6 I=1,3
      X(I) = SIGMA(2*I-1,2*I-1)
    6 CONTINUE
      CALL ELECT(X,EE)
      E(2,1) = EE(1)*CAPPA
      E(4,3) = EE(2)*CAPPA
      E(6,5) = EE(3)*CAPPA*GSQ
      RETURN
    5 CONTINUE
C     CHARGE ELLIPSOID IS NOT IN PRINCIPAL AXES
      DO 7 I=1,3
      DO 8 J=1,I
      A(I,J)=SIGMA(2*I-1,2*J-1)
      A(J,I)=A(I,J)
    8 CONTINUE
    7 CONTINUE
C     FIND EIGENVALUES
      P = -A(1,1)-A(2,2)-A(3,3)
      Q = A(1,1)*A(2,2)+A(1,1)*A(3,3)+A(2,2)*A(3,3)-A(1,2)**2
     2  -A(1,3)**2 -A(2,3)**2
      R = A(1,3)**2*A(2,2)+A(1,2)**2*A(3,3)+A(2,3)**2*A(1,1)
     2  -A(1,1)*A(2,2)*A(3,3)-2.0*A(1,2)*A(1,3)*A(2,3)
      S = (3.0*Q - P**2)/3.0
      U =-(2.0*P**3 - 9.0*P*Q + 27.0*R)/(54.0*(SQRT(-S/3.0)**3))
      IF(ABS(U) .GE. 1.0) GO TO 25
      V = SQRT(1.0 - U**2)
      PHI = ATAN2(V,U)/3.0
      GO TO 26
   25 PHI = 0.0
      IF(U .LE. 0.0) PHI = 1.0471976
   26 CONTINUE
      DO 1 I=1,3
      X(I) = 2.0*SQRT(-S/3.0)*COS(PHI + I*2.0943951) - P/3.0
    1 CONTINUE
C     FIND EIGENVECTORS
      H(1,1) = A(1,2)*A(2,3)-A(1,3)*(A(2,2)-X(3))
      H(2,1) = A(1,2)*A(1,3)-A(2,3)*(A(1,1)-X(3))
      H(3,1) = (A(1,1)-X(3))*(A(2,2)-X(3))-A(1,2)**2
      H(1,2) = A(1,3)*A(2,3)-A(1,2)*(A(3,3)-X(2))
      H(2,2) = (A(1,1)-X(2))*(A(3,3)-X(2))-A(1,3)**2
      H(3,2) = A(1,2)*A(1,3)-A(2,3)*(A(1,1)-X(2))
      H(1,3) = (A(2,2)-X(1))*(A(3,3)-X(1))-A(2,3)**2
      H(2,3) = A(1,3)*A(2,3)-A(1,2)*(A(3,3)-X(1))
      H(3,3) = A(1,2)*A(2,3)-A(1,3)*(A(2,2)-X(1))
C     NORMALIZE EIGENVECTORS
      DO 2 J=1,3
      AB = 0.0
      DO 3 I=1,3
      AB = AB + (H(I,J)*1.D+10)**2
    3 CONTINUE
      AB = 1.D+10/SQRT(AB)
      DO 4 I=1,3
      H(I,J) = AB*H(I,J)
    4 CONTINUE
    2 CONTINUE
C     REQUIRE THAT EIGENVALUE 1 CORRESPOND WITH EIGENVECTOR 1, ETC.
      DO 40 I=1,3
      DO 41 J=1,3
      G(I,J) = 0.0
      DO 42 K=1,3
      G(I,J) = G(I,J) + A(I,K)*H(K,J)
   42 CONTINUE
   41 CONTINUE
   40 CONTINUE
      DO 43 I=1,3
      X(I) = 0.0
      DO 44 K=1,3
      X(I) = X(I) + H(K,I)*G(K,I)
   44 CONTINUE
   43 CONTINUE
      CALL ELECT(X,EE)
C     CONSTRUCT ELECTRIC FIELD MATRIX
      DO 11 I=1,3
      DO 12 J=1,3
      BT(I,J) = 0.0
   12 CONTINUE
      BT(I,I) = EE(I)*CAPPA
   11 CONTINUE
C     ROTATE ELECTRIC FIELD MATRIX BACK TO ORIGINAL DIRECTION
      DO 13 I=1,3
      DO 14 J=1,3
      A(I,J) = BT(I,I)*H(J,I)
   14 CONTINUE
   13 CONTINUE
      DO 15 I=1,3
      DO 16 J=1,3
      G(I,J) = 0.0
      DO 17 K=1,3
      G(I,J) = G(I,J) + H(I,K)*A(K,J)
   17 CONTINUE
   16 CONTINUE
   15 CONTINUE
C     CONSTRUCT E MATRIX
      DO 20 J=1,3
      DO 21 I=1,2
      E(2*I,2*J-1) = G(I,J)
   21 CONTINUE
      E(6,2*J-1) = G(3,J)*GSQ
   20 CONTINUE
      RETURN
      END
      SUBROUTINE EXTENT
      COMMON /BLOC3/  TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     1                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     1                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC18/ SIT(6,6), CEN(6), RECENT
      LOGICAL RECENT
      COMMON /BLOC24/ B, KQ2, KVK, K2H, K2V, CS, SN, CM1N, J
      REAL KQ2, KVK, K2H, K2V
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC29/ A(21), CW, CA(21,21), SCALE(21), CASAV(21,21),
     1                PMARQ, CHSMIN, XNORM, GNORM, EPS
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      LOGICAL LOGIC
      DIMENSION RSV(6,20)
C
      IF (DEO .EQ. 0.0 .AND. TYPE .EQ. 10) GO TO 100
      CW = 1.0/SD**2
      SIJJ = SIT(J,J)
      IF (S1P) SIJJ = SIJJ - CEN(J)**2
      SSJJ = SQRT(SIJJ)
      A(1) = DEO - SSJJ/UNIT(J)
      CALL CLI(LOGIC)
      IF(LOGIC)   RETURN
      IF (NV1 .LT. 1) GO TO 50
      DO 40 N = 1, NV1, 1
      IF (R2P) GO TO 10
      IF (.NOT. SVP(N)) GO TO 40
      SVJJ = SV(J,J,N)
      IF (.NOT. S1P) GO TO 30
      COVJ = COV(J,N)
      GO TO 30
   10 SVJJ = 0.0
      COVJ = 0.0
      IF (.NOT. SVP(N)) GO TO 20
      DO 11 L1 = 1, 6
      DO 11 L2 = 1, 6
      SVJJ = SVJJ + RC2(J,L1)*SV(L1,L2,N)*RC2(J,L2)
   11 CONTINUE
      IF (.NOT. S1P) GO TO 20
      DO 13 L1 = 1, 6
      COVJ = COVJ + RC2(J,L1)*COV(L1,N)
   13 CONTINUE
   20 IF (.NOT. R2VP(N)) GO TO 30
      DO 21 L1 = 1, 6
      DO 21 L2 = 1, 6
      SVJJ = SVJJ + 2.0*R2V(J,L1,N)*SI(L1,L2)*RC2(J,L2)
   21 CONTINUE
      IF (.NOT. S1P) GO TO 30
      DO 23 L1 = 1, 6
      COVJ = COVJ + R2V(J,L1,N)*CO(L1)
   23 CONTINUE
   30 ANC = SVJJ
      IF (S1P) ANC = ANC - 2.0*COVJ*CEN(J)
      A(N+1) = 0.5*ANC/(SSJJ*UNIT(J))
   40 CONTINUE
   50 CALL GATHER
      RETURN
C
C     MINIMIZATION OF BEAM SIZE
C
  100 CW = 1.0/(SD*UNIT(J))**2
      SS = 0.0
      DO 110 L1 = 1, 6
      DO 110 L2 = 1, 6
      SS = SS + RC2(J,L1)*RC2(J,L2)*SI(L1,L2)
  110 CONTINUE
      CA(1,1) = CA(1,1) + SS*CW
C
      IF (NV1 .LT. 1) GO TO 150
      DO 120 N = 1, NV1
      DO 120 L1 = 1, 6
      SS = 0.0
      DO 115 L2 = 1, 6
      SS = SS + R2V(J,L2,N)*SI(L1,L2)
  115 CONTINUE
      RSV(L1,N) = SS
  120 CONTINUE
C
      DO 130 N = 1, NV1
      SS = 0.0
      DO 125 K = 1, 6
      SS = SS + RC2(J,K)*RSV(K,N)
  125 CONTINUE
      CA(N+1,1) = CA(N+1,1) - SS*CW
  130 CONTINUE
C
      DO 140 N1 = 1, NV1
      DO 140 N2 = 1, N1
      SS = 0.0
      DO 135 K = 1, 6
      SS = SS + R2V(J,K,N1)*RSV(K,N2)
  135 CONTINUE
      CA(N1+1,N2+1) = CA(N1+1,N2+1) + SS*CW
  140 CONTINUE
  150 CONTINUE
C
      IF (SEC) CALL CONSEC
      RETURN
      END
      SUBROUTINE FITTIN
C     READ IN DATA FOR NEXT CASE
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC5/ VSTOR(20), TIE(NND)
      INTEGER VSTOR, TIE
      COMMON /BLOC5A/ LABEL(NNL), LABM(20)
      CHARACTER       LABEL*4, LABM*4
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      COMMON /BLOC41/ LW, FLUSH, INDIC, NTYPE, LENGTH,
     A                NWORD, NVARY, DATUM(30), VARY(30)
      INTEGER VARY
      LOGICAL FLUSH
      COMMON /BLO41A/ IMAGE(80), LABLE
      CHARACTER       IMAGE*1, LABLE*4
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
      COMMON /BLOC49/ NL, FAILED, ITER
      LOGICAL FAILED
      COMMON /BLO49A/ LABS(20)
      CHARACTER       LABS*4
      DATA IZERO /  0 /
      NL = 0
C
C     READ AND PRINT TITLE AND INDICATOR
C
    5 CALL RDNEXT (2)
      CALL RDSKIP
      CALL RDSTRG (IMAGE, 80, LW)
      IF (FORMIO) WRITE (NOUT, 9000) IMAGE
      CALL RDSKIP
      CALL RDFIX  (INDIC, IFLAG)
      CALL RDNEXT (- 1)
      IF (FORMIO) WRITE (NOUT, 9005) INDIC
      IF (IABS(INDIC) .LE. 2 .AND. IFLAG .EQ. 0) GO TO 10
      IF (INDIC.EQ.-9) GO TO 800
      IF (FORMIO) WRITE (NOUT, 9010)
      INDIC = 0
   10 IF(INDIC .NE. 0) GO TO 200
C
C     READ NEW SYSTEM
C
  100 NEL = 0
      I = 1
      ISTOR(1) = 1
      FLUSH = .FALSE.
      CALL UNITS (0)
  110 CALL RDELMT
      IF(NWORD .EQ. 0) GO TO 400
      IF(FLUSH) GO TO 110
      NEL = NEL + 1
      IF(NEL .GE. NNL .OR. I + LENGTH .GE. NND) GO TO 150
      LABEL(NEL) = LABLE
      DO 120 J = 1, LENGTH
      DATA(I) = DATUM(J)
      TIE (I) = VARY (J)
  120 I = I + 1
      DATA(I) = 0.0
      ISTOR(NEL+1) = I
      GO TO 110
  150 IF (FORMIO) WRITE (NOUT, 9150) NEL, I
      FLUSH = .TRUE.
      GO TO 110
C
C     CONVERT INTERNAL VARY CODES TO EXTERNAL
C
  200 SEC = .FALSE.
      DO 210 NUM = 1, NEL
      I = ISTOR(NUM)
      NTYPE = DATA(I)
      IF(NTYPE .LE.  0) GO TO 210
      IF(NTYPE .EQ. 17) SEC = .TRUE.
      NVARY = NIV(NTYPE)
      IF(NVARY .EQ. 0) GO TO 210
      DO 205 JV = 1, NVARY
      I = I + 1
      K = IABS(TIE(I))
      IF(K .NE. 0) TIE(I) = ISIGN(VSTOR(K), TIE(I))
  205 CONTINUE
  210 CONTINUE
C
C     MODIFY EXISTING SYSTEM
C
  220 NUM = 0
  230 CALL RDELMT
      IF(NWORD .EQ. 0) GO TO 400
      IF(FLUSH) GO TO 230
      IF(LABLE .EQ. BLANK) GO TO 270
  250 J1 = NUM + 1
      DO 260 J = J1, NEL
      IF(LABLE .EQ. LABEL(J)) GO TO 300
  260 CONTINUE
      IF(NUM .NE. 0) GO TO 220
  270 IF (FORMIO) WRITE (NOUT, 9270) LABLE
      FLUSH = .TRUE.
      GO TO 230
C
C     LABEL HAS BEEN FOUND. NOW REPLACE ELEMENT
C
  300 NUM = J
      I = ISTOR(NUM)
      K = I
      L = ISTOR(NUM+1) - I
      IF (LENGTH .LE. L) GO TO 320
      IF (FORMIO) WRITE (NOUT, 9300) LABLE
      FLUSH = .TRUE.
      GO TO 230
  320 DO 330 J = 1, NWORD
      DATA(I) = DATUM(J)
  330 I = I + 1
      DO 340 J = 1, L
      TIE(K) = VARY(J)
  340 K = K + 1
      IF(NUM - NEL) 250, 220, 220
C
C     OPTIONALLY PRINT MODIFIED SYSTEM
C
  400 IF (FORMIO) WRITE (NOUT, 9400)
      IF (IABS(INDIC) .LT. 2) GO TO 500
      IF (FORMIO) WRITE (NOUT, 9410)
      IF (FORMIO) WRITE (NOUT, 9000) IMAGE, IZERO
      DO 410 NUM = 1, NEL
      I = ISTOR(NUM)
      L = ISTOR(NUM+1) - ISTOR(NUM)
  410 IF (FORMIO) CALL PRINT1 (LABEL(NUM), L, DATA(I), TIE(I))
      IF (FORMIO) WRITE (NOUT, 9400)
C
C     CONVERT EXTERNAL VARY CODES TO INTERNAL
C
  500 IF(FLUSH) GO TO 5
      ALIGN = .FALSE.
      SEC   = .FALSE.
      NC  = 0
      NV1 = 0
      NVMAX = 20
      DO 510 J = 1, NVMAX
  510 VSTOR(J) = 0
      DO 700 NUM = 1, NEL
      I = ISTOR(NUM)
      NTYPE = DATA(I)
      IF(NTYPE .LE. 0) GO TO 700
      IF(NTYPE .EQ.  8) ALIGN = .TRUE.
      IF(NTYPE .NE. 17) GO TO 520
      SEC = .TRUE.
      NVMAX = 10
  520 IF(NTYPE .EQ. 10) NC = NC + 1
      NVARY = NIV(NTYPE)
      IF(NVARY .EQ. 0) GO TO 700
      NVOLD = NV1
      DO 690 JV = 1, NVARY
      I = I + 1
      IVARY = IABS(TIE(I))
      IF(IVARY - 1) 690, 650, 610
  610 IF(IVARY .LT. 7 .OR. IVARY .GT. 9) GO TO 620
      IVARY = IVARY - 5
      TIE(I) = - TIE(I)
  620 IF(NV1 .EQ. 0) GO TO 650
      DO 630 N = 1, NV1
      IF(VSTOR(N) .EQ. IVARY) GO TO 680
  630 CONTINUE
  650 IF(NV1 .LT. NVMAX) GO TO 670
  660 IF (FORMIO) WRITE (NOUT, 9660) JV, NUM
      TIE(I) = 0
      GO TO 690
  670 NV1 = NV1 + 1
      VSTOR(NV1) = IVARY
      N = NV1
  680 TIE(I) = ISIGN(N, TIE(I))
  690 CONTINUE
      IF (NV1 .NE. NVOLD) THEN
      NL = NL + 1
      LABS(NL) = LABEL(NUM)
      END IF
  700 CONTINUE
      RETURN
C
C     DEACTIVATE SEQUENCE
C
  800 NUM = 0
  810 CALL RDELMT
      IF (NWORD .EQ. 0) GO TO 820
      GO TO 810
  820 DO 840 NUM = 1, NEL
      I = ISTOR(NUM)
      NTYPE = DATA(I)
      IF (NTYPE .LE. 0) GO TO 840
      IF (NTYPE .EQ. 10) DATA(I)=-10
      NVARY = NIV(NTYPE)
      IF (NVARY .EQ. 0) GO TO 840
      DO 830 JV = 1, NVARY
      I = I + 1
  830 TIE(I) = 0
  840 CONTINUE
      IF (FORMIO) WRITE (NOUT, 9001)
      GO TO 5
C
 9000 FORMAT('1"',80A1,'"')
 9001 FORMAT(/' Sequence not active.')
 9005 FORMAT('0',I5)
 9010 FORMAT('0INDICATOR VALUE WRONG OR MISSING - ZERO ASSUMED')
 9150 FORMAT('0DATA OVERFLOW, NEL =',I4,'   I =',I5)
 9270 FORMAT('0NO MATCH FOUND FOR LABEL "',A4,'"')
 9300 FORMAT('0LABEL "',A4,'" CANNOT BE REPLACED - DATA OVERLAP')
 9400 FORMAT('0SENTINEL')
 9410 FORMAT('0MODIFIED SYSTEM FOLLOWS ...')
 9660 FORMAT('0PARAMETER',I3,' OF ELEMENT ',I4,
     A       ' NOT VARIED - TOO MANY PARAMETERS')
      END
      SUBROUTINE FOCUS
      COMMON /BLOC3/ TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC11/ R(6,6), RV(6,6), T(6,6,6), TV(6,6,6)
      COMMON /BLOC24/ B, KQ2, KVK, K2H, K2V, CS, SN, CM1N, J
      REAL KQ2, KVK, K2H, K2V
      REAL KL
C
      KL = SQRT( ABS(KQ2)) * L
      IF ( KQ2 .GE. 0.) GO TO 349
      Y = EXP(KL)
      OOY = 1.0/Y
      CS = 0.5*(Y + OOY)
      SN = 0.5*(Y - OOY)
      GO TO 350
  349 CS = COS(KL)
      SN = SIN(KL)
  350 R(J+1,J+1) = CS
      R(J,J) = CS
      IF ( KL  .EQ. 0.)  GO TO 351
      R(J, J+1) = L * SN/ KL
      GO TO 352
  351 R(J,J+1)  =  L
  352 R(J+1, J) =  -KQ2 * R(J,J+1)
      RETURN
      END

      SUBROUTINE FOCUSE(XL,XAL,CC)

      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC11/ R(6,6), RV(6,6), T(6,6,6), TV(6,6,6)
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC23/ H, AL, NB, BDB, CHARGE, LILENS, EQUAD, EBEND
      REAL NB
      COMMON /BLOC33/ FOTILT, SM
      COMMON /BLOC58/ FIELD

      REAL KH, KV, KHL, KVL

      GAMMA=SQRT(1.0+(RI/SM)**2)
      BETA=SQRT(1.0-1.0/GAMMA**2)
      ENER=RI**2/((1.+GAMMA)*SM)
      B2=BETA*BETA
      H = XAL / XL
      FIELD = ENER*H*(GAMMA+1.0)/(GAMMA*CHARGE*3.335641*0.0001) ! KV/CM

      IF (CC .EQ. 0.0) THEN       ! CYLINDRICAL
       PP = SQRT(2.0 - B2)
       QQ = 0.0
      ELSE IF (CC .EQ. 1.0) THEN  ! SPHERICAL
       PP = SQRT(1.0 - B2)
       QQ = 1.0
      ELSE                        ! TOROIDAL
       PP = SQRT(2. - CC - B2)
       QQ = SQRT(CC)
      ENDIF

      KH  = PP * H
      KV  = QQ * H
      KHL = KH * XL
      KVL = KV * XL

      CF  = COS(KHL)
      SF  = SIN(KHL)
      CD  = COS(KVL)
      SD  = SIN(KVL)

      R(1,1) = CF
      R(1,2) = SF / KH
      R(2,1) = -SF * KH
      R(2,2) = R(1,1)

      R(1,6) = H * (1.0 - CF) / KH**2
      R(2,6) = H * R(1,2)
      R(6,6) = 1.0

      R(3,3) = CD
      IF (KV .EQ. 0.0) THEN
       R(3,4) = XL
      ELSE
       R(3,4) = SD / KV
      ENDIF
      R(4,3) = -SD * KV
      R(4,4) = R(3,3)

      R(5,1) = -R(2,6)
      R(5,2) = -R(1,6)
      R(5,6) = (KHL - SF) / KH

      RETURN
      END

      SUBROUTINE FORM
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC5/ VSTOR(20), TIE(NND)
      INTEGER VSTOR, TIE
      COMMON /BLOC5A/ LABEL(NNL), LABM(20)
      CHARACTER       LABEL*4, LABM*4
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC29/ A(21), CW, CA(21,21), SCALE(21), CASAV(21,21),
     1                PMARQ, CHSMIN, XNORM, GNORM, EPS
      LOGICAL ACTIV(21)
      INTEGER TYPE, VARY
      REAL LIMIT
C
C     ZERO LOWER LEFT HALF OF MATRIX OF NORMAL EQUATIONS
C
      NP1 = NV1 + 1
      DO 10 L1 = 1, NP1
      DO 10 L2 = 1, L1
      CA(L1,L2) = 0.0
   10 CONTINUE
C
C     FILL IN MATRIX OF NORMAL EQUATIONS
C
      CALL DERIVE
C
C     SYMMETRIZE MATRIX
C
      DO 20 L1 = 2, NV1, 1
      L1P1 = L1 + 1
      DO 20 L2 = L1P1, NP1
      CA(L1,L2) = CA(L2,L1)
   20 CONTINUE
C
C     DETERMINE WHICH VARIABLES WILL NOT HIT LIMITS
C
      IF (CHSMIN .GT. 0.0 .AND. CA(1,1) .GE. CHSMIN) RETURN
      CHSMIN = CA(1,1)
      DO 30 N = 1, NP1
   30 ACTIV(N) = .TRUE.
      DO 70 NUM = 1, NEL
      I = ISTOR(NUM)
      TYPE = DATA(I)
      IF (TYPE .LE. 0) GO TO 70
      NVT = NIV(TYPE)
      IF (NVT .LT. 1) GO TO 70
      DO 60 J = 1, NVT
      IPLUSJ = I + J
      VARY = TIE(IPLUSJ)
      IF (VARY .EQ. 0) GO TO 60
      IVARY = IABS(VARY) + 1
      SIG = SIGNF(VARY)
      X2 = DATA(IPLUSJ)
C
      SI = LIMIT(TYPE,J,2)
      IF (SI .EQ. 0.0) GO TO 40
      SI = LIMIT(TYPE,J,1)
      IF (X2 .GT. SI) GO TO 40
      ACTIV(IVARY) = ACTIV(IVARY) .AND. SIG*CA(IVARY,1) .GT. 0.0
C
   40 SI = LIMIT(TYPE,J,4)
      IF (SI .EQ. 0.0) GO TO 60
      SI = LIMIT(TYPE,J,3)
      IF (X2 .LT. SI) GO TO 60
      ACTIV(IVARY) = ACTIV(IVARY) .AND. SIG*CA(IVARY,1) .LT. 0.0
   60 CONTINUE
   70 CONTINUE
C
      DO 80 N = 2, NP1
      IF (ACTIV(N)) GO TO 80
      DO 75 J = 1, NP1
      CA(J,N) = 0.0
   75 CA(N,J) = 0.0
   80 CONTINUE
C
C     CALCULATE SCALING FACTOR FOR NORMAL MATRIX
C
      SCALE(1) = 1.0
      DO 90 J = 2, NP1
      SCALE(J) = 0.0
      IF (CA(J,J) .GT. 0.0) SCALE(J) = 1.0/SQRT(CA(J,J))
   90 CONTINUE
C
C     SAVE CA ARRAY
C
      DO 100 J = 2, NP1
      DO 100 K = 1, NP1
  100 CASAV(J,K) = CA(J,K)
C
C     CALCULATE MAGNITUDE OF GRADIENT
C
      GNORM = 0.0
      DO 110 J = 2, NP1
      CAJ1 = CA(J,1)
  110 GNORM = GNORM + CAJ1*CAJ1
      GNORM = SQRT(GNORM)
      RETURN
      END
      SUBROUTINE GATHER
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC3/ TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC29/ A(21), CW, CA(21,21), SCALE(21), CASAV(21,21),
     1                PMARQ, CHSMIN, XNORM, GNORM, EPS
      COMMON /BLOC47/ REG(10), DREG(10,20), LREG(10)
      LOGICAL LREG
C
      NP1 = NV1 + 1
      IF (TYPE .NE. 10) GO TO 100
      DO 10 L1 = 1, NP1
      DO 10 L2 = 1, L1
      CA(L1,L2) = CA(L1,L2) + CW * A(L1) * A(L2)
   10 CONTINUE
      RETURN
C
  100 J = DATA(I+3)
      LREG(J) = .TRUE.
      REG(J) = - A(1)
      DO 110 N = 1, 20
  110 DREG(J,N) = 0.0
      IF (NV1 .LT. 1) RETURN
      DO 120 N = 1, NV1
  120 DREG(J,N) = A(N+1)
      RETURN
      END
      SUBROUTINE GETTIT(TYPE,TITLE)
C
      INTEGER TYPE
      CHARACTER TITLE*10
C
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC23/ H, AL, NB, BDB, CHARGE, LILENS, EQUAD, EBEND
      REAL NB
      LOGICAL LILENS, EQUAD, EBEND
      COMMON /BLOC59/ SLITS
      LOGICAL SLITS
C
      IF      (TYPE .EQ.  1) THEN
       TITLE = '*BEAM*    '
       IF(ISTOR(NUM+1) .GT. I + 8) TITLE = '*ADD BEAM*'
      ELSE IF (TYPE .EQ.  2) THEN
       TITLE = '*ROTAT*   '
       IF (DATA(I+1) .GE. 1000) TITLE = '*FRINGE*  '
      ELSE IF (TYPE .EQ.  3) THEN
       TITLE = '*DRIFT*   '
      ELSE IF (TYPE .EQ.  4) THEN
       TITLE = '*BEND*    '
       IF (EBEND) TITLE = '*EPRI*    '
      ELSE IF (TYPE .EQ.  5) THEN
       TITLE = '*QUAD*    '
       IF (EQUAD) TITLE = '*EQUAD*   '
      ELSE IF (TYPE .EQ.  6) THEN
       TITLE = '*UPDATE*  '
       IF (SLITS) TITLE = '*SLIT*    '
      ELSE IF (TYPE .EQ.  7) THEN
       TITLE = '*SHIFT*   '
      ELSE IF (TYPE .EQ.  8) THEN
       TITLE = '*MISALIGN*'
      ELSE IF (TYPE .EQ. 10) THEN
       TITLE = '*FIT*     '
      ELSE IF (TYPE .EQ. 11) THEN
       TITLE = '*ACC*     '
      ELSE IF (TYPE .EQ. 12) THEN
       TITLE = '*CORR*    '
      ELSE IF (TYPE .EQ. 14) THEN
       TITLE = '*MATRIX*  '
      ELSE IF (TYPE .EQ. 16) THEN
       TITLE = '*PARAM*   '
      ELSE IF (TYPE .EQ. 18) THEN
       TITLE = '*SEXT*    '
      ELSE IF (TYPE .EQ. 19) THEN
       TITLE = '*SOLO*    '
      ELSE IF (TYPE .EQ. 20) THEN
       TITLE = '*Z RO*    '
      ELSE IF (TYPE .EQ. 21) THEN
       TITLE = '*WIEN*    '
      ELSE IF (TYPE .EQ. 22) THEN
       TITLE = '*SP CH*   '
      ELSE IF (TYPE .EQ. 23) THEN
       TITLE = '*RF CAV*  '
      ELSE IF (TYPE .EQ. 24) THEN
       TITLE = '*DEF RC*  '
      ELSE IF (TYPE .EQ. 25) THEN
       TITLE = '*COMBIN*  '
      ELSE IF (TYPE .EQ. 50) THEN
       TITLE = '*LIMIT*   '
      ELSE
       TITLE = '          '
      ENDIF
      RETURN
      END
      SUBROUTINE HUNT2
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC21/ EN, ES, BE, APB(2), LAYL, LAYX, RAB1,RAB2,RINVL
      REAL LAYL, LAYX
      COMMON /BLOC27/ CT(6,6), CT0(6,6), CT1(3,3), VM(6), DMC, NM
      LOGICAL DMC
C
C     CHECK FOR FOLLOWING FRINGE FIELD SPECIFICATION
C
      DMC = .TRUE.
      J = NUM
   10 J = J + 1
      IF(J .GT. NEL) GO TO 20
      II = ISTOR(J)
      IF (DATA(II) .EQ. 2.0) GO TO 30
      IF(DATA(II) .EQ. 13.) GO TO 10
   20 RETURN
C
C     DETERMINE IF IT PERTAINS TO THIS MAGNET
C
   30 NUMA = NUM
      NUM = J
      CALL CHEK(CKK)
      DMC = ES .EQ. 1.0 .OR. CKK .EQ. 0.0
      NUM = NUMA
      RETURN
      END
      SUBROUTINE INIT1
      COMMON /BLOC12/ RC(6,6), RCV(6,6,20), TC(6,6,6), RCP, RVP(20)
      LOGICAL RCP, RVP
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     A                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC15/ RS(6,6), RT(6,6), TS(6,6,6), TT(6,6,6)
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC18/ SIT(6,6), CEN(6), RECENT
      LOGICAL RECENT
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      COMMON /BLOC63/ Z216(216), U36(36)
C
      CALL UCOPY(U36,RC,36)
      CALL UCOPY(U36,RC2,36)
      IF (SEC) THEN
      CALL UCOPY(Z216,TC,216)
      CALL UCOPY(Z216,TC2,216)
      END IF
      IF (NV1 .LT. 1) RETURN
      DO 100 IR2P = 1, NV1, 1
      SVP(IR2P)= .FALSE.
  100 CONTINUE
      RECENT = .FALSE.
      S1P = .FALSE.
      RETURN
      END
      SUBROUTINE INIT2
      COMMON /BLOC12/ RC(6,6), RCV(6,6,20), TC(6,6,6), RCP, RVP(20)
      LOGICAL RCP, RVP
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     A                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC14/ RC3(6,6), TC3(6,6,6), R3P
      LOGICAL R3P
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC18/ SIT(6,6), CEN(6), RECENT
      LOGICAL RECENT
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
C
      IF (NV3 .LT. 1) GO TO 10
      DO 5 N = 1, NV3, 1
      RVP(N) = .FALSE.
      R2VP(N)= .FALSE.
      SVP(N) = .FALSE.
    5 CONTINUE
   10 CONTINUE
      RCP = .FALSE.
      R2P  = .FALSE.
      R3P = .FALSE.
      S1P = .FALSE.
      RECENT = .FALSE.
      RETURN
      END
      SUBROUTINE INITZE
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC4/ LC, TOTANG, LCV(20)
      REAL LC, LCV
      COMMON /BLOC6/ PERIDX, PERIDY, PERIDC, RCPER, EMITX, EMITY
      LOGICAL PERIDX, PERIDY, PERIDC, RCPER
      COMMON /BLOC12/ RC(6,6), RCV(6,6,20), TC(6,6,6), RCP, RVP(20)
      LOGICAL RCP, RVP
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     A                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC14/ RC3(6,6), TC3(6,6,6), R3P
      LOGICAL R3P
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC18/ SIT(6,6), CEN(6), RECENT
      LOGICAL RECENT
      COMMON /BLOC21/ EN, ES, BE, APB(2), LAYL, LAYX, RAB1,RAB2,RINVL
      REAL LAYL, LAYX
      COMMON /BLOC23/ H, AL, NB, BDB, CHARGE, LILENS, EQUAD, EBEND
      REAL NB
      LOGICAL LILENS, EQUAD, EBEND
      COMMON /BLOC25/ AP, CAP, JANET
      LOGICAL CAP
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC27/ CT(6,6), CT0(6,6), CT1(3,3), VM(6), DMC, NM
      LOGICAL DMC
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
      COMMON /BLOC31/ J1, TYP1
      INTEGER TYP1
      COMMON /BLOC33/ FOTILT, SM
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      COMMON /BLOC35/ KL, KO, SOLSEG
      REAL KL, KO
      LOGICAL SOLSEG
      COMMON /BLOC36/ VARS(4), SEXMAX, SEXLIM
      INTEGER VARS
      LOGICAL SEXLIM
      COMMON /BLOC38/ MOR,TOR,ANIN,NPFR
      LOGICAL MOR,TOR,ANIN
      COMMON /BLOC47/ REG(10), DREG(10,20), LREG(10)
      LOGICAL LREG
      COMMON /BLOC48/ MPS, DRIFT
      LOGICAL DRIFT
      COMMON /BLOC49/ NL, FAILED, ITER
      COMMON /BLOC59/ SLITS
      LOGICAL SLITS

      COMMON/SC/STEP,AMP,BFREQ,GAMMA,CAPPA,IPTFQ,SC1P,SC3P
      LOGICAL SC1P,SC3P
C
      NUM = 1
      IF (NV3 .LT. 1) GO TO 10
      DO 5 N = 1, NV3, 1
      LCV(N) = 0.0
      RVP(N) = .FALSE.
      R2VP(N)= .FALSE.
      SVP(N) = .FALSE.
    5 CONTINUE
   10 CONTINUE
      NV1 = 0
      IP = 0
      NM = 0
      LC = 0.0
      TOTANG = 0.0
      RCP = .FALSE.
      R2P  = .FALSE.
      R3P = .FALSE.
      S1P = .FALSE.
      RECENT = .FALSE.
      DMC = .FALSE.
      APB(1) = 0.0
      APB(2) = 0.0
      LAYL = .5
      LAYX = 0.0
      RAB1 = 0.0
      RAB2 = 0.0
      BDB = 0.0
      CAP = .FALSE.
      IR = 1
      RORC = 0
      TMK = .FALSE.
      NOR = .FALSE.
      MOR = .TRUE.
      TOR = .TRUE.
      LAY = .FALSE.
      PERIDX = .FALSE.
      PERIDY = .FALSE.
      PERIDC = .FALSE.
      RCPER = .FALSE.
      SOLSEG = .FALSE.
      SLITS = .FALSE.
      TYP1 = 0
      FOTILT = 0.0
      SM = 0.0
      AMP = 0.0
      GAMMA = 1.0
      SC1P = .FALSE.
      SEC = .FALSE.
      SOFA = .FALSE.
      LINEAR = .FALSE.
      SEXLIM = .FALSE.
      ANIN = .FALSE.
      NPFR = 0
      MPS = 1
      DRIFT = .FALSE.
      DO 20 N = 1, 4
   20 VARS(N) = 0
      DO 30 N = 1, 10
   30 LREG(N) = .FALSE.
      CALL RESET(2)
      CALL RESET(3)
      CALL RESET(4)
      ITER = 50
      RETURN
      END
      SUBROUTINE INQ
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC29/ A(21), CW, CA(21,21), SCALE(21), CASAV(21,21),
     1                PMARQ, CHSMIN, XNORM, GNORM, EPS
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      INTEGER ROW(21),COL(21)
      REAL CAT(21)
C
C     NORMALIZE ROWS AND COLUMNS
C
      N = NV1+1
      DO 15 I = 2, N
      DO 15 J = 1, N
   15 CA(I,J) = CA(I,J)*SCALE(I)*SCALE(J)
      CM0 = 1.0E-5
C
C     ADD MARQUARDT-LEVENBERG PARAMETER
C
      IF (PMARQ .EQ. 0.0) GO TO 20
      DO 18 J = 2, N
   18 CA(J,J) = CA(J,J) + PMARQ
C
C     INVERT SIGNIFICANT PORTION OF MATRIX
C
   20 DO 100 KK = 2, N
      K = KK
C
C     FIND ROW WITH LARGEST REMAINING DIFFERENCE
C
      CM  =  -1.
      DO 25 I = K, N
      CM1  =  ABS(  CA(I,1) )
      IF (CM1 .LE. CM) GO TO 25
      CM  =   CM1
      KI  =  I
   25 CONTINUE
C
C     FIND COLUMN WITH LARGEST ELEMENT IN PREVIOUSLY DETERMINED ROW
C
      CM  =  -1.
      DO 30 J = K, N, 1
      I = KI
      CM1  =  ABS(  CA(I,J) )
      IF (CM1 .LE. CM) GO TO 30
      CM  =  CM1
      KJ  =  J
   30 CONTINUE
C
C     IS FOUND ELEMENT LARGE ENOUGH
C
      IF (CM .GE. CM0) GO TO 60
C
C     IF NOT FIND LARGEST REMAINING ELEMENT IN MATRIX
C
      CM  =  -1.
      DO 40 I = K, N, 1
      DO 40 J = K, N, 1
      CM1  =   ABS(  CA(I,J)  )
      IF (CM1 .LE. CM) GO TO 40
      CM  =  CM1
      KI  =  I
      KJ  =   J
   40 CONTINUE
C
C     IS FOUND ELEMENT LARGE ENOUGH
C
      IF (CM .GE. CM0) GO TO 60
C
C     IF NOT, ZERO REMAINING MATRIX
C
   45 KP = K
      K = K - 1
      DO 50 I = KP, N
      DO 50 J = 1, N
      CA(I,J) = 0.0
      CA(J,I) = 0.0
   50 CONTINUE
      GO TO 110
C
C     SWITCH AND RENORMALIZE ROWS
C
   60 ROW(K) = KI
      COL(K) = KJ
      CK  =  1. / CA(KI,KJ)
      CA(KI,KJ)   =  -CA(KI ,KJ )
      DO 70 J = 1, N, 1
      CAT(J) = CA(KI,J)
      CA(KI,J)  =  CA(K,J)
      CA(K,J) = CK*CAT(J)
   70 CONTINUE
      CAT(KJ) = CAT(K)
      DO 80 I = 2, N, 1
      CK1  =  -CK * CA(I,KJ)
      CA(I,KJ)  =  CA(I,K)
      CA(I,K)  =  CK1
      IF (I .EQ. K) GO TO 80
      DO 75 J = 1, N, 1
      IF (J .NE. K) CA(I,J) = CA(I,J) + CK1*CAT(J)
   75 CONTINUE
   80 CONTINUE
  100 CONTINUE
C
C     RELOCATE ROWS AND COLUMNS
C
  110 IF (K .LT. 2) GO TO 150
      KI  =  COL(K)
      DO 120 J = 1, N, 1
      CK  =  CA(K,J)
      CA(K,J)  =  CA(KI,J)
      CA(KI,J)  =  CK
  120 CONTINUE
      KJ  =  ROW(K)
      DO 130 I = 2, N, 1
      CK  =  CA(I,K)
      CA(I,K)  =  CA(I,KJ)
      CA(I,KJ)  =  CK
  130 CONTINUE
      K  =  K - 1
      GO TO 110
  150 CONTINUE
C
C     CALCULATE MARQUARDT-LEVENBERG PARAMETER
C
      IF (PMARQ .NE. 0.0) GO TO 160
      DO 154 I = 2, N
      SUM = 0.0
      DO 152 J = 2, N
      SUM = SUM + CA(I,J)*CA(J,1)
  152 CONTINUE
      CAT(I) = SUM
  154 CONTINUE
      DNUM = 0.0
      DEN = 0.0
      DO 155 J = 2, N
      DNUM = DNUM + CA(J,1)*CA(J,1)
      DEN = DEN + CAT(J)*CAT(J)
  155 CONTINUE
      IF (DEN .NE. 0.0) PMARQ = SQRT(DNUM/DEN)
C
C     RENORMALIZE INVERTED MATRIX
C
  160 DO 170 I = 2, N
      DO 170 J=1,N
  170 CA(I,J) = CA(I,J)*SCALE(I)*SCALE(J)
C
C     DETERMINE STEP SIZE
C
      XNORM = 0.0
      DO 180 J = 2, N
      CAJ1 = CA(J,1)
  180 XNORM = XNORM + CAJ1*CAJ1
      XNORM = SQRT(XNORM)
      RETURN
      END
      SUBROUTINE IO
C
C     IO -- IN GREEK MYTHOLOGY, A MAIDEN LOVED BY ZEUS
C     AND CHANGED INTO A HEIFER BY JEALOUS HERA
C     OR, IN SOME TALES, BY ZEUS, TO PROTECT HER'
C     SHE WAS WATCHED BY HUNDRED-EYED ARGUS AND WAS DRIVEN TO EGYPT,
C     WHERE SHE REGAINED HER NATURAL FORM.
C
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC12/ RC(6,6), RCV(6,6,20), TC(6,6,6), RCP, RVP(20)
      LOGICAL RCP, RVP
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     A                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC25/ AP, CAP, JANET
      LOGICAL CAP
      COMMON /BLOC27/ CT(6,6), CT0(6,6), CT1(3,3), VM(6), DMC, NM
      LOGICAL DMC
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
      COMMON /BLOC38/ MOR,TOR,ANIN,NPFR
      LOGICAL MOR,TOR,ANIN
      IF (CDB .EQ. 01) GO TO 10
      IF (CDB .EQ. 02) GO TO 20
      IF (CDB .EQ. 03) GO TO 30
      IF (CDB .EQ. 04) GO TO 40
      IF (CDB .EQ. 05) GO TO 50
      IF (CDB .EQ. 06) GO TO 60
      IF (CDB .EQ. 07) GO TO 70
      IF (CDB .EQ. 08) GO TO 80
      IF (CDB .EQ. 09) GO TO 90
      IF (CDB .EQ. 10) GO TO 100
      IF (CDB .EQ. 12) GO TO 120
      IF (CDB .EQ. 24) GO TO 40
C
      IF (CDB .GE. 40 .AND. CDB .LE. 43) RETURN
      IF (CDB .GE. 47 .AND. CDB .LE. 48) RETURN
C
C     UNDEFINED OPERATIONS
C
      IF (FORMIO) WRITE(NOUT,999) CDB
  999 FORMAT('IO: UNDEFINED TYPE CODE 13.',I3,'. ;')
      RETURN
C
C     PRINT BEAM MATRIX SIGMA
C
   10 IF (.NOT.NOR) CALL QEO
      CDB = 0
      RETURN
C
C     SUPPRESS BEAM MATRIX PRINT
C
   20 NOR  =  .FALSE.
      RETURN
C
C     RESTORE NORMAL BEAM MATRIX PRINTING
C
   30 NOR  =  .TRUE.
      RETURN
C
C     PRINT TRANSFER MATRIX R OR R2
C
   40 NR = CDB / 20 + 1
      IF(RCP .OR. R2P) CALL RCO (NR)
      RETURN
C
C     ALWAYS PRINT R1
C
   50 MOR = .FALSE.
      RETURN
C
C     SUPPRESS PERMANENT R1 PRINTING
C
   60 MOR = .TRUE.
      RETURN
C
C     SUPPRESS ELEMENT PRINTING
C
   70 TOR = .TRUE.
      RETURN
C
C     RESTORE ELEMENT PRINTING
C
   80 TOR = .FALSE.
      RETURN
C
C     PRINT MISALIGMENT PARTIAL DERIVATIVE TABLE
C
   90 IF (NM .GE. 1) CALL WOE
      RETURN
C
C     OBSERVE MAGNET APERTURES
C
  100 CAP  =  .TRUE.
      RETURN
C
C     FLOOR COORDINATES
C
  120 LAY  =  .TRUE.
      RETURN
      END
      REAL FUNCTION  LIMIT(  TYPE,  N,  K)
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC21/ EN, ES, BE, APB(2), LAYL, LAYX, RAB1,RAB2,RINVL
      REAL LAYL, LAYX
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL SEC, SOFA, LINEAR
      INTEGER TYPE
C
C     LIMITS ONLY SPECIFIED FOR FOLLOWING TYPES AND DATA:
C     LIMITS STORED IN     A(K,L) L=1,6
C     L=1: DEFAULT LIMITS TO AVOID DIVERGENCES
C     L=2: TYPE CODE 1 LIMITS TO AVIOD DIMENSIONS GOING LESS THAN 1.E-3
C     L=3: TYPE 2 TO LIMIT ANGLE OF ROTATION TO 60 DEG
C     L=4: TYPES 3,4,5,18,19,21 TO AVOID NEGATIVE LENGTHS
C          TYPE 16 TO AVOID NEGATIVE MAGNET GAP
C          TYPE 23 TO AVOID NEGATIVE VOLTAGE ACROSS THE GAP
C     L=5: TYPE 12 TO LIMIT CORRELATIONS TO +-1
C     L=6: TYPE 20 TO LIMIT ANGLES TO 360 DEG + OR -
C
      REAL A(4,6)
      DATA A/-1.E10, 1.,1.E10, 1.,
     1       1.E-3, 1., 0., 0.,
     2       -1.04720,1.0,1.04720,1.0,
     3       0., 1., 0., 0.,
     4       -.99999, 1., .99999, 1.,
     5       -360., 1., 360., 1. /
C
      LIMIT = A(K,1)
      IF (TYPE .EQ. 1) LIMIT = A(K,2)
      IF (TYPE .EQ. 2 .AND. DATA(I+1).LT.1000.) LIMIT = A(K,3)/UNIT(7)
      IF (TYPE .LT. 3) RETURN
      IF (TYPE .LT. 6) GO TO 3
      IF (TYPE .EQ. 12) LIMIT = A(K,5)
      IF (TYPE .EQ. 16 .AND. .NOT. SEC) LIMIT = A(K,4)
      IF (TYPE .EQ. 16 .AND. SEC) THEN
       J = DATA(I+1)
       IF (J.EQ.12 .OR. J.EQ.13) THEN
        IF (K.EQ.2 .OR. K.EQ.4) THEN
         IF (RINVL .EQ. 0.0) THEN
          LIMIT = 0.0
         ELSE
          LIMIT = 1.0
         ENDIF
        ENDIF
        IF (K.EQ.1) LIMIT = - ABS(RINVL)
        IF (K.EQ.3) LIMIT =   ABS(RINVL)
       ENDIF
      ENDIF
      IF (TYPE .EQ. 20) LIMIT = A(K,6)
      IF (TYPE .NE. 18 .AND. TYPE .NE. 19 .AND.
     X    TYPE .NE. 21 .AND. TYPE .NE. 23) RETURN
    3 IF (N .NE. 1) RETURN
      LIMIT = A(K,4)
      RETURN
      END
      SUBROUTINE MADD(A,B,N)
      DIMENSION A(1), B(1)
      DO 1 I = 1, N
    1 A(I) = A(I) + B(I)
      RETURN
      END
      SUBROUTINE MALIGN
      COMMON /BLOC4/  LC, TOTANG, LCV(20)
      REAL LC, LCV
      COMMON /BLOC11/ R(6,6), RV(6,6), T(6,6,6), TV(6,6,6)
      COMMON /BLOC12/ RC(6,6), RCV(6,6,20), TC(6,6,6), RCP, RVP(20)
      LOGICAL RCP, RVP
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     1 R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC14/ RC3(6,6), TC3(6,6,6), R3P
      LOGICAL R3P
      COMMON /BLOC15/ RS(6,6), RT(6,6), TS(6,6,6), TT(6,6,6)
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     1 SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC17/ COD(6)
      COMMON /BLOC18/ SIT(6,6), CEN(6), RECENT
      LOGICAL RECENT
      COMMON /BLOC19/ TR(6,6,6)
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC27/ CT(6,6), CT0(6,6), CT1(3,3), VM(6), DMC, NM
      LOGICAL DMC
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL SEC, SOFA, LINEAR
      COMMON /BLOC44/ BEGM(3), BEGMS(20), ENDMS(20)
      COMMON /BLOC45/ SIOL(3,6,6), COLD(3,6), SPO(3)
      LOGICAL SPO
      COMMON /BLOC46/ XM(6), XMB(6), DXM(6), GXXM(6,6)
      COMMON /BLOC63/ Z216(216), U36(36)
      COMMON /BLOC77/ COM(6,6,20), SIM(36,6,20)
      DIMENSION COMJM(36,20), GT(6,6,6)
      EQUIVALENCE (COM,COMJM), (TR,GT)

C
      IF (.NOT. RECENT) CALL BEAM
      IF (TMK) GO TO 350
C
C     PIVOT POINT AT ENTRANCE FACE
C
      CALL UCOPY(Z216,CT0,36)
      CT0(5,5)  =  1.
      CT0(3,3)  =  1.
      CT0(2,4)  =  1.
      CT0(1,1)  =  1.
      CT0(4,2)  = -1.
      GO TO 360
C
C     PIVOT POINT AS INDICATED
C
  350 TMK = .FALSE.
      CALL UCOPY(CT,CT0,36)
C
C     EFFECT OF MISALIGNMENT ON CENTROID DISPLACEMENT
C
  360 CALL TFL
      IF (R2P) CALL UPDAT2
      CALL RCALC(IR-1)
C
C     BILINEAR TERMS
C
      CALL UCOPY(Z216,GT,216)
      DO 430 J = 1, 6
      GT(J,2,5) = RS(J,1)
      GT(J,1,6) = - RS(J,3)
      GT(J,2,6) = - RS(J,4)
      GT(J,3,6) = RS(J,1)
      GT(J,4,6) = RS(J,2)
      GT(J,4,5) = RS(J,3)
  430 CONTINUE
      DO 460 J = 1, 6
      DO 440 K = 1, 6
      GT(1,J,K) = GT(1,J,K) - CT(5,K)*RS(2,J)
      GT(3,J,K) = GT(3,J,K) - CT(5,K)*RS(4,J)
  440 CONTINUE
      DO 450 K = 1, 3
      K2 = 2*K
      GT(1,J,K2) = GT(1,J,K2) - O(IR,3,K)*RS(3,J)
      GT(2,J,K2) = GT(2,J,K2) - O(IR,3,K)*RS(4,J)
      GT(3,J,K2) = GT(3,J,K2) + O(IR,3,K)*RS(1,J)
      GT(4,J,K2) = GT(4,J,K2) + O(IR,3,K)*RS(2,J)
  450 CONTINUE
  460 CONTINUE
C
C     IMAGE OF DISPLACED CENTROID AT ENTRANCE FACE
C
      DO 484 J = 1, 6
      DO 484 K = 1, 6
      S = 0.0
      DO 480 N = 1, 6
      S = S + RS(J,N)*CT0(N,K)
  480 CONTINUE
      CT(J,K) = CT(J,K) - S
  484 CONTINUE
C
C     UNCERTAINTY IN POSITION SHOWN IN BEAM MATRIX
C
      IF (TYT/100 .NE. 0) GO TO 600
      IF (MOD(TYT/10,10) .NE. 0) GO TO 550
      DO 540 J = 1, 6
      DO 540 K = 1, J
      S = 0.0
      DO 510 N = 1, 6
      S = S + CT(J,N)*CT(K,N)*VM(N)**2
  510 CONTINUE
      IF (.NOT. SPO(IR)) GO TO 520
      DO 515 L = 1, 6
      DO 515 M = 1, 6
      S = S + (CT(J,M)*GT(K,L,M) + CT(K,M)*GT(J,L,M))*COLD(IR,L)*
     A VM(M)**2
  515 CONTINUE
  520 DO 525 L1 = 1, 6
      DO 525 L2 = 1, 6
      DO 525 M = 1, 6
      S = S + GT(J,L1,M)*GT(K,L2,M)*SIOL(IR,L1,L2)*VM(M)**2
  525 CONTINUE
  530 SI(J,K) = SI(J,K) + S
      SI(K,J) = SI(J,K)
  540 CONTINUE
      RECENT = .FALSE.
      RETURN
C
C     UNCERTAINTY IN POSITION SHOWN IN MISALIGNMENT TABLE
C
  550 NM = NM + 1
      BEGMS(NM)=BEGM(IR)
      ENDMS(NM)=LC
      IF (S1P) GO TO 556
      CALL UCOPY(Z216,COMJM(1,NM),36)
      GO TO 560
  556 DO 558 J = 1, 6
      DO 558 M = 1, 6
      COM(J,M,NM) = CEN(J)
  558 CONTINUE
  560 DO 590 J = 1, 6
      DO 590 K = 1, J
      JPK = 6*J + K - 6
      KPJ = 6*K + J - 6
      DO 590 M = 1, 6
      S = CT(J,M)*CT(K,M)*VM(M)**2
      IF (.NOT. SPO(IR)) GO TO 570
      DO 565 L = 1, 6
      S = S + (CT(J,M)*GT(K,L,M) + CT(K,M)*GT(J,L,M))*
     A COLD(IR,L)*VM(M)**2
  565 CONTINUE
  570 DO 575 L1 = 1, 6
      DO 575 L2 = 1, 6
      S = S + GT(J,L1,M)*GT(K,L2,M)*SIOL(IR,L1,L2)*VM(M)**2
  575 CONTINUE
  580 SIM(JPK,M,NM) = SIT(J,K) + S
      SIM(KPJ,M,NM) = SIM(JPK,M,NM)
  590 CONTINUE
      GO TO 700
C
C     KNOWN DISPLACEMENT SHOWN IN BEAM MATRIX
C
  600 IF (MOD(TYT/10,10) .NE. 0) GO TO  650
      DO 605 J = 1, 6
      S = 0.0
      DO 604 K = 1, 6
      S = S + CT(J,K)*VM(K)
  604 CONTINUE
      XM(J) = S
  605 CONTINUE
      DO 609 J = 1, 6
      DO 609 K = 1, 6
      S = 0.0
      DO 608 M = 1, 6
      S = S + GT(J,K,M)*VM(M)
  608 CONTINUE
      RT(J,K) = S
  609 CONTINUE
      IF (.NOT. SPO(IR)) GO TO 615
      DO 614 J = 1, 6
      S = 0.0
      DO 613 K = 1, 6
      S = S + RT(J,K)*COLD(IR,K)
  613 CONTINUE
      XMB(J) = S
  614 CONTINUE
C
  615 DO 616 J = 1, 6
      COD(J) = XM(J)
  616 CONTINUE
      IF (.NOT. SPO(IR)) GO TO 620
      DO 617 J = 1, 6
      COD(J) = COD(J) + XMB(J)
  617 CONTINUE
  620 DO 621 J = 1, 6
      CO(J) = CO(J) + COD(J)
  621 CONTINUE
C
      IF (.NOT. S1P) GO TO 630
      DO 625 J = 1, 6
      DXM(J) = CEN(J)
      IF (.NOT. SPO(IR)) GO TO 625
      S = 0.0
      DO 622 K = 1, 6
      S = S + RS(J,K)*COLD(IR,K)
  622 CONTINUE
      DXM(J) = DXM(J) - S
  625 CONTINUE
C
  630 DO 632 J = 1, 6
      DO 632 K = 1, 6
      S = 0.0
      DO 631 L = 1, 6
      S = S + RT(J,L)*SIOL(IR,L,K)
  631 CONTINUE
      GXXM(J,K) = S
  632 CONTINUE
      DO 648 J = 1, 6
      DO 648 K = 1, J
      S = XM(J)*XM(K)
      DO 641 L = 1, 6
      S = S + GXXM(J,L)*RS(K,L) + GXXM(K,L)*RS(J,L)
      S = S + GXXM(J,L)*RT(K,L)
  641 CONTINUE
      IF (.NOT. S1P) GO TO 646
      S = S + XM(J)*CEN(K) + XM(K)*CEN(J)
      IF (.NOT. SPO(IR)) GO TO 646
      S = S + XM(J)*XMB(K) + XM(K)*XMB(J)
      S = S + DXM(J)*XMB(K) + DXM(K)*XMB(J)
  646 SI(J,K) = SI(J,K) + S
      SI(K,J) = SI(J,K)
  648 CONTINUE
      S1P = .TRUE.
      SOFA = .TRUE.
      RECENT = .FALSE.
      RETURN
C
C     KNOWN DISPLACEMENT SHOWN IN MISALIGNMENT TABLE
C
  650 NM = NM + 1
      BEGMS(NM) = BEGM(IR)
      ENDMS(NM) = LC
      DO 699 M = 1, 6
      DO 655 J = 1, 6
      XM(J) = CT(J,M)*VM(M)
  655 CONTINUE
      DO 659 J = 1, 6
      DO 659 K = 1, 6
      RT(J,K) = GT(J,K,M)*VM(M)
  659 CONTINUE
      IF (.NOT. SPO(IR)) GO TO 665
      DO 664 J = 1, 6
      S = 0.0
      DO 660 K = 1, 6
      S = S + RT(J,K)*COLD(IR,K)
  660 CONTINUE
      XMB(J) = S
  664 CONTINUE
C
  665 DO 666 J = 1, 6
      COD(J) = XM(J)
  666 CONTINUE
      IF (.NOT. SPO(IR)) GO TO 668
      DO 667 J = 1, 6
      COD(J) = COD(J) + XMB(J)
  667 CONTINUE
C
  668 IF (S1P) GO TO 675
      DO 674 J = 1, 6
      COM(J,M,NM) = COD(J)
  674 CONTINUE
      GO TO 680
  675 DO 676 J = 1, 6
      COM(J,M,NM) = CO(J) + COD(J)
  676 CONTINUE
C
  680 DO 682 J = 1, 6
      DO 682 K = 1, 6
      S = 0.0
      DO 681 L = 1, 6
      S = S + RT(J,L)*SIOL(IR,L,K)
  681 CONTINUE
      GXXM(J,K) = S
  682 CONTINUE
      DO 698 J = 1, 6
      DO 698 K = 1, J
      JPK = 6*J + K - 6
      KPJ = 6*K + J - 6
      S = XM(J)*XM(K)
      DO 691 L = 1, 6
      S = S + GXXM(J,L)*RS(K,L) + RS(J,L)*GXXM(K,L)
      S = S + GXXM(J,L)*RT(K,L)
  691 CONTINUE
      IF (.NOT. S1P) GO TO 696
      S = S + XM(J)*CEN(K) + CEN(J)*XM(K)
      IF (.NOT. SPO(IR)) GO TO 696
      S = S + XM(J)*XMB(K) + XMB(J)*XM(K)
  696 SIM(JPK,M,NM) = SI(J,K) + S
      SIM(KPJ,M,NM) = SIM(JPK,M,NM)
  698 CONTINUE
  699 CONTINUE
C
  700 DMC = .FALSE.
      IR = 1
      RETURN
      END
      SUBROUTINE MNEG(A,N)
      DIMENSION A(1)
      DO 1 I = 1, N
    1 A(I) = - A(I)
      RETURN
      END
      SUBROUTINE MSYM(A)
      DIMENSION A(36)
      A( 7) = A( 2)
      A(13) = A( 3)
      A(14) = A( 9)
      A(19) = A( 4)
      A(20) = A(10)
      A(21) = A(16)
      A(25) = A( 5)
      A(26) = A(11)
      A(27) = A(17)
      A(28) = A(23)
      A(31) = A( 6)
      A(32) = A(12)
      A(33) = A(18)
      A(34) = A(24)
      A(35) = A(30)
      RETURN
      END
      SUBROUTINE MSMPLY(RC,TC,RA,TA,RB,TB)
C
C     COMPUTES RESULT FROM R AND T MATRICES
C     USING PRELIMINARY CALCULATION
C
      COMMON /BLOC19/ TR(6,6,6)
      DIMENSION RA(6,6), RB(6,6), RC(6,6)
      DIMENSION TA(6,6,6), TB(6,6,6), TC(6,6,6)
      CALL CAB(RC,RA,RB)
      DO 130 I1 = 1, 5
      DO 130 I2 = 1, 6
      DO 130 I3 = I2, 6
      GHOST = 0.0
      DO 110 I4 = 1, 5
      GHOST = GHOST + RA(I1,I4)*TB(I4,I2,I3) + TR(I1,I2,I4)*RB(I4,I3)
  110 CONTINUE
      GHOST = GHOST + TR(I1,I2,6)*RB(6,I3)
      TC(I1,I2,I3) = GHOST
  130 TC(I1,I3,I2) = GHOST
      RETURN
      END
      SUBROUTINE MTMPLF(RC,TC,RA,TA,RB,TB)
C
C     COMPUTES RESULT FROM R AND T MATRICES
C
      COMMON /BLOC3/ TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC48/ MPS, DRIFT
      LOGICAL DRIFT
      DIMENSION RA(6,6), RB(6,6), RC(6,6)
      DIMENSION TA(36,6), TB(6,6,6), TC(6,6,6)
      DIMENSION TR(6,6,6), TRL(36,6)
      EQUIVALENCE(TR,TRL)
C
      IF (MPS .EQ. 1 .AND. DRIFT) GO TO 200
C     -------------------------------
      ENTRY MTMPLY(RC,TC,RA,TA,RB,TB)
C     -------------------------------
      CALL CAB(RC,RA,RB)
      DO 60 I3 = 1, 6
   60 CALL CAB(TRL(1,I3),TA(1,I3),RB)
      DO 130 I1 = 1, 5
      DO 130 I2 = 1, 6
      DO 130 I3 = I2, 6
      GHOST = 0.0
      DO 110 I4 = 1, 5
      GHOST = GHOST + RA(I1,I4)*TB(I4,I2,I3) + TR(I1,I2,I4)*RB(I4,I3)
  110 CONTINUE
      GHOST = GHOST + TR(I1,I2,6)*RB(6,I3)
      TC(I1,I2,I3) = GHOST
  130 TC(I1,I3,I2) = GHOST
      RETURN
C
C     MATRIX MULTIPLICATIONS IF RA AND TA REPRESENT A DRIFT
C     AND RB HAS MIDPLANE SYMMETRY
C
  200 CALL CABF(RC,RA,RB)
C
      CALL UCOPY(TB,TC,216)
      TC(1,1,1) = TB(1,1,1) + L * TB(2,1,1)
      AUX       = TB(1,1,2) + L * TB(2,1,2)
      TC(1,1,2) = AUX
      TC(1,2,1) = AUX
      AUX       = TB(1,1,3) + L * TB(2,1,3)
      TC(1,1,3) = AUX
      TC(1,3,1) = AUX
      AUX       = TB(1,1,4) + L * TB(2,1,4)
      TC(1,1,4) = AUX
      TC(1,4,1) = AUX
      AUX       = TB(1,1,5) + L * TB(2,1,5)
      TC(1,1,5) = AUX
      TC(1,5,1) = AUX
      AUX       = TB(1,1,6) + L * TB(2,1,6)
      TC(1,1,6) = AUX
      TC(1,6,1) = AUX
C
      TC(1,2,2) = TB(1,2,2) + L * TB(2,2,2)
      AUX       = TB(1,2,3) + L * TB(2,2,3)
      TC(1,2,3) = AUX
      TC(1,3,2) = AUX
      AUX       = TB(1,2,4) + L * TB(2,2,4)
      TC(1,2,4) = AUX
      TC(1,4,2) = AUX
      AUX       = TB(1,2,5) + L * TB(2,2,5)
      TC(1,2,5) = AUX
      TC(1,5,2) = AUX
      AUX       = TB(1,2,6) + L * TB(2,2,6)
      TC(1,2,6) = AUX
      TC(1,6,2) = AUX
C
      TC(1,3,3) = TB(1,3,3) + L * TB(2,3,3)
      AUX       = TB(1,3,4) + L * TB(2,3,4)
      TC(1,3,4) = AUX
      TC(1,4,3) = AUX
      AUX       = TB(1,3,5) + L * TB(2,3,5)
      TC(1,3,5) = AUX
      TC(1,5,3) = AUX
      AUX       = TB(1,3,6) + L * TB(2,3,6)
      TC(1,3,6) = AUX
      TC(1,6,3) = AUX
C
      TC(1,4,4) = TB(1,4,4) + L * TB(2,4,4)
      AUX       = TB(1,4,5) + L * TB(2,4,5)
      TC(1,4,5) = AUX
      TC(1,5,4) = AUX
      AUX       = TB(1,4,6) + L * TB(2,4,6)
      TC(1,4,6) = AUX
      TC(1,6,4) = AUX
C
      TC(1,5,5) = TB(1,5,5) + L * TB(2,5,5)
      AUX       = TB(1,5,6) + L * TB(2,5,6)
      TC(1,5,6) = AUX
      TC(1,6,5) = AUX
C
      TC(1,6,6) = TB(1,6,6) + L * TB(2,6,6)
C
      TC(3,1,1) = TB(3,1,1) + L * TB(4,1,1)
      AUX       = TB(3,1,2) + L * TB(4,1,2)
      TC(3,1,2) = AUX
      TC(3,2,1) = AUX
      AUX       = TB(3,1,3) + L * TB(4,1,3)
      TC(3,1,3) = AUX
      TC(3,3,1) = AUX
      AUX       = TB(3,1,4) + L * TB(4,1,4)
      TC(3,1,4) = AUX
      TC(3,4,1) = AUX
      AUX       = TB(3,1,5) + L * TB(4,1,5)
      TC(3,1,5) = AUX
      TC(3,5,1) = AUX
      AUX       = TB(3,1,6) + L * TB(4,1,6)
      TC(3,1,6) = AUX
      TC(3,6,1) = AUX
C
      TC(3,2,2) = TB(3,2,2) + L * TB(4,2,2)
      AUX       = TB(3,2,3) + L * TB(4,2,3)
      TC(3,2,3) = AUX
      TC(3,3,2) = AUX
      AUX       = TB(3,2,4) + L * TB(4,2,4)
      TC(3,2,4) = AUX
      TC(3,4,2) = AUX
      AUX       = TB(3,2,5) + L * TB(4,2,5)
      TC(3,2,5) = AUX
      TC(3,5,2) = AUX
      AUX       = TB(3,2,6) + L * TB(4,2,6)
      TC(3,2,6) = AUX
      TC(3,6,2) = AUX
C
      TC(3,3,3) = TB(3,3,3) + L * TB(4,3,3)
      AUX       = TB(3,3,4) + L * TB(4,3,4)
      TC(3,3,4) = AUX
      TC(3,4,3) = AUX
      AUX       = TB(3,3,5) + L * TB(4,3,5)
      TC(3,3,5) = AUX
      TC(3,5,3) = AUX
      AUX       = TB(3,3,6) + L * TB(4,3,6)
      TC(3,3,6) = AUX
      TC(3,6,3) = AUX
C
      TC(3,4,4) = TB(3,4,4) + L * TB(4,4,4)
      AUX       = TB(3,4,5) + L * TB(4,4,5)
      TC(3,4,5) = AUX
      TC(3,5,4) = AUX
      AUX       = TB(3,4,6) + L * TB(4,4,6)
      TC(3,4,6) = AUX
      TC(3,6,4) = AUX
C
      TC(3,5,5) = TB(3,5,5) + L * TB(4,5,5)
      AUX       = TB(3,5,6) + L * TB(4,5,6)
      TC(3,5,6) = AUX
      TC(3,6,5) = AUX
C
      TC(3,6,6) = TB(3,6,6) + L * TB(4,6,6)
C
      X = RA(5,6)
      FACT = RB(2,1) * TA(11,2)
      TC(5,1,1) = TB(5,1,1) + X * TB(6,1,1)
     1          + RB(2,1) * FACT
      AUX       = TB(5,1,2) + X * TB(6,1,2)
     1          + RB(2,2) * FACT
      TC(5,1,2) = AUX
      TC(5,2,1) = AUX
      AUX       = TB(5,1,3) + X * TB(6,1,3)
      TC(5,1,3) = AUX
      TC(5,3,1) = AUX
      AUX       = TB(5,1,4) + X * TB(6,1,4)
      TC(5,1,4) = AUX
      TC(5,4,1) = AUX
      AUX       = TB(5,1,5) + X * TB(6,1,5)
      TC(5,1,5) = AUX
      TC(5,5,1) = AUX
      AUX       = TB(5,1,6) + X * TB(6,1,6)
     1          + RB(2,6) * FACT
     1          + RB(6,6) * RB(5,1) * TA(29,6)
      TC(5,1,6) = AUX
      TC(5,6,1) = AUX
C
      FACT = RB(2,2) * TA(11,2)
      TC(5,2,2) = TB(5,2,2) + X * TB(6,2,2)
     1          + RB(2,2) * FACT
      AUX       = TB(5,2,3) + X * TB(6,2,3)
      TC(5,2,3) = AUX
      TC(5,3,2) = AUX
      AUX       = TB(5,2,4) + X * TB(6,2,4)
      TC(5,2,4) = AUX
      TC(5,4,2) = AUX
      AUX       = TB(5,2,5) + X * TB(6,2,5)
      TC(5,2,5) = AUX
      TC(5,5,2) = AUX
      AUX       = TB(5,2,6) + X * TB(6,2,6)
     1          + RB(2,6) * FACT
     1          + RB(6,6) * RB(5,2) * TA(29,6)
      TC(5,2,6) = AUX
      TC(5,6,2) = AUX
C
      FACT = RB(4,3) * TA(23,4)
      TC(5,3,3) = TB(5,3,3) + X * TB(6,3,3)
     1          + RB(4,3) * FACT
      AUX       = TB(5,3,4) + X * TB(6,3,4)
     1          + RB(4,4) * FACT
      TC(5,3,4) = AUX
      TC(5,4,3) = AUX
      AUX       = TB(5,3,5) + X * TB(6,3,5)
      TC(5,3,5) = AUX
      TC(5,5,3) = AUX
      AUX       = TB(5,3,6) + X * TB(6,3,6)
      TC(5,3,6) = AUX
      TC(5,6,3) = AUX
C
      FACT = RB(4,4) * TA(23,4)
      TC(5,4,4) = TB(5,4,4) + X * TB(6,4,4)
     1          + RB(4,4) * FACT
      AUX       = TB(5,4,5) + X * TB(6,4,5)
      TC(5,4,5) = AUX
      TC(5,5,4) = AUX
      AUX       = TB(5,4,6) + X * TB(6,4,6)
      TC(5,4,6) = AUX
      TC(5,6,4) = AUX
C
      TC(5,5,5) = TB(5,5,5) + X * TB(6,5,5)
      AUX       = TB(5,5,6) + X * TB(6,5,6)
     1          + RB(6,6) * RB(5,5) * TA(29,6)
      TC(5,5,6) = AUX
      TC(5,6,5) = AUX
C
      TC(5,6,6) = TB(5,6,6) + X * TB(6,6,6)
     1          + RB(2,6) * RB(2,6) * TA(11,2)
     1          + RB(5,6) * RB(6,6) *(TA(35,5) + TA(29,6))
     1          + RB(6,6) * RB(6,6) * TA(35,6)
C
      RETURN
      END
      SUBROUTINE MXMPLY(RC,TC,RA,TA,RB,TB)
C
C     COMPUTES RESULT FROM R AND T MATRICES
C     USING PRELIMINARY CALCULATION
C     RB AND TB ARE DERIVATIVES
C
      COMMON /BLOC19/ TR(6,6,6)
      DIMENSION RA(6,6), RB(6,6), RC(6,6)
      DIMENSION TA(6,6,6), TB(6,6,6), TC(6,6,6)
      CALL CAB(RC,RA,RB)
      DO 130 I1 = 1, 5
      DO 130 I2 = 1, 6
      DO 130 I3 = I2, 6
      GHOST = 0.0
      DO 110 I4 = 1, 5
      GHOST = GHOST + RA(I1,I4)*TB(I4,I2,I3)
     A + TR(I1,I2,I4)*RB(I4,I3) + TR(I1,I3,I4)*RB(I4,I2)
  110 CONTINUE
      GHOST = GHOST + TR(I1,I2,6)*RB(6,I3) + TR(I1,I3,6)*RB(6,I2)
      TC(I1,I2,I3) = GHOST
  130 TC(I1,I3,I2) = GHOST
      RETURN
      END

      INTEGER FUNCTION NIV(TYPE)
C
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      COMMON /BLOC70/ RANOPT, NITER, ALOW(20), AHIGH(20)
      LOGICAL RANOPT
C
      INTEGER NV1(25), NV2(25), TYPE
      DATA NV1 /6,2,1,3,3,0,6,6,0,0,0,15,0,6,0,2,0,2,2,1,2,0,1,0,0/
      DATA NV2 /6,1,1,3,3,0,0,0,0,0,0,0 ,0,6,0,2,0,2,2,1,2,0,0,0,0/
C
      IF (TYPE .EQ. 50) THEN
        NIV = 0
        RETURN
      ENDIF
      IF (.NOT.SEC) NIV = NV1(TYPE)
      IF      (SEC) NIV = NV2(TYPE)
      IF (RANOPT .AND. TYPE.EQ.22) NIV = 2
      IF (RANOPT .AND. TYPE.EQ.11) NIV = 2
      RETURN
      END

      INTEGER FUNCTION NV(TYPE)
C
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      COMMON /BLOC70/ RANOPT, NITER, ALOW(20), AHIGH(20)
      LOGICAL RANOPT
C
      INTEGER NV1(25), NV2(25), TYPE
      DATA NV1 /6,1,1,3,3,0,6,6,0,0,0,15,0,6,0,2,0,0,2,1,2,0,1,0,0/
      DATA NV2 /0,2,1,4,3,0,0,0,0,0,0,0 ,0,6,0,0,0,2,2,1,2,0,0,0,0/
C
      IF (TYPE .EQ. 50) THEN
        NV = 0
        RETURN
      ENDIF
      IF (.NOT.SEC) NV = NV1(TYPE)
      IF      (SEC) NV = NV2(TYPE)
      IF (RANOPT .AND. TYPE.EQ.22) NV = 2
      IF (RANOPT .AND. TYPE.EQ.11) NV = 2
      RETURN
      END

      SUBROUTINE OUTFIT
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC3/ TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC4/ LC, TOTANG, LCV(20)
      REAL LC, LCV
      COMMON /BLOC5/ VSTOR(20), TIE(NND)
      INTEGER VSTOR, TIE
      COMMON /BLOC5A/ LABEL(NNL), LABM(20)
      CHARACTER       LABEL*4, LABM*4
      COMMON /BLOC6/ PERIDX, PERIDY, PERIDC, RCPER, EMITX, EMITY
      LOGICAL PERIDX, PERIDY, PERIDC, RCPER
      COMMON /BLOC11/ R(6,6), RV(6,6), T(6,6,6), TV(6,6,6)
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC23/ H, AL, NB, BDB, CHARGE, LILENS, EQUAD, EBEND
      REAL NB
      LOGICAL LILENS, EQUAD, EBEND
      COMMON /BLOC24/ B, KQ2, KVK, K2H, K2V, CS, SN, CM1N, J
      REAL KQ2, KVK, K2H, K2V
      COMMON /BLOC25/ AP, CAP, JANET
      LOGICAL CAP
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC33/ FOTILT, SM
      COMMON /BLOC38/ MOR,TOR,ANIN,NPFR
      LOGICAL MOR,TOR,ANIN
      COMMON /BLOC41/ LW, FLUSH, INDIC, NTYPE, LENGTH,
     A                NWORD, NVARY, DATUM(30), VARY(30)
      INTEGER VARY
      LOGICAL FLUSH
      COMMON /BLO41A/ IMAGE(80), LABLE
      CHARACTER       IMAGE*1, LABLE*4
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
      COMMON /BLOC47/ REG(10), DREG(10,20), LREG(10)
      LOGICAL LREG
      COMMON /BLOC49/ NL, FAILED, ITER
      LOGICAL FAILED
      COMMON /BLO49A/ LABS(20)
      CHARACTER       LABS*4
      COMMON /BLOC50/ XI1, XI2, XI3
      COMMON /BLOC58/ FIELD
      COMMON /BLOC59/ SLITS
      LOGICAL SLITS
      COMMON /BLOC60/ ALONG, CENUN(6), SIUN(6), R12, R34, R56, R13, R24,
     A                RMTX(13), SRMTX(105), PLOT, TOTROT
      LOGICAL PLOT
      COMMON/SC/STEP,AMP,BFREQ,GAMMA,CAPPA,IPTFQ,SC1P,SC3P
      LOGICAL SC1P,SC3P
C
      LOGICAL PRINT, VARIED
      CHARACTER*4 NAM(78), CSYM(5)
      CHARACTER*1 ICHAR(12), IC1, IC2, IC3
      DATA NAM / '*BET', 'A*  ', '*DFI', 'ELD*', '*P M', 'ASS*', '*PAR',
     X   'AM* ', '* G/', '2 * ', '*LEN', 'GTH*', '* K1', ' *  ', '* K2',
     X   ' *  ', '*PAR', 'AM* ', '*PAR', 'AM* ', '*PAR', 'AM* ', '* 1/',
     X   'R1 *', '* 1/', 'R2 *', '*PAR', 'AM* ', '*FOT', 'ILT*', '*XBE',
     X   'GIN*', '*YBE', 'GIN*', '*ZBE', 'GIN*', '*THE', 'TA0*',
     X   '*PHI', '0 * ', '*1/R', 'LIM*', '*ITR', 'LIM*', '    ', '    ',
     X   '    ', '    ', '* I1', ' *  ', '* I2', ' *  ', '* I3', ' *  ',
     X   '    ', '    ', '    ', '    ', '    ', '    ', '*RAN', 'OPT*',
     X   '*NOR', 'MAL*', '    ', '    ', '    ', '    ', '    ', '    ',
     X   '    ', '    ', '    ', '    ', '    ', '    ', '    ', '    '/
      DATA CSYM /'ADD','SUB','MULT','DIV','SQRT'/
C
      CALL INITZE
      TOTROT = 0.
      CDB = 0
      PLOT = .FALSE.
      IF (IMAGE(1).EQ.'*' .AND. IMAGE(2).EQ.'P' .AND.
     *    IMAGE(3).EQ.'L' .AND. IMAGE(4).EQ.'O' .AND.
     *    IMAGE(5).EQ.'T' .AND. IMAGE(6).EQ.'*') THEN
      PLOT = .TRUE.
      TOR = .FALSE.
      NOR = .TRUE.
      MOR = .FALSE.
      END IF
      IF(TOR) GO TO 5
      IF(FORMIO) WRITE (NOUT, 9000) IMAGE
 9000 FORMAT('1',80A1/)
    5 CONTINUE
      IF(NEL .LE. 0) GO TO 5300
   10 I = ISTOR(NUM)
      TYPE = DATA(I)
      IF(TYPE .EQ. 9) CALL REPEAT
      IF(TYPE .LE. 0) GO TO 5002
   20 CALL ELICIT
      IF(.NOT.(PERIDX.OR.PERIDY)) GO TO 21
      IF(.NOT.RCPER) GO TO 5002
C
   21 DO 30 J = 1, 12
   30 ICHAR(J) = BLANK
      VARIED = .FALSE.
      KV = MIN(6,NIV(TYPE))
      IF(KV .EQ. 0) GO TO 60
      LLV = 0
      DO 50 JV = 1, KV
      K = I + JV
      ISIG = TIE(K)
      IVARY = IABS(ISIG)
      IF(ISIG .GE. 0) GO TO 40
      LLV = LLV + 1
      ICHAR(LLV) = MINUS
   40 LLV = LLV + 1
      IF(IVARY .EQ. 0) GO TO 50
      VARIED = .TRUE.
      IVARY = VSTOR(IVARY)
   50 ICHAR(LLV) = TABLE(IVARY+1)
C
   60 PRINT = FORMIO .AND. (.NOT. TOR .OR. VARIED)
      IF (TYPE .EQ. 50) GO TO 5000
      GO TO (100,200,300,400,500,600,700,800,5002,1000,1100,1200
     A      ,1300,1400,5002,1600,1700,1800,1900,2000,2100,2200,2300
     A      ,2400,2500), TYPE
C
C     1. -- BEAM
C
  100 WORK1 = RI / UNIT(11)
      GAMMA = SQRT (1.0 + (RI / SM)**2 )
      IF(.NOT.PRINT) GO TO 5001
      IF(ISTOR(NUM+1) .GT. I + 8) GO TO 130
  101 IF (SM .GT. 0.0) THEN
      WORK2 = RI * WORK1 / (SM * (1. + GAMMA))
      WRITE (NOUT, 9303) TYPE, ICHAR, LABEL(NUM), WORK1, XDIME(11),
     X                   WORK2, XDIME(11)
 9303 FORMAT(' *BEAM*',I11,'.',12A1,' "',A4,'"',2(F13.5,1X,A4))
      GO TO 180
      ENDIF
      WRITE (NOUT, 9001) TYPE, ICHAR, LABEL(NUM), WORK1, XDIME(11)
 9001 FORMAT(' *BEAM*',I11,'.',12A1,' "',A4,'"',F13.5,1X,A4)
      GO TO 180
  130 WRITE (NOUT, 9002) TYPE, ICHAR, LABEL(NUM), WORK1, XDIME(11)
 9002 FORMAT(' *ADD TO BEAM*',I4,'.',12A1,' "',A4,'"',F13.5,1X,A4)
  180 GO TO 5001
C
C     2. -- POLE FACE ROTATION
C
  200 IF(.NOT.PRINT) GO TO 5001
      IF (DATA(I+1) .GE. 1000.) THEN
       WRITE (NOUT, 9103) TYPE, ICHAR, LABEL(NUM), XI1, XI2, XI3
 9103  FORMAT(' *FRINGE*',I9,'.',12A1,' "',A4,'"',3F13.5)
      ELSE
       WRITE (NOUT, 9003) TYPE, ICHAR, LABEL(NUM), DATA(I+1), XDIME(7)
 9003  FORMAT(' *ROTAT*',I10,'.',12A1,' "',A4,'"',F13.5,1X,A4)
      ENDIF
      GO TO 5001
C
C     3. -- DRIFT SPACE
C
  300 IF(.NOT.PRINT) GO TO 5001
      WRITE (NOUT, 9004) TYPE, ICHAR, LABEL(NUM), DATA(I+1), XDIME(8)
 9004 FORMAT(' *DRIFT*',I10,'.',12A1,' "',A4,'"',F13.5,1X,A4)
      GO TO 5001
C
C     4. -- BENDING MAGNET
C
  400 CONTINUE
      IF (EBEND) GO TO 401
      WORK1 = AL / UNIT(7)
      BNORM = B/UNIT(9)
      IF(.NOT.PRINT) GO TO 5001
      WRITE (NOUT, 9005) TYPE, ICHAR, LABEL(NUM), DATA(I+1), XDIME(8),
     A                   BNORM, XDIME(9), NB, WORK1, XDIME(7)
 9005 FORMAT(' *BEND*',I11,'.',12A1,' "',A4,'"',2(F13.5,1X,A4),F13.5,
     A       6X,'(',F11.5,1X,A4,' )')
      GO TO 5001
  401 CONTINUE
      IF(.NOT.PRINT) GO TO 5001
      WRITE (NOUT, 9055) TYPE, ICHAR, LABEL(NUM), DATA(I+1), XDIME(8),
     A                   DATA(I+2), XDIME(7), NB, FIELD
 9055 FORMAT(' *EPRI*',I11,'.',12A1,' "',A4,'"',2(F13.5,1X,A4),F13.4,
     A                   F13.5,' kV/cm')
      GO TO 5001
C
C     5. -- QUADRUPOLE
C
  500 IF(.NOT.PRINT) GO TO 5001
      IF (R(2,1) .NE. 0.0) GO TO 520
      WORK1 = 0.0
      GO TO 530
  520 WORK1 = - 1.0/(R(2,1)*UNIT(8))
      IF(ABS(WORK1).GT.9999.9) WORK1=0.0
  530 CONTINUE
      IF (EQUAD) THEN
      WRITE (NOUT, 9066) TYPE, ICHAR, LABEL(NUM), DATA(I+1), XDIME(8),
     A     DATA(I+2), DATA(I+3), XDIME(1), WORK1, XDIME(8)
 9066 FORMAT(' *EQUAD*',I11,'.',12A1,' "',A4,'"',F13.5,1X,A4,
     A       F13.5,' kV/cm',F13.5,1X,A4,' (',F11.5,1X,A4,')')
      ELSE
      WRITE (NOUT, 9006) TYPE, ICHAR, LABEL(NUM), DATA(I+1), XDIME(8),
     A     DATA(I+2), XDIME(9), DATA(I+3), XDIME(1), WORK1, XDIME(8)
 9006 FORMAT(' *QUAD*',I11,'.',12A1,' "',A4,'"',3(F13.5,1X,A4),' (',
     A       F11.5,1X,A4,')')
      ENDIF
      GO TO 5001
C
C     6. -- UPDATE (SLITS)
C
  600 IF(.NOT.PRINT) GO TO 5001
      IF (SLITS) THEN
       IWORK1 = DATA(I+1)
       IF (ISTOR(NUM+1)-I .EQ. 5) THEN
        IWORK2 = DATA(I+3)
        WRITE (NOUT,9077) TYPE, LABEL(NUM), IWORK1, DATA(I+2)
     A                ,XDIME(IWORK1), IWORK2, DATA(I+4), XDIME(IWORK2)
 9077   FORMAT(' *SLIT*',I11,'.',13X,'"',A4,'"',2(I13,F13.5,1X,A4))
       ELSE
        WRITE (NOUT,9078) TYPE, LABEL(NUM), IWORK1, DATA(I+2)
     A                   ,XDIME(IWORK1)
 9078   FORMAT(' *SLIT*',I11,'.',13X,'"',A4,'"',I13,F13.5,1X,A4)
       ENDIF
      ELSE
       WRITE (NOUT,9007) TYPE, LABEL(NUM), JANET, DATA(I+2)
 9007  FORMAT(' *UPDATE*',I9,'.',13X,'"',A4,'"      (',I1,'.)',F10.1)
      ENDIF
      GO TO 5001
C
C     7. -- BEAM CENTROID SHIFT
C
  700 IF(.NOT.PRINT) GO TO 5001
      WRITE (NOUT,9008) TYPE, LABEL(NUM), (DATA(I+J), XDIME(J), J=1,6)
 9008 FORMAT(' *AXIS SHIFT*',I5,'.',13X,'"',A4,'"',/1X,6(F13.5,1X,A4))
      GO TO 5001
C
C     8. -- MAGNET MISALIGNMENT
C
  800 IF(.NOT.PRINT) GO TO 5001
      I1 = TYT / 100
      IC1 = TABLE(I1+1)
      I2 = MOD(TYT/10,10)
      IC2 = TABLE(I2+1)
      IC3 = TABLE(RORC+1)
      WRITE (NOUT, 9009) TYPE, ICHAR, LABEL(NUM), DATA(I+1), XDIME(1),
     A                   DATA(I+2), XDIME(2), DATA(I+3), XDIME(1),
     B                   DATA(I+4), XDIME(2), DATA(I+5), XDIME(1),
     C                   DATA(I+6), XDIME(2), IC1, IC2, IC3
 9009 FORMAT(' *MISALIGN*',I7,'.',12A1,' "',A4,'"',/1X,6(F13.5,1X,A4),
     A       8H    CODE,2X,3A1)
      GO TO 5001
C
C     10. -- FITTING CONSTRAINTS
C
 1000 CALL ASSESS
      IF(FORMIO) THEN
      CTY = TIE(I+1)
      Z = LC/UNIT(8)
      WRITE (NOUT, 9011) TYPE, TABLE(CTY+1), LABEL(NUM), DATA(I+1),
     A                   DATA(I+2), DATA(I+3), DATA(I+4), COC, Z
 9011 FORMAT(' *FIT*',I12,'.',A1,12X,'"',A4,'"',F8.0,F5.0,F14.5,' /',
     A       F7.5,8X,'(',F10.5,' )',F10.3)
      END IF
      IF (.NOT. FORMIO) CALL PLOTFL
      GO TO 5002
C
C     11. -- ACCELERATOR
C
 1100 IF(.NOT.PRINT) GO TO 5001
      WORK1  =  RI / UNIT(11)
      WORK2  =  RI * WORK1 / (SM * ( 1. + GAMMA))
      WRITE (NOUT, 9012) TYPE, ICHAR, LABEL(NUM), DATA(I+1), XDIME(8),
     A                   WORK2, XDIME(11), WORK1, XDIME(11)
 9012 FORMAT(' *ACC*',I12,'.',12A1,' "',A4,'"',F13.5,1X,A4,F13.5,
     A       1X,A4,F13.5,1X,A4)
      GO TO 5001
C
C     12. -- CORRELATIONS
C
 1200 IF(PRINT) WRITE (NOUT, 9112) TYPE, ICHAR, LABEL(NUM)
 9112 FORMAT(' *CORR*',I11,'.',12A1,' "',A4,'"')
      GO TO 5001
C
C     13. -- INPUT-OUTPUT OPTIONS
C
 1300 CALL IO
      CDB = 0
      GO TO 5002
C
C     14. -- ARBITRARY MATRIX
C
 1400 IF(.NOT.PRINT) GO TO 1420
      IF (DATA(I+8) .EQ. 0.0) GO TO 1410
      WRITE (NOUT, 9013) TYPE, ICHAR, LABEL(NUM), DATA(I+7)
 9013 FORMAT(' *MATRIX*',I9,'.',12A1,' "',A4,'"      ROW',F5.0)
      GO TO 1420
 1410 WRITE (NOUT, 9014) TYPE, ICHAR, LABEL(NUM), DATA(I+7)
 9014 FORMAT(' *MATRIX*',I9,'.',12A1,' "',A4,'"      ROW',F5.0,
     A       ' + 2ND ORDER TERMS')
 1420 IPLNO = ISTOR(NUM+1)
      IF(  IFIX( DATA( IPLNO ) )  .EQ.  14  )   GO TO 5002
      IF (PLOT .OR. PRINT) CALL RCO (0)
      GO TO 5001
C
C     16. -- SPECIAL PARAMETERS
C
 1600 IF(PRINT) THEN
      J = 2.0*DATA(I+1) - 1.0
      WRITE (NOUT, 9015) NAM(J), NAM(J+1), TYPE, ICHAR, LABEL(NUM),
     A                   DATA(I+1), DATA(I+2)
 9015 FORMAT(' ',2A4,I9,'.',12A1,' "',A4,'"',F8.0,F23.5)
      END IF
      GO TO 5003
C
C     17. -- SECOND ORDER CALCULATION
C
 1700 IF(PRINT) WRITE (NOUT, 9016) TYPE, LABEL(NUM)
 9016 FORMAT(' *2ND ORDER*',I6,'.',13X,'"',A4,'"',6X,
     A       'GAUSSIAN DISTRIBUTION')
      GO TO 5002
C
C     18. -- SEXTUPOLE
C
 1800 IF(.NOT.PRINT) GO TO 5001
      WRITE (NOUT, 9017) TYPE, ICHAR, LABEL(NUM), DATA(I+1), XDIME(8),
     A                   DATA(I+2), XDIME(9), DATA(I+3), XDIME(1)
 9017 FORMAT(' *SEXT*',I11,'.',12A1,' "',A4,'"',3(F13.5,1X,A4))
      GO TO 5001
C
C     19. -- SOLENOID
C
 1900 IF(.NOT.PRINT) GO TO 5001
      WRITE (NOUT, 9018) TYPE, ICHAR, LABEL(NUM), DATA(I+1), XDIME(8),
     A                   DATA(I+2), XDIME(9)
 9018 FORMAT(' *SOLO*',I11,'.',12A1,' "',A4,'"',2(F13.5,1X,A4))
      GO TO 5001
C
C     20. -- BEAM ROTATION
C
 2000 TOTROT = TOTROT + DATA(I+1)
      IF(.NOT.PRINT) GO TO 5001
      WRITE (NOUT, 9019) TYPE, ICHAR, LABEL(NUM), DATA(I+1)
 9019 FORMAT(' *Z RO*',I11,'.',12A1,' "',A4,'"',F13.5,' DEG')
      GO TO 5001
C
C     21. -- WIEN FILTER
C
 2100 IF(.NOT.PRINT) GO TO 5001
      GAMMA=SQRT(1.0+(RI/SM)**2)
      BETA=SQRT(1.0-1.0/GAMMA**2)
      WORK1=2997.9*BETA*DATA(I+2)*UNIT(9)
      WRITE (NOUT, 9020) TYPE, ICHAR, LABEL(NUM), DATA(I+1), XDIME(8),
     A     DATA(I+2), XDIME(9), WORK1
 9020 FORMAT(' *WIEN*',I11,'.',12A1,' "',A4,'"',2(F13.5,1X,A4),F13.5,1X
     A,'KV/CM')
      GO TO 5001
C
C     22. -- SPACE CHARGE
C
 2200 IF(.NOT.PRINT) GO TO 5001
      WRITE(NOUT,9022) TYPE, ICHAR, LABEL(NUM), DATA(I+1), XDIME(8),
     A                 DATA(I+2), DATA(I+3), DATA(I+4)
 9022 FORMAT(' *SP CH*',I10,'.',12A1,' "',A4,'"',F13.5,1X,A4,F13.5,
     A       ' AMP ',F13.5,' MHZ ',F15.5)
      GO TO 5001
C
C     23. -- RF - CAVITY
C
 2300 IF(.NOT.PRINT) GO TO 5001
      WRITE(NOUT,9023) TYPE, ICHAR, LABEL(NUM), DATA(I+1), DATA(I+2),
     A                 DATA(I+3)
 9023 FORMAT(' *RF CAV*',I9,'.',12A1,' "',A4,'"',F13.5,' MEV ',
     A       F13.1,' DEG ',F13.5,' MHZ')
      GO TO 5001
C
C     24. -- DEFINE REGISTER CONTENTS
C
 2400 CALL ASSESS
      J = DATA(I+3)
      REG(J) = COC
      LREG(J) = .TRUE.
      IF(.NOT.PRINT) GO TO 5002
      DAT2 = DATA(I+2)
      IF( J .EQ. 100) DAT2 = 0.0
      WRITE(NOUT,9024) TYPE ,LABEL(NUM), DATA(I+1), DAT2, DATA(I+3),
     1 COC
 9024 FORMAT(' *DEF RC*',I9,'.',13X,'"',A4,'"',F8.0,F5.0,5X,'REG NO',
     1 F5.0,1X,'(',F10.5,' )')
      GO TO 5002
C
C     25. -- ALGEBRAIC OPERATIONS
C
 2500 CALL COMBIN(0)
      IF(.NOT.PRINT) GO TO 5002
      K1 = DATA(I+1)
      K2 = DATA(I+2)
      IOP = DATA(I+3)
      J = DATA(I+4)
      REGK1 = REG(K1)
      REGK2 = REG(K2)
      REGJ = REG(J)
      IF (IOP.EQ.5) GO TO 2505
      WRITE(NOUT,9025) TYPE, LABEL(NUM), K1, REGK1, K2, REGK2,
     1 IOP, CSYM(IOP), J, REGJ
 9025 FORMAT(' *COMBIN*',I9,'.',13X,'"',A4,'"',6X,'REG',I3,2X,
     1 '(',F10.5,' )',3X,'REG',I3,1X,'(',F10.5,' )',2X,'OP NO',
     2 I2,2X,A4,3X,'REG',I3,1X,'(',F10.5,' )')
      GO TO 5002
 2505 WRITE(NOUT,9125) TYPE, LABEL(NUM), K1, REGK1, IOP,
     1 CSYM(IOP), J, REGJ
 9125 FORMAT(' *COMBIN*',I9,'.',13X,'"',A4,'"',6X,'REG',I3,2X,
     1 '(',F10.5,' )',25X,'OP NO',I2,2X,A4,3X,'REG',I3,1X,'(',
     2 F10.5,' )')
      GO TO 5002
C
C     50. -- LOWER AND UPPER LIMITS FOR RANDOM OPTIMIZER
C
 5000 IF(.NOT.PRINT) GO TO 5002
      WRITE(NOUT,9050) TYPE, LABEL(NUM), DATA(I+1), DATA(I+2), DATA(I+3)
 9050 FORMAT(' *LIMITS*',I9,'.',13X,'"',A4,'"',3F13.5)
      GO TO 5002
C
C     PRINT BEAM ELLIPSE AND R1 MATRIX
C     WRITE DATA UNFORMATTED ON UNIT NOUT+1 FOR PLOTS
C
 5001 IF (PLOT .OR. PRINT) THEN
      CALL QEO
      CALL RCO(1)
      END IF
 5003 IF (.NOT. FORMIO .AND. PLOT) CALL PLOTFL
C
C     ADVANCE TO NEXT ELEMENT
C
 5002 NUM = NUM + 1
      IF (PERIDC) CALL PERSOL
      IF (NUM .LE. NEL) GO TO 10
      IF (.NOT.(PERIDX.OR.PERIDY)) GO TO 5300
      IF (PERIDC) GO TO 5300
      IF (FORMIO) WRITE(NOUT,9200)
 9200 FORMAT(' With the 16. 9. EMIX; and/or 16. 10. EMIY; cards you
     X are asking for a periodic'/' solution, but a 16. 11. 0.; card
     X is missing at Z = length of period.')
      CALL MENU(1)
      RETURN
C
C     END OF BEAM LINE - PRINT LENGTH AND LABELS OF VARIED PARAM
C
 5300 PRINT = FORMIO .AND. .NOT. TOR
      IF (.NOT. PRINT) RETURN
      WORK1  =  LC / UNIT(8)
      WRITE (NOUT,9021) WORK1, XDIME(8)
 9021 FORMAT('0*LENGTH*',F17.5,1X,A4)
      IF (NL .NE. 0) WRITE(NOUT, 5410) (LABS(J), J = 1, NL)
 5410 FORMAT('0*VARIED*',20(1X,A4,','))
      NL = 0
      DO 5310 NUM = 1, NEL
      I = ISTOR(NUM)
      TYPE = DATA(I)
      IF (TYPE .EQ. 10) THEN
      NL = NL + 1
      LABS(NL) = LABEL(NUM)
      IF (NL .EQ. 20) THEN
      WRITE(NOUT,5420) LABS
      NL = 0
      END IF
      END IF
 5310 CONTINUE
      IF (NL .NE. 0) WRITE(NOUT, 5420) (LABS(J), J = 1, NL)
 5420 FORMAT(' *CONSTR*',20(1X,A4,','))
      RETURN
      END
      SUBROUTINE PARSEC
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC3/  TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC5/ VSTOR(20), TIE(NND)
      INTEGER VSTOR, TIE
      COMMON /BLOC5A/ LABEL(NNL), LABM(20)
      CHARACTER       LABEL*4, LABM*4
      COMMON /BLOC11/ R(6,6), RV(6,6), T(6,6,6), TV(6,6,6)
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     1                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC22/ BE1, SB, TB, TB1
      COMMON /BLOC23/ H, AL, NB, BDB, CHARGE, LILENS, EQUAD, EBEND
      REAL NB
      LOGICAL LILENS, EQUAD, EBEND
      COMMON /BLOC24/ B, KQ2, KVK, K2H, K2V, CS, SN, CM1N, J
      REAL KQ2, KVK, K2H, K2V
      COMMON /BLOC25/ AP, CAP, JANET
      LOGICAL CAP
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC29/ A(21), CW, CA(21,21), SCALE(21), CASAV(21,21),
     1                PMARQ, CHSMIN, XNORM, GNORM, EPS
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC35/ KL, KO, SOLSEG
      REAL KL, KO
      LOGICAL SOLSEG
      COMMON /BLOC36/ VARS(4), SEXMAX, SEXLIM
      INTEGER VARS
      LOGICAL SEXLIM
      COMMON /BLOC37/ INT1(2), INT2(2), INT3(2), INT4(2), INT5(2),
     A                INT6(2), INT7(2), INT8(2), INT9(2), INT10(2),
     B                INT11(2)
      REAL INT1, INT2, INT3, INT4, INT5, INT6, INT7, INT8,INT9, INT10,
     A     INT11
C
      JH = 1
      JU = 3
      SIG = 1.0
      IF (TYPE .EQ. 2) GO TO 200
      IF (TYPE .EQ. 4) GO TO 400
      IF (TYPE .EQ. 18) GO TO 1800
      IF (TYPE .EQ. 19) GO TO 1900
      RETURN
C
C     2. -- POLE FACE ROTATION
C
  200 IF (DATA(I+1) .GE. 1000.) RETURN
      GO TO (5000,210), JV
C
  210 SB3 = SB**3
      JU = 4 - JH
      TV(JH+1,JH,JH) = 0.5*SIG*H*SB3/UNIT(8)
      TV(JH+1,JU,JU) = - 0.5*SIG*H*SB3/UNIT(8)
      TV(JU+1,1,3) = - SIG*H*SB3/UNIT(8)
      GO TO 5000
C
C     4. -- BENDING MAGNET
C
  400 GO TO (5000,5000,5000,470), JV
C
  470 DBEB = 1.0/(H*UNIT(1))**2
      JU = 4 - JH
      CSH = R(JH,JH)
      SKH = - R(JH+1,JH)
      SOKH = R(JH,JH+1)
      C2 = CSH**2 - SOKH**2*K2H
      S2K = 2.0*SKH*CSH
      TV(JH,JH,JH) = SIG*H*DBEB*( - 6.0 + 4.0*CSH + 2.0*C2)/
     A (12.0*(1.0 - NB))
      TV(JH,JH,JH+1) = SIG*H*DBEB*( - 4.0*SOKH + 4.0*SOKH*CSH)/
     1 (6.0*(1.0 - NB))
      TV(JH,JH+1,JH+1) = SIG*H*DBEB*(6.0*CM1N - 2.0*CSH*CM1N
     A + 2.0*(1.0 - NB)*SOKH**2)/(12.0*(1.0 - NB)**2)
      TV(JH+1,JH,JH) = - SIG*H*DBEB*(SKH + 2.0*SKH*CSH)/(3.0*(1.0 - NB))
      TV(JH+1,JH,JH+1) = - 2.0*SIG*H*DBEB*(CSH - C2)/(3.0*(1.0 - NB))
      TV(JH+1,JH+1,JH+1) = SIG*H*DBEB*( - SOKH + SOKH*CSH)/
     1 (1.5*(1.0 - NB))
      TV(JH,JH,6) = DBEB*(6.0 - 4.0*CSH - 2.0*C2 - 6.0*L*SKH)/
     A (6.0*(1.0 - NB)**2)
      TV(JH,JH+1,6) = DBEB*( - 2.0*SOKH - 4.0*SOKH*CSH + 6.0*L*CSH)/
     A (6.0*(1.0 - NB)**2)
      TV(JH,6,6) = SIG*DBEB*(H*CM1N*(18.0 + 2.0*CSH)
     A - 2.0*(1.0 - NB)*H*SOKH**2 + 12.0*L*(1.0 - NB)*H*SOKH)/
     A (12.0*(1.0 - NB)**3)
      TV(JH+1,JH,6) = DBEB*(-SKH/3.0 + S2K/1.5 - L*K2H*CSH)/
     1 (1.0 - NB)**2
      TV(JH+1,JH+1,6) = DBEB*((CSH - C2)/1.5 - L*SKH)/(1.0 - NB)**2
      TV(JH+1,6,6) = SIG*H*DBEB*( - 2.0*SOKH - 4.0*SOKH*CSH + 6.0*L*CSH)
     1 /(6.0*(1.0 - NB)**2)
      DO 480 II = 1, 2
      JU = 4 - JH
      IH = JH + II - 1
      IV = JU + II - 1
      TV(IH,JU,JU) = SIG*H**3*DBEB*(INT7(II) - NB*INT9(II))
      TV(IH,JU,JU+1) = 2.0*SIG*H*DBEB*INT8(II)
      TV(IH,JU+1,JU+1) = SIG*H*DBEB*INT9(II)
      TV(IV,1,3) = 2.0*SIG*H**3*DBEB*INT3(II)
      TV(IV,(JH+1)/2,(JU+5)/2) = 2.0*SIG*H*DBEB*INT4(II)
      TV(IV,(JU+1)/2,(JH+5)/2) = 2.0*SIG*H*DBEB*INT5(II)
      TV(IV,2,4) = 2.0*SIG*H*DBEB*INT6(II)
      TV(IV,JU,6) = 2.0*H**2*DBEB*(- INT3(II) + INT1(II))/(1.0 - NB)
      TV(IV,JU+1,6) = 2.0*DBEB*(-INT4(II) + H**2*INT2(II))/(1.0 - NB)
  480 CONTINUE
      GO TO 5000
C
C     18. -- SEXTUPOLE
C
 1800 W2 = 2.0*UNIT(9)/(RI*AP**2)
      JU = 4 - JH
      S = - 0.25*W2*L**2
      TV(JH,JH,JH) = SIG*S
      TV(JH+1,JH,JH) = 2.0*SIG*S/L
      S = - W2*L**4/24.0
      TV(JH,JH+1,JH+1) = SIG*S
      TV(JH+1,JH+1,JH+1) = 4.0*SIG*S/L
      S = 0.25*W2*L**2
      TV(JH,JU,JU) = SIG*S
      TV(JH+1,JU,JU) = 2.0*SIG*S/L
      S = W2*L**4/24.0
      TV(JH,JU+1,JU+1) = SIG*S
      TV(JH+1,JU+1,JU+1) = 4.0*SIG*S/L
      S = - W2*L**3/6.0
      TV(JH,JH,JH+1) = SIG*S
      TV(JH+1,JH,JH+1) = 3.0*SIG*S/L
      S = W2*L**3/6.0
      TV(JH,JU,JU+1) = SIG*S
      TV(JH+1,JU,JU+1) = 3.0*SIG*S/L
      S = 0.5*W2*L**2
      TV(JU,1,3) = SIG*S
      TV(JU+1,1,3) = 2.0*SIG*S/L
      S = W2*L**3/6.0
      TV(JU,(JU+1)/2,(JH+5)/2) = SIG*S
      TV(JU,(JH+1)/2,(JU+5)/2) = SIG*S
      TV(JU+1,(JU+1)/2,(JH+5)/2) = 3.0*SIG*S/L
      TV(JU+1,(JH+1)/2,(JU+5)/2) = 3.0*SIG*S/L
      S = W2*L**4/12.0
      TV(JU,2,4) = SIG*S
      TV(JU+1,2,4) = 4.0*SIG*S/L
      IF (.NOT. SEXLIM) GO TO 5000
      NV2 = IABS(TIE(I+2))
      CW = 1.0/SEXMAX**2
      CA(1,1) = CA(1,1) + CW*B**2
      CA(NV2+1,1) = CA(NV2+1,1) - CW*B*UNIT(9)
      CA(NV2+1,NV2+1) = CA(NV2+1,NV2+1) + CW*UNIT(9)**2
      GO TO 5000
C
C     19. -- SOLENOID
C
 1900 IF (JV .EQ. 2) GO TO 1910
      LV = UNIT(8)
      TEMP = 0.5*KO*(SN + KL*CS)*LV
      TV(1,1,6) = TEMP
      TV(2,2,6) = TEMP
      TV(3,3,6) = TEMP
      TV(4,4,6) = TEMP
      TEMP = KL*SN*LV
      TV(1,2,6) = TEMP
      TV(3,4,6) = TEMP
      TEMP = - 0.5*KO*(CS - KL*SN)*LV
      TV(1,3,6) = TEMP
      TV(2,4,6) = TEMP
      TV(4,2,6) = - TEMP
      TV(3,1,6) = - TEMP
      TEMP = - KL*CS*LV
      TV(1,4,6) = TEMP
      TV(3,2,6) = - TEMP
      TEMP = 0.25*KO*(2.0*KO*CS - KO*KL*SN)*LV
      TV(2,1,6) = TEMP
      TV(4,3,6) = TEMP
      TEMP = 0.25*KO*(2.0*KO*SN + KO*KL*SN)*LV
      TV(2,3,6) = TEMP
      TV(4,1,6) = - TEMP
      GO TO 5000
C
 1910 TEMP = 0.5*L*(SN + KL*CS)/RI
      TV(1,1,6) = TEMP
      TV(2,2,6) = TEMP
      TV(3,3,6) = TEMP
      TV(4,4,6) = TEMP
      TEMP = ( - SN/KO**2 + L*CS/KO + L**2*SN)/RI
      TV(1,2,6) = TEMP
      TV(3,4,6) = TEMP
      TEMP = - 0.5*L*(CS - KL*SN)/RI
      TV(1,3,6) = TEMP
      TV(2,4,6) = TEMP
      TV(4,2,6) = - TEMP
      TV(3,1,6) = - TEMP
      TEMP = ( - (1.0 - CS)/KO**2 + L*SN/KO - L**2*CS)/RI
      TV(1,4,6) = TEMP
      TV(3,2,6) = - TEMP
      TEMP = 0.25*(3.0*KL*CS - KL**2*SN + SN)/RI
      TV(2,1,6) = TEMP
      TV(4,3,6) = TEMP
      TEMP = 0.25*(3.0*KL*SN + KL**2*CS + 1.0 - CS)/RI
      TV(2,3,6) = TEMP
      TV(4,1,6) = - TEMP
C
C     CHANGE TRIANGULAR MATRIX INTO SQUARE MATRIX
C
 5000 DO 5010 IA = 1, 5
      DO 5010 IB = 1, 5
      IBP1 = IB + 1
      DO 5010 IC = IBP1, 6
      TV(IA,IB,IC) = 0.5*TV(IA,IB,IC)
      TV(IA,IC,IB) = TV(IA,IB,IC)
 5010 CONTINUE
      RETURN
      END
      SUBROUTINE PARTLS
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC3/ TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC11/ R(6,6), RV(6,6), T(6,6,6), TV(6,6,6)
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC17/ COD(6)
      COMMON /BLOC21/ EN, ES, BE, APB(2), LAYL, LAYX, RAB1,RAB2,RINVL
      REAL LAYL, LAYX
      COMMON /BLOC22/ BE1, SB, TB, TB1
      COMMON /BLOC23/ H, AL, NB, BDB, CHARGE, LILENS, EQUAD, EBEND
      REAL NB
      LOGICAL LILENS, EQUAD, EBEND
      COMMON /BLOC24/ B, KQ2, KVK, K2H, K2V, CS, SN, CM1N, J
      REAL KQ2, KVK, K2H, K2V
      COMMON /BLOC25/ AP, CAP, JANET
      LOGICAL CAP
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC27/ CT(6,6), CT0(6,6), CT1(3,3), VM(6), DMC, NM
      LOGICAL DMC
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC31/ J1, TYP1
      INTEGER TYP1
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC33/ FOTILT, SM
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      COMMON /BLOC35/ KL, KO, SOLSEG
      REAL KL, KO
      LOGICAL SOLSEG
      COMMON /BLOC38/ MOR,TOR,ANIN,NPFR
      LOGICAL MOR,TOR,ANIN
C
      IPLJV = I + JV
      IF (TYPE .LE. 5) GO TO 1
      IF (TYPE .EQ. 7) GO TO 700
      IF (TYPE .EQ. 8) GO TO 800
      IF (TYPE .EQ. 12) GO TO 1200
      IF (TYPE .EQ. 14) GO TO 1400
      IF (TYPE .EQ. 18) GO TO 5000
      IF (TYPE .EQ. 19) GO TO 1900
      IF (TYPE .EQ. 20) GO TO 2000
      IF (TYPE .EQ. 21) GO TO 2100
      IF (TYPE .EQ. 23) GO TO 2300
      RETURN
    1 GO TO (100,200,300,400,500), TYPE
C
C     1. -- BEAM
C
  100 SIG = 1.0
      IF (NV2 .LT. 0) SIG = -1.0
      NV2 = IABS(NV2)
      IPLJV = I + JV
      IF (SVP(NV2)) GO TO 120
      DO 110 J = 1, 6
      COV(J,NV2) = 0.0
      DO 110 K = 1, 6
      SV(J,K,NV2) = 0.0
  110 CONTINUE
  120 SV(JV,JV,NV2) = SV(JV,JV,NV2) + 2.0*SIG*DATA(IPLJV)*UNIT(JV)**2
      SVP(NV2) = .TRUE.
      RETURN
C
C     2. -- POLE FACE ROTATION
C
  200 IF (DATA(I+1) .GE. 1000.) RETURN
      IF(JV .EQ. 2) GO TO 201
      LINEAR = .FALSE.
      RV(2,1) = 0.01745*H/COS(BE)**2
      RV(4,3) = - 0.01745*H/COS(BE1)**2
      RETURN
  201 IF(SEC) GO TO 5000
      ECB = (H/COS(BE1))**2
      TCOR = 2.0*H*APB(2)*LAYL
      RV(4,3) = 2.0*SB*LAYL*ECB*(1.0-2.0*LAYX*TCOR*TB)*UNIT(3)
      RETURN
C
C     3. -- DRIFT SPACE
C
  300 LINEAR = .FALSE.
      LV = UNIT(8)
      RV(1,2) = LV
      RV(3,4) = LV
      RV(5,6) = LV * SM ** 2 / (RI ** 2 + SM ** 2)
      RETURN
C
C     4. -- BENDING MAGNET
C
  400 CONTINUE
      IF (EBEND) RETURN
      GO TO (410,440,470,5000), JV
C
  410 LINEAR = .FALSE.
      LV = UNIT(8)
      J = 3
      CALL DFOL
      J = 1
      KQ2 = K2H
      CALL DFOL
      IF (ANIN) GO TO 420
      RV(1,6) = - R(2,1)/DEN(K2H)
      RV(5,2) = - RV(1,6)
      RV(2,6) = H*R(1,1)
      RV(5,1) = - RV(2,6)
      RV(5,6) = (R(1,1) - 1.0)/DEN(1.0 - NB)
      RETURN
  420 RV(1,6) = R(1,6)*UNIT(8)/DEN(L)
      RV(5,2) = R(5,2)*UNIT(8)/DEN(L)
      RV(5,6) = R(5,6)*UNIT(8)/DEN(L)
      RETURN
C
  440 LINEAR = .FALSE.
      J = 3
      KVK = UNIT(9)/DEN(B)
      IF(ANIN) KVK = UNIT(7)/DEN(AL)
      CALL DFOCUS
      J = 1
      KQ2 = K2H
      CALL DFOCUS
      RV(1,6) = ( - 2.0*R(1,6) - H*L*R(2,1)/ABS(KQ2) + R(1,6))*KVK
      RV(5,2) = - RV(1,6)
      RV(2,6) = H*RV(1,2) + KVK*R(2,6)
      RV(5,1) = - RV(2,6)
      RV(5,6) = ( - R(5,6) + H*L*R(1,6))*KVK
      RETURN
C
  470 LINEAR = .FALSE.
      J = 3
      KVK = 0.5/DEN(NB)
      CALL DFOCUS
      J = 1
      KQ2 = K2H
      KVK = - 0.5/DEN(1.0 - NB)
      CALL DFOCUS
      RV(1,6) = KVK*( - 2.0*R(1,6) - H*L*R(2,1)/DEN(ABS(KQ2)))
      RV(5,2) = - RV(1,6)
      RV(2,6) = H*RV(1,2)
      RV(5,1) = - RV(2,6)
      RV(5,6) = ( - 3.0*R(5,6) + H*L*R(1,6))*KVK
      RETURN
C
C     5. -- QUADRUPOLE
C
  500 LINEAR = .FALSE.
      GO TO (510,520,530), JV
C
  510 LV = UNIT(8)
      J = 3
      CALL DFOL
      IF (.NOT. LILENS) THEN
       KQ2  =  -KQ2
      ENDIF
      J  =  1
      CALL DFOL
      IF (.NOT. LILENS) THEN
       KQ2  =  - KQ2
      ENDIF
      RETURN
C
  520 J = 3
      IF (EQUAD) THEN
       KVK  =  3.335641 * 0.0001 / DEN(2. * B)
      ELSE
       KVK  =  UNIT(9) / DEN(2. * B)
      ENDIF
      CALL DFOCUS
      J  =  1
      IF (.NOT. LILENS) THEN
       KQ2  =  - KQ2
      ENDIF
      CALL DFOCUS
      RETURN
C
  530 J = 3
      KVK  =  UNIT(1) / DEN(-2. * AP)
      CALL DFOCUS
      J  =  1
      IF (.NOT. LILENS) THEN
       KQ2  =  - KQ2
      ENDIF
      CALL DFOCUS
      RETURN
C
C     7. -- BEAM CENTROID SHIFT
C
  700 SIG = 1.0
      IF (NV2 .LT. 0) SIG = -1.0
      NV2 = IABS(NV2)
      IF (SVP(NV2)) GO TO 720
      DO 710 J = 1, 6
      COV(J,NV2) = 0.0
      DO 710 K = 1, 6
      SV(J,K,NV2) = 0.0
  710 CONTINUE
  720 DO 730 J = 1, 6
      DSV = SIG*CO(J)*UNIT(JV) + COD(J)*COV(JV,NV2)
      SV(J,JV,NV2) = SV(J,JV,NV2) +DSV
      SV(JV,J,NV2) = SV(JV,J,NV2) +DSV
  730 CONTINUE
  740 COV(JV,NV2) = COV(JV,NV2) + SIG*UNIT(JV)
      SVP(NV2) = .TRUE.
      RETURN
C
C     8. -- MAGNET MISALIGNMENT
C
  800 IF(MOD(TYT/10,10) .NE. 0) RETURN
      IF (RORC .GE. 3) RETURN
      CALL WOBBLE
      RETURN
C
C     12. -- CORRELATIONS IN BEAM ELLIPSE
C
 1200 SIG = 1.0
      IF (NV2 .LT. 0) SIG = -1.0
      NV2 = IABS(NV2)
      K = (3 + IFIX(SQRT(8.0*FLOAT(JV) - 6.99)))/2
      J = JV - (K-1)*(K-2)/2
      DSIG = SIG*SQRT(SI(J,J)*SI(K,K))
      IF (SVP(NV2)) GO TO 1220
      DO 1210 J1 = 1, 6
      COV(J1,NV2) = 0.0
      DO 1210 K1 = 1, 6
      SV(J1,K1,NV2) = 0.0
 1210 CONTINUE
 1220 SV(J,K,NV2) = SV(J,K,NV2) + DSIG
      SV(K,J,NV2) = SV(J,K,NV2)
      SVP(NV2) = .TRUE.
      RETURN
C
C     14. -- ARBITRARY MATRIX
C
 1400 RV(J1,JV) = UNIT(J1)/UNIT(JV)
      GO TO 5000
C
C     19. -- SOLENOID
C
 1900 LINEAR = .FALSE.
      IF (JV .EQ. 1) GO TO 1910
      IF (JV .EQ. 2) GO TO 1920
      GO TO 1950
C
 1910 LV = UNIT(8)
      IF (.NOT.SOLSEG) GO TO 1915
C
C     WITHOUT FRINGE FIELD
C
      RV(2,2) = - KO*SN*LV
      RV(1,2) = CS*LV
      RV(2,4) = KO*CS*LV
      RV(1,4) = SN*LV
      GO TO 1950
C
C     WITH FRINGE FIELD
C
 1915 RV(1,1) = - 0.5*KO*SN*LV
      RV(2,2) = RV(1,1)
      RV(1,2) = CS*LV
      RV(2,1) = - 0.25*KO**2*CS*LV
      RV(1,3) = 0.5*KO*CS*LV
      RV(2,4) = RV(1,3)
      RV(1,4) = SN*LV
      RV(2,3) = - 0.25*KO**2*SN*LV
      GO TO 1950
C
 1920 AUX = UNIT(9) / RI
      IF (L .NE. 0.) GO TO 1925
C
C     ENTRANCE OR EXIT FRINGE FIELD ALONE (L=0)
C
      IF (.NOT.SOLSEG) AUX = - AUX
      RV(2,3) = 0.5*AUX
      RV(4,1) = - RV(2,3)
      GO TO 5000
C
 1925 IF (.NOT. SOLSEG) GO TO 1930
C
C     WITHOUT FRINGE FIELD
C
      RV(2,2) = -L*SN*AUX
      RV(1,2) = AUX*(-SN+KL*CS)/KO**2
      RV(2,4) = L*CS*AUX
      RV(1,4) = AUX*(KL*SN-(1.0-CS))/KO**2
      GO TO 1950
C
C     WITH FRINGE FIELD
C
 1930 RV(1,1) = -0.5*L*SN*AUX
      RV(2,2) = RV(1,1)
      RV(1,2) = AUX*(-SN+KL*CS)/KO**2
      RV(2,1) = -0.25*(SN+KL*CS)*AUX
      RV(1,3) = 0.5*L*CS*AUX
      RV(2,4) = RV(1,3)
      RV(1,4) = AUX*(KL*SN-(1.0-CS))/KO**2
      RV(2,3) = -0.25*(KL*SN+(1.0-CS))*AUX
C
 1950 CONTINUE
      DO 1951 J = 3, 4, 1
      DO 1951 J1 = 1, 2, 1
      RV(J,J1) = - RV(J-2,J1+2)
 1951 CONTINUE
      DO 1955 J = 1, 2
      DO 1955 J1 = 1, 2
      RV(J+2, J1+2)  =  RV(J,J1)
 1955 CONTINUE
      GO TO 5000
C
C     20. -- BEAM ROTATION
C
 2000 RV(4,4)  =  0.01745 * R(3,1)
      RV(3,3)  =  RV(4,4)
      RV(2,2)  =  RV(4,4)
      RV(1,1)  =  RV(4,4)
      RV(2,4)  =  0.01745 * R(1,1)
      RV(1,3)  =  RV(2,4)
      RV(4,2)  = -RV(2,4)
      RV(3,1)  = -RV(2,4)
      LINEAR = .FALSE.
      RETURN
C
C     21. -- WIEN FILTER
C
 2100 GAMMA=SQRT(1.0+(RI/SM)**2)
      LINEAR = .FALSE.
      GO TO (2110,2120), JV
C
 2110 LV=UNIT(8)
      J=1
      CALL DFOL
      RV(3,4)=UNIT(8)
      RV(1,6)=-R(2,1)/DEN(H)
      RV(2,6)=-H*R(1,1)/GAMMA
      RETURN
C
 2120 KVK=UNIT(9)/B
      J=1
      CALL DFOCUS
      RV(1,6)=KVK*(-R(1,6)+R(2,1)*L/DEN(H))
      RV(2,6)=-KVK*R(1,1)*SQRT(KQ2)*L/GAMMA
      RETURN
C
C     23. -- RF-CAVITY
C
 2300 RV(6,5) = R(6,5) / DEN(DATA(I+1))
      RV(4,3) = R(4,3) / DEN(DATA(I+1))
      RV(2,1) = R(2,1) / DEN(DATA(I+1))
      RETURN
C
C     SECOND ORDER DERIVATIVE TERMS
C
 5000 IF (SEC) CALL PARSEC
      RETURN
      END
      SUBROUTINE PERSOL
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC4/ LC, TOTANG, LCV(20)
      REAL LC, LCV
      COMMON /BLOC6/ PERIDX, PERIDY, PERIDC, RCPER, EMITX, EMITY
      LOGICAL PERIDX, PERIDY, PERIDC, RCPER
      COMMON /BLOC15/ RS(6,6), RT(6,6), TS(6,6,6), TT(6,6,6)
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
C
      IF(RCPER) RETURN
      CALL RCALC(1)
      DO 5 J = 1, 6
      DO 5 K = 1, 6
      RS(J,K) = RS(J,K) * UNIT(K) / UNIT(J)
    5 CONTINUE
C
C     PERIODIC SOLUTION IN X,X'
C
      IF(.NOT.PERIDX) GO TO 10
      COSMU = .5 * (RS(1,1) + RS(2,2))
      SINMU = SQRT(1. - COSMU**2)
      TANCHI = .5 * (RS(2,2) - RS(1,1)) / SINMU
      CHI = ATAN(TANCHI)
      SINCHI = SIN(CHI)
      COSCHI = SQRT(1. - SINCHI**2)
      X = SQRT(ABS(EMITX * RS(1,2) / SINMU))
      R12 = SINCHI
      XP = EMITX  / (X * COSCHI)
C
C     PERIODIC SOLUTION IN D,D'
C
      DELTA = 2. - RS(1,1) - RS(2,2)
      R16 = (RS(1,2) * RS(2,6) + RS(1,6) * (1. - RS(2,2)))/ DELTA
      R26 = (RS(2,1) * RS(1,6) + RS(2,6) * (1. - RS(1,1)))/ DELTA
C
C     PERIODIC SOLUTION IN Y,Y'
C
   10 IF(.NOT.PERIDY) GO TO 20
      COSMU = .5 * (RS(3,3) + RS(4,4))
      SINMU = SQRT(1. - COSMU**2)
      TANCHI = .5 * (RS(4,4) - RS(3,3)) / SINMU
      CHI = ATAN(TANCHI)
      SINCHI = SIN(CHI)
      COSCHI = SQRT(1. - SINCHI**2)
      Y = SQRT(ABS(EMITY * RS(3,4) / SINMU))
      R34 = SINCHI
      YP = EMITY / (Y * COSCHI)
   20 CONTINUE
C
C     CHANGE DATA ON BEAM CARD
C
      DO 30 NUM = 1, NEL
      I = ISTOR(NUM)
      ITYPE = DATA(I)
      IF(ITYPE .NE. 1) GO TO 30
      IF(PERIDX) DATA(I+1) = X
      IF(PERIDX) DATA(I+2) = XP
      IF(PERIDY) DATA(I+3) = Y
      IF(PERIDY) DATA(I+4) = YP
      GO TO 35
   30 CONTINUE
      GO TO 60
C
C     CHANGE DATA ON CORRELATION CARD
C
   35 DO 40 NUM = 1, NEL
      I = ISTOR(NUM)
      ITYPE = DATA(I)
      IF(ITYPE .NE. 12) GO TO 40
      IF(PERIDX) DATA(I+1) = R12
      IF(PERIDY) DATA(I+6) = R34
      GO TO 45
   40 CONTINUE
      GO TO 60
C
C     CHANGE DATA ON 14. CARD
C
   45 M = 0
      IF(PERIDX) M = 2
      DO 50 NUM = 1, NEL
      I = ISTOR(NUM)
      ITYPE = DATA(I)
      IF(ITYPE .NE. 14) GO TO 50
      IF(DATA(I+7).EQ.1.0 .AND. PERIDX) THEN
      M = M - 1
      DATA(I+1) = 1.
      DATA(I+2) = 0.
      DATA(I+3) = 0.
      DATA(I+4) = 0.
      DATA(I+5) = 0.
      DATA(I+6) = R16
      ELSE IF(DATA(I+7).EQ.2.0 .AND. PERIDX) THEN
      M = M - 1
      DATA(I+1) = 0.
      DATA(I+2) = 1.
      DATA(I+3) = 0.
      DATA(I+4) = 0.
      DATA(I+5) = 0.
      DATA(I+6) = R26
      ELSE IF(DATA(I+7).EQ.3.0 .AND. PERIDY) THEN
      DATA(I+1) = 0.
      DATA(I+2) = 0.
      DATA(I+3) = 1.
      DATA(I+4) = 0.
      DATA(I+5) = 0.
      DATA(I+6) = 0.
      ELSE IF(DATA(I+7).EQ.4.0 .AND. PERIDY) THEN
      DATA(I+1) = 0.
      DATA(I+2) = 0.
      DATA(I+3) = 0.
      DATA(I+4) = 1.
      DATA(I+5) = 0.
      DATA(I+6) = 0.
      END IF
   50 CONTINUE
      IF(M.EQ.0) GO TO 70
C
C     ERROR MESSAGE
C
   60 IF (FORMIO) WRITE(NOUT, 1000)
 1000 FORMAT(' You are asking for a periodic solution, but
     X a beam card, a type_code'/' 12 card and ev. 2 cards
     X of type_code 14 have to be in the input_file.')
      CALL MENU(1)
      RETURN
C
C     SET POINTER TO BEGINNING OF BEAMLINE
C
   70 NUM = 1
      LC = 0.0
      TOTANG = 0.0
      RCPER= .TRUE.
      RETURN
      END
      SUBROUTINE PICKUP(I)
      COMMON /BLOC4/  LC, TOTANG, LCV(20)
      REAL LC, LCV
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     1 SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC18/ SIT(6,6), CEN(6), RECENT
      LOGICAL RECENT
      COMMON /BLOC44/ BEGM(3), BEGMS(20), ENDMS(20)
      COMMON /BLOC45/ SIOL(3,6,6), COLD(3,6), SPO(3)
      LOGICAL SPO
      BEGM(I) = LC
      IF (.NOT. RECENT) CALL BEAM
      DO 10 J = 1, 6
      COLD(I,J) = CEN(J)
      DO 10 K = 1, 6
      SIOL(I,J,K) = SIT(J,K)
   10 CONTINUE
      SPO(I) = S1P
      RETURN
      END
      SUBROUTINE PIVOT
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
C
      IR = CDB - 19
      DO 422  J =  1,3,1
      X0(IR,J) = - X0(IR,J)
      IF (J .GT. 2) GO TO 4220
      JPLUS1  =  J+1
      DO  422  K  = JPLUS1,3,1
      S  =  O(IR,J,K)
      O(IR,J,K)    =  O(IR,K,J)
      O(IR,K,J)  =  S
  422 CONTINUE
 4220 CONTINUE
      TYT  =  0
      CALL  TFL
      CALL RESET  (IR)
      TMK  =  .TRUE.
      RETURN
      END

      SUBROUTINE PLOTFL
C
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC3/ TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC4/ LC, TOTANG, LCV(20)
      REAL LC, LCV
      COMMON /BLOC5/ VSTOR(20), TIE(NND)
      INTEGER VSTOR, TIE
      COMMON /BLOC5A/ LABEL(NNL), LABM(20)
      CHARACTER       LABEL*4, LABM*4
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC23/ H, AL, NB, BDB, CHARGE, LILENS, EQUAD, EBEND
      REAL NB
      LOGICAL LILENS, EQUAD, EBEND
      COMMON /BLOC24/ B, KQ2, KVK, K2H, K2V, CS, SN, CM1N, J
      REAL KQ2, KVK, K2H, K2V
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC29/ A(21), CW, CA(21,21), SCALE(21), CASAV(21,21),
     1                PMARQ, CHSMIN, XNORM, GNORM, EPS
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC33/ FOTILT, SM
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      COMMON /BLOC49/ NL, FAILED, ITER
      LOGICAL FAILED
      COMMON /BLO49A/ LABS(20)
      CHARACTER       LABS*4
      COMMON /BLOC50/ XI1, XI2, XI3
      COMMON /BLOC58/ FIELD
      COMMON /BLOC59/ SLITS
      LOGICAL SLITS
      COMMON /BLOC60/ ALONG, CENUN(6), SIUN(6), R12, R34, R56, R13, R24,
     A                RMTX(13), SRMTX(105), PLOT, TOTROT
      LOGICAL PLOT
      COMMON/SC/STEP,AMP,BFREQ,GAMMA,CAPPA,IPTFQ,SC1P,SC3P
      LOGICAL SC1P,SC3P
      COMMON /SCDIR/ DIR, LDIR
      CHARACTER*80 DIR
      COMMON /FIRST/ FIRST1, FIRST2, FIRST3, FIRST4, SNTNL
      LOGICAL FIRST1, FIRST2, FIRST3, FIRST4, SNTNL
C
      CHARACTER TIT*10
      CHARACTER    FILNAM*10, ANS*3
      REAL DUM(6)
      LOGICAL FX
      DATA FILNAM /'FOR002.DAT'/
C
      IF (.NOT.FIRST3) GO TO 5
      FIRST3 = .FALSE.
c      INQUIRE(FILE=DIR(1:LDIR)//FILNAM,EXIST=FX)
c      IF (FX) THEN
c       INQUIRE(FILE=DIR(1:LDIR)//FILNAM,FORMATTED=ANS)
c       IF (ANS(1:3) .EQ. 'YES') CALL SYSTEM('DEL '//DIR(1:LDIR)//FILNAM)
c      ENDIF
      OPEN(UNIT=NOUT+1,FILE=DIR(1:LDIR)//FILNAM,STATUS='UNKNOWN')
      REWIND NOUT+1
      WRITE(NOUT+1,1002) (XDIME(J),J=1,11), AMP
 1002 FORMAT(12A4)
C
    5 IF (.NOT. (FIRST4 .AND. SEC) ) GO TO 10
      FIRST4 = .FALSE.
      OPEN(UNIT=0,FILE=DIR(1:LDIR)//'FOR000.DAT',STATUS='UNKNOWN')
      REWIND 0
      WRITE(0,1003) (XDIME(J),J=1,11)
 1003 FORMAT(11A4)
C
   10 CONTINUE
      CALL LAYOUT(XL,YL,ZL,THETA,PHI)
      IF (TYPE .EQ.  1) GO TO 100
      IF (TYPE .EQ.  2) GO TO 200
      IF (TYPE .EQ.  4) GO TO 400
      IF (TYPE .EQ.  6 .AND. SLITS) GO TO 600
      IF (TYPE .EQ. 10) GO TO 1000
      IF (TYPE .EQ. 11) GO TO 1100
C
C     MOST ELEMENTS
C
   20 WRITE(NOUT+1,1001) TYPE, LABEL(NUM), (DATA(I+J), J=1,4), ALONG,
     A                   (CENUN(J),J=1,6), (SIUN(J),J=1,6),R12,R34,R56,
     B                   R13,R24,(RMTX(J),J=1,13),XL,YL,ZL,THETA,PHI
 1001 FORMAT(42A4)
      GO TO 5000
C
C     1. -- BEAM
C
  100 WORK = RI / UNIT(11)
      WRITE(NOUT+1,1001) TYPE, LABEL(NUM), WORK, (DUM(J),J=1,3), ALONG,
     A                   (CENUN(J),J=1,6), (SIUN(J),J=1,6),R12,R34,R56,
     B                   R13,R24,(RMTX(J),J=1,13),XL,YL,ZL,THETA,PHI
      GO TO 5000
C
C     2. -- FRINGE
C
  200 IF (DATA(I+1) .GE. 1000.) THEN
       WORK = DATA(I+1)
       WRITE(NOUT+1,1001) TYPE, LABEL(NUM), WORK, XI1, XI2, XI3, ALONG,
     A                    (CENUN(J),J=1,6), (SIUN(J),J=1,6),R12,R34,R56,
     B                    R13,R24,(RMTX(J),J=1,13),XL,YL,ZL,THETA,PHI
       GO TO 5000
      ELSE
       GO TO 20
      ENDIF
C
C     4. -- BEND
C
  400 CONTINUE
      IF (EBEND) GO TO 401
      WORK = AL / UNIT(7)
      BNORM = B / UNIT(9)
      WRITE(NOUT+1,1001) TYPE, LABEL(NUM), DATA(I+1), BNORM, NB, WORK,
     A                   ALONG,(CENUN(J),J=1,6), (SIUN(J),J=1,6),
     B                   R12,R34,R56,R13,R24,(RMTX(J),J=1,13),XL,YL,ZL,
     C                   THETA,PHI
      GO TO 5000
  401 CONTINUE
      WORK = DATA(I+2)
      BNORM = FIELD
      WRITE(NOUT+1,1001) TYPE, LABEL(NUM), DATA(I+1), BNORM, NB, WORK,
     A                   ALONG,(CENUN(J),J=1,6), (SIUN(J),J=1,6),
     B                   R12,R34,R56,R13,R24,(RMTX(J),J=1,13),XL,YL,ZL,
     C                   THETA,PHI
      GO TO 5000
C
C     6. -- SLITS
C
  600 IF (ISTOR(NUM+1)-I .EQ. 5) THEN
       WRITE(NOUT+1,1001) TYPE, LABEL(NUM), (DATA(I+J), J=1,4), ALONG,
     A                    (CENUN(J),J=1,6), (SIUN(J),J=1,6),R12,R34,R56,
     B                    R13,R24,(RMTX(J),J=1,13),XL,YL,ZL,THETA,PHI
      ELSE
       XN1 = 0.
       XN2 = 0.
       WRITE(NOUT+1,1001) TYPE, LABEL(NUM), (DATA(I+J), J=1,2),
     A                    XN1, XN2, ALONG, (CENUN(J),J=1,6),
     B                    (SIUN(J),J=1,6),R12,R34,R56,R13,R24,
     C                    (RMTX(J),J=1,13),XL,YL,ZL,THETA,PHI
      ENDIF
      GO TO 5000
C
C     10. -- FITTING CONSRAINS
C
 1000 Z = LC / UNIT(8)
      WRITE(NOUT+1,1001) TYPE, LABEL(NUM), (DATA(I+J), J=1,4), COC, Z,
     A                   CA(1,1), NL, (LABS(J),J=1,20), FAILED,
     B                   DUM(1),DUM(2),DUM(3),DUM(4),DUM(5),DUM(6),
     C                   XL,YL,ZL,THETA,PHI
      RETURN
C
C     11.  -- ELECTROSTATIC ACCELERATOR
C
 1100 WORK1 = RI / UNIT(11)
      WORK2 = RI * WORK1 / (SM * ( 1. + GAMMA ))
      WRITE(NOUT+1,1001) TYPE, LABEL(NUM), DATA(I+1), WORK2, WORK1,
     A                   DUM(1), ALONG,
     B                   (CENUN(J),J=1,6), (SIUN(J),J=1,6),
     C                   R12,R34,R56,R13,R24,
     D                   (RMTX(J),J=1,13),XL,YL,ZL,THETA,PHI
      GO TO 5000
C
C     SECOND ORDER MATRIX
C
 5000 CONTINUE
      IF (.NOT. SEC) RETURN
      IF (TYPE .GT.  5 .AND. TYPE .NE. 11 .AND. TYPE .NE. 18 .AND.
     A    TYPE .NE. 19 .AND. TYPE .NE. 20 .AND. TYPE .NE. 21) RETURN
      WRITE(0,2000) TYPE,ALONG,LABEL(NUM),TOTROT,(SRMTX(J),J=1,105)
 2000 FORMAT(109A4)
C
      RETURN
      END

      SUBROUTINE LAYOUT(XL,YL,ZL,THETA,PHI)
C
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
      COMMON /BLOC32/ UNIT(11)
C
      DATA PI /3.141592654/
C
      IF (LAY) THEN
       THETA = ATAN(O(4,3,1) / O(4,3,3))
       IF (O(4,3,3) .GE. 0.0) GO TO 72
       SHIFT = SIGN(PI,O(4,3,1))
       THETA = SHIFT - THETA
   72  THETA = THETA / UNIT(7)
       PHI = ASIN(O(4,3,2)) / UNIT(7)
       XL =  X0(4,1)/UNIT(8)
       YL =  X0(4,2)/UNIT(8)
       ZL =  X0(4,3)/UNIT(8)
      ELSE
       THETA = 7777.7
       PHI   = 0.0
       XL    = 0.0
       YL    = 0.0
       ZL    = 0.0
      ENDIF
C
      RETURN
      END

      SUBROUTINE PRINT1 (LABEL,NWORD,DATA,VARY)
C     PRINT DATA FOR ONE ELEMENT
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
      CHARACTER*1 CHAR(12), CAR(24), KAR(12)
      CHARACTER*4 LABEL
      EQUIVALENCE (CHAR,CAR), (KAR,CAR(13))
      INTEGER     VARY(30), NV(25)
      REAL        DATA(30)
      DATA NV/6,1,1,3,3,0,6,6,0,1,0,15,0,6,0,2,0,2,2,1,2,0,1,0,0/
C
      NTYPE = DATA(1)
      KTYPE = IABS(NTYPE)
      IF (KTYPE .EQ. 15) GO TO 50
      DO 10 J = 1, 24
   10 CAR(J) = BLANK
      IF(NTYPE .LE. 0) GO TO 40
      KV = 1
      IF (NTYPE .LE. 21) KV = NV(NTYPE)
      IF (KV .EQ. 0) GO TO 40
      LV = 0
      DO 30 JV = 1, KV
      K = IABS(VARY(JV+1))
      IF (VARY(JV+1) .GE. 0) GO TO 20
      LV = LV + 1
      CAR(LV) = MINUS
   20 LV = LV + 1
   30 CAR(LV) = TABLE(K + 1)
      IF(NTYPE .EQ. 12) GO TO 70
   40 IF(NWORD .LE. 1) GO TO 60
      IF(NWORD .LE. 9) GO TO 55
      WRITE (NOUT, 940) NTYPE, CHAR, LABEL,
     A                  (BLANK, DATA(J), J = 2, NWORD), SEMI(1)
      RETURN
   55 WRITE (NOUT, 945) NTYPE, CHAR, LABEL,
     A                  (BLANK, DATA(J), J = 2, NWORD), SEMI(1)
      RETURN
   50 III = DATA(3)
      WRITE (NOUT, 950) NTYPE, LABEL, DATA(2), DSTOR(III), DATA(4)
      RETURN
   60 WRITE (NOUT, 960) NTYPE, CHAR, LABEL
      RETURN
   70 IF(NWORD .LE. 1) GO TO 80
      WRITE(NOUT,970) NTYPE,CHAR,LABEL,
     A                (BLANK,DATA(J),J = 2, 9 ) , BLANK
      WRITE(NOUT,971) KAR,(BLANK,DATA(J),J = 10, 16) , SEMI(1)
      RETURN
   80 WRITE(NOUT,960) NTYPE,CHAR,LABEL
      WRITE(NOUT,981) KAR
      RETURN
C
  940 FORMAT(I5,'.',12A1,' "',A4,'" ',A1,8(F11.5,A1),/,
     A       (27X,8(F11.5,A1)))
  945 FORMAT(I5,'.',12A1,' "',A4,'" ',A1,8(F11.5,A1))
  950 FORMAT(I5,'.',13X,'"',A4,'" ',F12.5,'      "',A4,'"',
     A       F12.5,' =')
  960 FORMAT(I5,'.',12A1,' "',A4,'" ;')
  970 FORMAT(I5,'.',12A1,' "',A4,'" ',A1,8(F11.5,A1))
  971 FORMAT(6X,12A1,8X,A1,7(F11.5,A1))
  981 FORMAT(6X,12A1)
      END
      SUBROUTINE QEO
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC4/ LC, TOTANG, LCV(20)
      REAL LC, LCV
      COMMON /BLOC18/ SIT(6,6), CEN(6), RECENT
      LOGICAL RECENT
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC38/ MOR,TOR,ANIN,NPFR
      LOGICAL MOR,TOR,ANIN
      COMMON /BLOC60/ ALONG, CENUN(6), SIUN(6), R12, R34, R56, R13, R24,
     A                RMTX(13), SRMTX(105), PLOT, TOTROT
      LOGICAL PLOT
      LOGICAL PRINT
      REAL OUTPUT(6), POS(3), SIO(6)
C
C     CUMULATIVE LENGTH AND BEAM SIZE
C
      ALONG  =  LC/ UNIT(8)
      IF (.NOT. RECENT) CALL BEAM
      IF (CDB .EQ. 1) PRINT = FORMIO .AND. .NOT. TOR
      IF (CDB .EQ. 0) PRINT = FORMIO .AND. .NOT. TOR .AND. NOR
C
C     PRINT BEAM PARAMETERS
C
      DO 10 J = 1, 6
      SIO(J) = SQRT( MAX( 0.0, SIT(J,J) - CEN(J) **2 ) )
   10 CONTINUE
      SIUN(1) = SIO(1)/UNIT(1)
      CENUN(1) = CEN(1)/UNIT(1)
      IF (LAY) GO TO 20
      IF (PRINT)
     A WRITE (NOUT,1016) ALONG, XDIME(8), CENUN(1), SIUN(1), XDIME(1)
      GO TO 30
   20 DO 21 J = 1, 3
   21 POS(J) = X0(4,J)/UNIT(8)
      IF (PRINT) WRITE (NOUT,1015)
     A       ALONG, XDIME(8), POS, XDIME(8), CENUN(1), SIUN(1), XDIME(1)
C
   30 DO 40 J = 2, 6
      JMIN1 = J - 1
      SIUN(J) = SIO(J) / UNIT(J)
      CENUN(J)  =  CEN(J) / UNIT(J)
      DO 35 K = 1, JMIN1, 1
      OUTPUT(K) = (SIT(J,K) - CEN(J) * CEN(K)) / ( DEN(SIO(J) * SIO(K)))
   35 CONTINUE
      IF(J.EQ.2) R12=OUTPUT(1)
      IF(J.EQ.4) R34=OUTPUT(3)
      IF(J.EQ.6) R56=OUTPUT(5)
      IF(J.EQ.3) R13=OUTPUT(1)
      IF(J.EQ.4) R24=OUTPUT(2)
      IF (PRINT) WRITE (NOUT,1014)
     1           CENUN(J),SIUN(J),XDIME(J),(OUTPUT(K), K = 1,JMIN1)
   40 CONTINUE
      RETURN
C
 1016 FORMAT(F11.3,1X,A4,56X,2F8.3,1X,A4)
 1015 FORMAT(' ',F10.3,1X,A4,4X,'*COORDINATES*',3F10.3,1X,A4,F12.3,
     A       F8.3,1X,A4)
 1014 FORMAT(72X,2F8.3,1X,A4,F9.3,4F7.3)
      END
      SUBROUTINE RCALC (NR)
      COMMON /BLOC11/ R(6,6), RV(6,6), T(6,6,6), TV(6,6,6)
      COMMON /BLOC12/ RC(6,6), RCV(6,6,20), TC(6,6,6), RCP, RVP(20)
      LOGICAL RCP, RVP
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     A                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC15/ RS(6,6), RT(6,6), TS(6,6,6), TT(6,6,6)
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      COMMON /BLOC48/ MPS, DRIFT
      LOGICAL DRIFT
C
      IF(NR - 1) 300, 1, 10
    1 IF(RCP) GO TO 100
C
C     DESIRED MATRIX EQUALS R2 MATRIX
C
   10 CALL UCOPY(RC2,RS,36)
      IF (SEC) CALL UCOPY(TC2,TS,216)
      RETURN
C
C     DESIRED MATRIX EQUALS RC MATRIX
C
  100 IF (R2P) GO TO 200
      CALL UCOPY(RC,RS,36)
      IF (SEC) CALL UCOPY(TC,TS,216)
      RETURN
C
C     DESIRED MATRIX EQUALS RC2 TIMES RC
C
  200 DRIFT = .FALSE.
      IF (SEC) CALL MTMPLY(RS,TS,RC2,TC2,RC,TC)
      IF (.NOT.SEC) CALL CABF(RS,RC2,RC)
      RETURN
C
C     DESIRED MATRIX EQUALS R MATRIX (INDIVIDUAL ELEMENT)
C
  300 CALL UCOPY(R,RS,36)
      IF (SEC) CALL UCOPY(T,TS,216)
      RETURN
      END
      SUBROUTINE RCO (NR)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC15/ RS(6,6), RT(6,6), TS(6,6,6), TT(6,6,6)
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     1 SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      COMMON /BLOC38/ MOR,TOR,ANIN,NPFR
      LOGICAL MOR,TOR,ANIN
      COMMON /BLOC60/ ALONG, CENUN(6), SIUN(6), R12, R34, R56, R13, R24,
     A                RMTX(13), SRMTX(105), PLOT, TOTROT
      LOGICAL PLOT
      REAL OUT(6,6), OUTPUT(6,6,6)
      EQUIVALENCE (OUT(1,1),OUTPUT(1,1,1))
      LOGICAL PRINT, ALREDY
C
      PRINT = FORMIO .AND. .NOT. TOR
      ALREDY = .NOT. MOR .AND. CDB .EQ. 4
      CALL RCALC (NR)
      IF(NR .NE. 0) GO TO 100
C
C     ARBITRARY MATRIX
C
      IF (.NOT. PRINT) RETURN
      WRITE (NOUT, 1002)
      DO 2 J = 1, 6
      DO 1 K = 1, 6
      OUT(J,K) = RS(J,K) * UNIT(K) / UNIT(J)
    1 CONTINUE
      WRITE (NOUT,1003) (OUT(J,K), K = 1, 6)
    2 CONTINUE
      IF (SEC) GO TO 7
      RETURN
C
C     PREPARE RMTX FOR PLOTFL
C
  100 DO 10 J = 1, 6
      DO 10 K = 1, 6
      OUT(J,K) = RS(J,K) * UNIT(K) / UNIT(J)
   10 CONTINUE
      IF (CDB.EQ.24) GO TO 5
      IND = 0
      IROT = ABS(TOTROT)
      IF (IROT .EQ. 90) IND = 2
      RMTX(1)=OUT(1,1+IND)
      RMTX(2)=OUT(1,2+IND)
      RMTX(3)=OUT(1,6)
      RMTX(4)=OUT(2,1+IND)
      RMTX(5)=OUT(2,2+IND)
      RMTX(6)=OUT(2,6)
      RMTX(7)=OUT(3,3-IND)
      RMTX(8)=OUT(3,4-IND)
      RMTX(9)=OUT(3,6)
      RMTX(10)=OUT(4,3-IND)
      RMTX(11)=OUT(4,4-IND)
      RMTX(12)=OUT(4,6)
      RMTX(13)=OUT(6,6)
    5 CONTINUE
C
C     PRINT FIRST ORDER TRANSFER MATRIX IF NOT DONE PERMANENTLY
C
      IF (MOR .AND. CDB .EQ. 0) GO TO 15
      IF (PRINT .AND. .NOT. ALREDY) THEN
      WRITE (NOUT, 1004) NR
      DO 20 J = 1, 6
      WRITE (NOUT,1003) (OUT(J,K), K = 1, 6)
   20 CONTINUE
      END IF
   15 IF (.NOT. SEC) RETURN
C
C     PREPARE SRMTX FOR PLOTFL
C
      IND = 0
      DO 11 N = 1, 5
      DO 11 J = 1, 6
      Y = SQRT(SI(J,J))
      DO 11 K = 1, J
      X = SQRT(SI(K,K))
      IND = IND + 1
      AUX1 = TS(N,J,K)/UNIT(N)
      AUX2 = AUX1*UNIT(J)*UNIT(K)
      IF (J .NE. K) THEN
      AUX2 = 2.0 * AUX2
      AUX1 = 2.0 * AUX1
      END IF
      OUTPUT(N,J,K) = AUX2
      IF (CDB .EQ. 24) GO TO 11
      SRMTX(IND) = AUX1*X*Y
   11 CONTINUE
      IF (.NOT.PRINT .OR. (CDB .NE. 4 .AND. CDB .NE. 24)) RETURN
C
C     PRINT SECOND ORDER TRANSFER MATRIX
C
    7 WRITE (NOUT,1011)
      DO 8 N = 1, 5
      DO 9 J = 1, 5
      WRITE (NOUT,1009) (N,K,J,OUTPUT(N,J,K), K = 1, J)
    9 CONTINUE
      J=6
      WRITE (NOUT,1010) (N,K,J,OUTPUT(N,J,K), K = 1, J)
    8 CONTINUE
      RETURN
C
 1002 FORMAT (' *ELEMENT MATRIX*')
 1003 FORMAT (11X,6F10.5)
 1004 FORMAT (' *TRANSFORM',I2,'*')
 1009 FORMAT (11X,6(I4,I2,I1,1PE11.3))
 1010 FORMAT (11X,6(I4,I2,I1,1PE11.3)/)
 1011 FORMAT (' *2ND ORDER TRANSFORM*')
      END
      SUBROUTINE RDELMT
C     READ IN DATA FOR ONE ELEMENT
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC41/ LW, FLUSH, INDIC, NTYPE, LENGTH,
     A                NWORD, NVARY, DATUM(30), VARY(30)
      INTEGER VARY
      LOGICAL FLUSH
      COMMON /BLO41A/ IMAGE(80), LABLE
      CHARACTER       IMAGE*1, LABLE*4
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
      COMMON /BLOC43/ NCD, MC, EMPTY
      LOGICAL EMPTY
      COMMON /BLO43A/ CARD(120), ITEM
      CHARACTER*1     CARD, ITEM
      COMMON /FIRST/ FIRST1, FIRST2, FIRST3, FIRST4, SNTNL
      LOGICAL FIRST1, FIRST2, FIRST3, FIRST4, SNTNL
      COMMON /NNN/ NUC
C
      INTEGER NO1(25)
      LOGICAL SEPAR
      CHARACTER*1 IARROW, IWORD(4)
      DATA NO1/8,2,2,4,4,3,7,8,2,5,3,16,2,8,4,3,1,4,3,2,3,5,4,4,5/
      DATA IARROW / '^' /
C
C     SET DEFAULT VALUES
C
   10 DO 20 J = 1, 30
      DATUM(J) = 0.0
   20 VARY (J) = 0
      NWORD = 0
      NVARY = 1
      LABLE = BLANK//BLANK//BLANK//BLANK
C
C     HAS SENTINEL BEEN READ AT PREVIOUS CALL
C
      IF(.NOT. SNTNL) GO TO 30
      SNTNL = .FALSE.
      RETURN
   30 SEPAR = .TRUE.
      CALL RDSKIP
      GO TO 110
C
C     SEPARATORS
C
  100 SEPAR = ITEM .EQ. BLANK
      CALL RDNEXT (- 1)
  110 DO 115 J = 1, 5
      IF(ITEM .EQ. SEMI(J)) GO TO 500
  115 CONTINUE
      DO 120 J = 1, 6
      IF(ITEM .EQ. QUOTE(J)) GO TO 350
  120 CONTINUE
      IF(ITEM .EQ. TABLE(29)) GO TO 450
      IF(SEPAR) GO TO 150
  130 IF (FORMIO) WRITE (NOUT, 9130) CARD, (BLANK, J = 1, MC), IARROW
      CALL MENU(1)
      RETURN
  150 IF(NWORD) 300, 200, 300
C
C     TYPE CODE
C
  200 CALL RDFIX (NTYPE, IFLAG)
      IF(IFLAG .NE. 0) GO TO 130
      NWORD = 1
      DATUM(1) = NTYPE
      NTYPE = IABS(NTYPE)
      IF(ITEM .NE. PERIOD) GO TO 100
C
C     VARY CODES
C
  210 CALL RDNEXT (0)
      IFLAG = 0
      IF(ITEM .EQ. MINUS) GO TO 220
      ISIG = 1
      IF(ITEM .EQ. PLUS(1) .OR. ITEM .EQ. PLUS(2)) GO TO 230
      GO TO 240
  220 ISIG = - 1
  230 CALL RDNEXT (0)
      IFLAG = 1
  240 DO 250 J = 1, 36
      IF(ITEM .EQ. TABLE(J)) GO TO 260
  250 CONTINUE
      IF(IFLAG) 130, 100, 130
  260 IF(NVARY .GE. 30) GO TO 210
      NVARY = NVARY + 1
      VARY(NVARY) = ISIGN(J - 1, ISIG)
      GO TO 210
C
C     DATA VALUE
C
  300 CALL RDFLT (VALUE, IFLAG)
      IF(IFLAG .NE. 0) GO TO 130
      NWORD = NWORD + 1
      IF(NWORD .LE. 30) DATUM(NWORD) = VALUE
      GO TO 100
C
C     LABEL
C
  350 CALL RDSTRG (IWORD, 4, L)
      IF(L.GT.4 .AND. FORMIO) WRITE (NOUT, 9350)
      IF(L.GT.4) L = 4
      SEPAR = .TRUE.
      IF (NWORD .EQ. 2 .AND. NTYPE .EQ. 15) GO TO 360
      IF (LABLE.NE.BLANK .AND. FORMIO) WRITE (NOUT, 9360) LABLE
      DO 355 K = 1, L
       LABLE(K:K) = IWORD(K)
  355 CONTINUE
      GO TO 110
  360 NUC = NUC + 1
      DSTOR(NUC) = BLANK//BLANK//BLANK//BLANK
      DO 370 K = 1, L
       DSTOR(NUC)(K:K) = IWORD(K)
  370 CONTINUE
      DATUM(3) = NUC
      NWORD = 3
      GO TO 110
C
C     SENTINEL
C
  450 EMPTY = .TRUE.
      IF(NWORD .EQ. 0) RETURN
      SNTNL = .TRUE.
      GO TO 502
C
C     CHECK VALIDITY OF ELEMENT JUST READ
C
  500 IF(NWORD .EQ. 0) GO TO 130
      CALL RDNEXT (1)
  502 IF(NTYPE .EQ. 0) GO TO 510
      IF(NTYPE .EQ. 16 .AND. VARY(2) .NE .0) THEN
      IF (FORMIO) WRITE (NOUT, 9660)
      FLUSH = .TRUE.
      GO TO 700
      END IF
      IF(NTYPE .LE. 25) GO TO 530
      IF(NTYPE .LT. 50) GO TO 510
      IF(NTYPE .GT. 53) GO TO 510
  505 IF(NTYPE .EQ. 50) THEN
        LENGTH = 4 ! LOWER AND UPPER LIMITS FOR RANDOM OPTIMIZER
        GO TO 535
      ENDIF
      IF (FORMIO) WRITE (NOUT, 9500)
      IF (FORMIO) CALL PRINT1 (LABLE, NWORD, DATUM, VARY)
      GO TO 10
  510 IF (FORMIO) WRITE (NOUT, 9510)
      FLUSH = .TRUE.
      GO TO 700
  530 LENGTH = NO1(NTYPE)
      IF(NTYPE .NE. 16) GO TO 535
      IF(DATUM(2) .GE. 0.0 .AND. DATUM(2) .LT. 99.5) GO TO 535
      LENGTH = 4
      GO TO 505
  535 IF(NWORD - LENGTH) 600, 700, 550
C
C     DATA OVERFLOW
C
  550 IF(DATUM(9) .NE. 0.0) GO TO 560
      IF(NTYPE .NE. 6) GO TO 555
      IF(DATUM(4) .NE. 0.0) LENGTH = 5
      IF(NWORD - LENGTH) 600, 700, 560
  555 IF(NTYPE .EQ. 1) LENGTH = 9
      IF(NTYPE .EQ. 14) LENGTH = 30
      IF(NWORD - LENGTH) 600, 700, 560
  560 IF (FORMIO) WRITE (NOUT, 9560)
      GO TO 690
C
C     FILL IN INCOMPLETE 15 ELEMENT
C
  600 IF(INDIC .NE. 0) GO TO 700
      IF(NTYPE .EQ. 15) CALL RDUNIT
  690 NWORD = LENGTH
C
C     PRINT OUT
C
  700 IF(FORMIO) THEN
      CALL PRINT1 (LABLE, NWORD, DATUM, VARY)
      END IF
      IF(FLUSH) GO TO 10
      RETURN
C
 9130 FORMAT('0SCANNING STOPS DUE TO ERROR AT POSITION SHOWN BELOW'/
     A       11X,120A1/10X,121A1)
 9350 FORMAT('0NEXT LABEL TRUNCATED TO 4 CHARS.')
 9360 FORMAT('0LABEL "',A4,'" ON NEXT ELEMENT WAS OVERWRITTEN')
 9500 FORMAT('0NEXT ELEMENT IS FOR TURTLE ONLY - IGNORED')
 9510 FORMAT('0NEXT ELEMENT IS ILLEGAL - RUN FLUSHED')
 9560 FORMAT('0DATA LIST FOR NEXT ELEMENT IS TOO LONG')
 9650 FORMAT('0ERROR ON FOLLOWING 15. ELEMENT')
 9660 FORMAT('0ATTEMPT TO VARY 1ST PARAMETER OF 16. CARD - RUN FLUSHED')
      END
      SUBROUTINE RDFIX (IVALUE, IFLAG)
C     READ AN INTEGER
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
      COMMON /BLOC43/ NCD, MC, EMPTY
      LOGICAL EMPTY
      COMMON /BLO43A/ CARD(120), ITEM
      CHARACTER*1     CARD, ITEM
C
      IFLAG = - 1
      IVAL = 0
      IF(ITEM .EQ. MINUS) GO TO 10
      ISIG = 1
      IF(ITEM .EQ. PLUS(1) .OR. ITEM .EQ. PLUS(2)) GO TO 20
      GO TO 30
   10 ISIG = - 1
   20 CALL RDNEXT (0)
   30 DO 40 J = 1, 10
      IF(ITEM .EQ. TABLE(J)) GO TO 50
   40 CONTINUE
      IVALUE = ISIGN (IVAL, ISIG)
      RETURN
   50 IVAL = 10 * IVAL + J - 1
      IFLAG = 0
      GO TO 20
      END
      SUBROUTINE RDFLT (VALUE, IFLAG)
C     READ A FLOATING-POINT NUMBER
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
      COMMON /BLOC43/ NCD, MC, EMPTY
      LOGICAL EMPTY
      COMMON /BLO43A/ CARD(120), ITEM
      CHARACTER*1     CARD, ITEM
C
      IFLAG = - 1
      VAL = 0.0
      NPL = 0
      JPL = 0
      NEX = 0
      IF(ITEM .EQ. MINUS) GO TO 10
      SIG = 1.0
      IF(ITEM .EQ. PLUS(1) .OR. ITEM .EQ. PLUS(2)) GO TO 20
      GO TO 30
   10 SIG = - 1.0
   20 CALL RDNEXT (0)
   30 DO 40 J = 1, 10
      IF(ITEM .EQ. TABLE(J)) GO TO 50
   40 CONTINUE
      IF(ITEM .NE. PERIOD) GO TO 70
      IF(JPL .NE. 0) GO TO 60
      JPL = 1
      FF = 0.1
      GO TO 20
   50 IFLAG = 0
      IF(JPL .NE. 0) GO TO 55
      VAL = 10.0 * VAL + FLOAT(J - 1)
      GO TO 20
   55 VAL = VAL + FF * FLOAT(J - 1)
      FF = 0.1 * FF
      GO TO 20
   60 IFLAG = 1
      GO TO 90
   70 IF(ITEM .NE. TABLE(15)) GO TO 80
      CALL RDNEXT (0)
      CALL RDFIX (NEX, IFLAG)
      GO TO 90
   80 IF(ITEM .EQ. PLUS(1) .OR. ITEM .EQ. PLUS(2) .OR. ITEM .EQ. MINUS)
     A       CALL RDFIX (NEX, IFLAG)
   90 VALUE = SIGN (VAL, SIG)
      IF(NEX .NE. 0) VALUE = VALUE * 10.0 ** NEX
      RETURN
      END
      SUBROUTINE RDNEXT (ISKIP)
C     READ NEXT CHARACTER, OPTIONNALY SKIPPING BLANKS
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC41/ LW, FLUSH, INDIC, NTYPE, LENGTH,
     A                NWORD, NVARY, DATUM(30), VARY(30)
      INTEGER VARY
      LOGICAL FLUSH
      COMMON /BLO41A/ IMAGE(80), LABLE
      CHARACTER       IMAGE*1, LABLE*4
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
      COMMON /BLOC43/ NCD, MC, EMPTY
      LOGICAL EMPTY
      COMMON /BLO43A/ CARD(120), ITEM
      CHARACTER*1     CARD, ITEM
C
      IF (ISKIP .LT. 0) GO TO 40
      IF (ISKIP .GE. 2) GO TO 20
      IF (EMPTY)        GO TO 20
   10 IF (MC .LT. 120)  GO TO 30
      IF (ISKIP .EQ. 0) THEN
       EMPTY = .TRUE.
       ITEM  = BLANK
       RETURN
      ENDIF
   20 MC = 0
      EMPTY = .FALSE.
      READ (NIN, 100, END = 70, ERR = 60) CARD
      NCD  = NCD + 1
   30 MC   = MC + 1
      ITEM = CARD(MC)
      IF (ISKIP .EQ. 0) RETURN
   40 IF (ITEM .EQ. BLANK) GO TO 10
      IF (ITEM.EQ.TABLE(29) .AND. ISKIP.EQ.2) GO TO 50
      RETURN
C
   50 IF (FORMIO) WRITE(NOUT,5000)
      IF (FLUSH) THEN
       CALL MENU(1)
       RETURN
      ELSE
       CALL MENU(0)
       RETURN
      ENDIF
   60 IF (FORMIO) WRITE(NOUT,5001)
      CALL MENU(2)
      RETURN
   70 IF (FORMIO) WRITE(NOUT,5002)
      CALL MENU(1)
      RETURN
C
  100 FORMAT(120A1)
 5000 FORMAT(/' TRANSPORT ENDE')
 5001 FORMAT(' Transport Input_file not found.')
 5002 FORMAT(' Transport Input_file EOF encountered.')
      END
      SUBROUTINE RDSKIP
C     SKIP COMMENTS
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
      COMMON /BLOC43/ NCD, MC, EMPTY
      LOGICAL EMPTY
      COMMON /BLO43A/ CARD(120), ITEM
      CHARACTER*1     CARD, ITEM
C
      CHARACTER*1 LINE(80)
C
   10 IF(ITEM .NE. PAR1(1) .AND. ITEM .NE. PAR1(2)) RETURN
      CALL RDSTRG (LINE, 80, L)
      IF (L.GT.80 .AND. FORMIO) WRITE (NOUT, 100)
      IF (FORMIO) WRITE (NOUT, 110) LINE
      GO TO 10
  100 FORMAT(' NEXT COMMENT TRUNCATED TO 80 CHARS.')
  110 FORMAT(' (',80A1,')')
      END
      SUBROUTINE RDSTRG (STRING, LMAX, L)
C     READ A CHARACTER STRING
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
      COMMON /BLOC43/ NCD, MC, EMPTY
      LOGICAL EMPTY
      COMMON /BLO43A/ CARD(120), ITEM
      CHARACTER*1     CARD, ITEM
C
      CHARACTER*1 STRING(*), CHAR(4), ISTOP
C
      DO 10 L = 1, LMAX
   10 STRING(L) = BLANK
      L = 0
      DO 12 J = 1, 2
       IF(ITEM .EQ. PAR1(J)) GO TO 20
   12 CONTINUE
      DO 14 J = 1, 6
       IF(ITEM .EQ. QUOTE(J)) GO TO 16
   14 CONTINUE
      RETURN
   16 ISTOP = QUOTE(J)
      GO TO 30
   20 ISTOP = PAR2(J)
   30 ISKIP = 1
   40 CALL RDNEXT (ISKIP)
      IF(ITEM .EQ. ISTOP) GO TO 80
      ISKIP = 0
      IF(ITEM .EQ. BLANK .OR. LMAX .EQ. 4) ISKIP = 1
      L = L + 1
      IF (L .LE. LMAX) STRING(L) = ITEM
      IF (ITEM .NE. ISTOP) GO TO 40
   80 CALL RDNEXT (1)
      RETURN
      END
      SUBROUTINE RDUNIT
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC40/ UORIG(11), UNTAB(21)
      COMMON /BLO40A/ XORIG(11), XDTAB(21)
      CHARACTER*4     XORIG,     XDTAB
      COMMON /BLOC41/ LW, FLUSH, INDIC, NTYPE, LENGTH,
     A                NWORD, NVARY, DATUM(30), VARY(30)
      INTEGER VARY
      LOGICAL FLUSH
      COMMON /BLO41A/ IMAGE(80), LABLE
      CHARACTER       IMAGE*1, LABLE*4
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
      CHARACTER*4     TEXT
C
      J = DATUM(2)
      NUC = DATUM(3)
      GO TO (10, 20, 30, 40), NWORD
C
   20 IF(J .EQ. 0) GO TO 10
      IF (FORMIO) WRITE (NOUT, 910)
  910 FORMAT('0BAD 15. CARD FOUND - RUN FLUSHED')
      FLUSH = .TRUE.
      RETURN
C
   10 DATUM(2) = 0.0
      DSTOR(NUC) = BLANK//BLANK//BLANK//BLANK
      DATUM(4) = 0.0
   40 RETURN
C
   30 GO TO (110, 120, 110, 120, 110, 130, 120, 110, 140, 150, 160), J
C
C     UNITS FOR LENGTHS
C
  110 K1 = 1
      K2 = 6
      GO TO 200
C
C     UNITS FOR ANGLES
C
  120 K1 = 7
      K2 = 9
      GO TO 200
C
C     UNITS FOR DP/P
C
  130 K1 = 10
      K2 = 14
      GO TO 200
C
C     UNITS FOR MAGNETIC FLUX DENSITY
C
  140 K1 = 15
      K2 = 17
      GO TO 200
C
C     UNITS FOR PARTICLE MASSES
C
  150 K1 = 18
      K2 = 21
      GO TO 200
C
C     UNITS FOR PARTICLE MOMENTUM
C
  160 K1 = 18
      K2 = 20
C
  200 TEXT = DSTOR(NUC)
      DO 210 K = K1, K2
       IF (TEXT .EQ. XDTAB(K)) GO TO 220
  210 CONTINUE
      IF (FORMIO) WRITE (NOUT, 920) TEXT, J
  920 FORMAT('0UNIT "',A4,'" IS MEANINGLESS ON 15.',I3,
     A       '. CARD - RUN FLUSHED')
      DATUM(4) = 1.0
      FLUSH = .TRUE.
      RETURN
C
  220 DATUM(4) = UNTAB(K) / UORIG(J)
      RETURN
      END
      SUBROUTINE REPEAT
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC3/ TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      INTEGER IC(4), IS(4)
      SAVE    IC,    IS
C      
   10 NREP = DATA(I+1)
      IF(NREP .EQ. 0) GO TO 20
      IP = IP + 1
      IC(IP) = NREP
      IS(IP) = NUM
      GO TO 40
   20 IC(IP) = IC(IP) - 1
      IF(IC(IP) .LE. 0) GO TO 30
      NUM = IS(IP)
      GO TO 40
   30 IP = IP - 1
   40 NUM = NUM + 1
      I = ISTOR(NUM)
      TYPE = DATA(I)
      IF(TYPE .EQ. 9) GO TO 10
      RETURN
      END
      SUBROUTINE RESET(I)
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      DO  1  J =  1,3,1
      X0(I,J) = 0.0
      DO  1   K  =   1,3,1
      O(I,J,K)  =  DELTA(J,K)
    1 CONTINUE
      RETURN
      END
      SUBROUTINE RMAT
C
C     NEW SUBROUTINE FOR SPACE CHARGE . GETS THE R-MATRIX
C     FOR ELEMENTS OF TYPE CODE 3, 4, 5, 18, 19 AND 21.
C
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC3/ TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC4/ LC, TOTANG, LCV(20)
      REAL LC, LCV
      COMMON /BLOC11/ R(6,6), RV(6,6), T(6,6,6), TV(6,6,6)
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC17/ COD(6)
      COMMON /BLOC18/ SIT(6,6), CEN(6), RECENT
      LOGICAL RECENT
      COMMON /BLOC23/ H, AL, NB, BDB, CHARGE, LILENS, EQUAD, EBEND
      REAL NB
      LOGICAL LILENS, EQUAD, EBEND
      COMMON /BLOC24/ B, KQ2, KVK, K2H, K2V, CS, SN, CM1N, J
      REAL KQ2, KVK, K2H, K2V
      COMMON /BLOC25/ AP, CAP, JANET
      LOGICAL CAP
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC33/ FOTILT, SM
      COMMON /BLOC35/ KL, KO, SOLSEG
      REAL KL, KO
      LOGICAL SOLSEG
      COMMON /BLOC38/ MOR,TOR,ANIN,NPFR
      LOGICAL MOR,TOR,ANIN
      COMMON /BLOC48/ MPS, DRIFT
      LOGICAL DRIFT
      COMMON /BLOC62/ RL, EFLAG
      LOGICAL EFLAG
      COMMON/SC/STEP,AMP,BFREQ,GAMMA,CAPPA,IPTFQ,SC1P,SC3P
      LOGICAL SC1P,SC3P
C
      DRIFT = .FALSE.
      IF (TYPE .EQ. 3) GO TO 300
      IF (TYPE .EQ. 4) GO TO 400
      IF (TYPE .EQ. 5) GO TO 500
      IF (TYPE .EQ. 18) GO TO 300
      IF (TYPE .EQ. 19) GO TO 1900
      IF (TYPE .EQ. 21) GO TO 2100
C
C     3. -- DRIFT SPACE
C
  300 R(1,2)  = L
      R(3,4) = L
      DRIFT = .TRUE.
      GO TO 5001
C
C     4. -- BENDING MAGNET
C
  400 CONTINUE
      IF (EBEND) GO TO 420
      IF (.NOT.ANIN) THEN
       B = DATA(I+2) * UNIT(9)
       H = B*CHARGE/RI
       AL = H*L
      ELSE
       AL = DATA(I+2) * UNIT(7)
       H = AL/RL
       B = RI * H / CHARGE
      END IF
      NB = DATA(I+3)
      IF (NB .EQ. 1.0) NB = 1.000001
      TOTANG = TOTANG + AL
      J = 1
      KQ2 = H**2*(1.0 - NB)
      K2H = KQ2
      CALL FOCUS
      SNH = SN
      IF (ABS(K2H*L**2) .GT. 0.0005) GO TO 401
      CM1N = - 0.5*(1.0 - NB)*L**2
      GO TO 402
  401 CM1N = (CS - 1.0)/H**2
  402 CONTINUE
      R(1,6) = - H*CM1N/(1.0 - NB)
      R(5,2) = - R(1,6)
      R(2,6) = H*R(1,2)
      R(5,1) = - R(2,6)
      R(5,6) = - (L - R(1,2))/(1.0 - NB)
      J = 3
      KQ2 = H**2*NB
      K2V = KQ2
      CALL FOCUS
      SN = SNH
      GO TO 5001
C
C     ELECTROSTATIC PRISM
C
  420 CONTINUE
      XL = DATA(I+1) * UNIT(8)
      XAL = DATA(I+2) * UNIT(7)
      AL = (L / XL) * XAL
      NB = DATA(I+3)
      CALL FOCUSE(L,AL,NB)
      TOTANG = TOTANG + AL
      GO TO 5001
C
C     5. -- QUADRUPOLE
C
  500 CONTINUE
      IF (EQUAD) THEN
        B = DATA (I+2) * 3.335641 * 0.0001  ! EFIELD-GRADIENT (KV/CM --> GV/M)
      ELSE
        B = DATA (I+2) * UNIT(9)
      ENDIF
      IF( ABS(B).LT.1.E-10) B=1.E-10
      AP =  DATA(I+3) * UNIT(1)
      J  =  1
      IF (EQUAD) THEN
        GAMMA = SQRT(1.0 + (RI / SM)**2)
        E = RI**2 / ((1. + GAMMA) * SM)
        RIE = E * (1. + GAMMA) / GAMMA
        KQ2 = B * CHARGE /(AP * RIE)
      ELSE
        KQ2 = B * CHARGE /(AP * RI)
      ENDIF
      K2H = KQ2
      CALL FOCUS
      J  =  3
      IF (.NOT. LILENS) THEN
       KQ2  =  - KQ2
      ENDIF
      K2V = KQ2
      CALL FOCUS
      GO TO 5001
C
C     19. -- SOLENOID
C
 1900 B  =  DATA(I+2) * UNIT(9)
      KO = DEN (B * CHARGE / RI)
      IF (RL .NE. 0.) GO TO 1910
C
C     ENTRANCE OR EXIT FRINGE FIELD ALONE (RL=0)
C
      IF (SOLSEG) KO = - KO
      IF (B .NE. 0.) MPS = 0
      R(2,3) = KO / 2.0
      R(4,1) = - R(2,3)
      IF (SOLSEG) THEN
       SOLSEG = .FALSE.
      ELSE
       SOLSEG = .TRUE.
      ENDIF
      GO TO 5001
C
 1910 KL = KO*L
      SN  = SIN(KL)
      CS = COS(KL)
      IF (.NOT.SOLSEG) GO TO 1920
C
C     WITHOUT FRINGE FIELD
C
      R(2,2) = CS
      R(4,4) = R(2,2)
      IF (B .NE. 0.) MPS = 0
      R(1,4) = (1.0 - CS) / KO
      R(3,2) = - R(1,4)
      R(2,4) = SN
      R(4,2) = - R(2,4)
      R(1,2) = SN / KO
      R(3,4) = R(1,2)
      GO TO 5001
C
C     WITH FRINGE FIELD
C
 1920 R(4,4)  =  0.5 + 0.5*CS
      R(3,3)   = R(4,4)
      R(2,2)   = R(4,4)
      R(1,1)   = R(4,4)
      IF (B .NE. 0.) MPS = 0
      R(1,4)    =   (1.- CS)/KO
      R(3,2)    =  -R(1,4)
      R(4,1)    =  0.25*KO*(1.- CS)
      R(2,3)    =  -R(4,1)
      R(4,2)    =  -0.5*SN
      R(3,1)    =  R(4,2)
      R(2,4)    =  -R(3,1)
      R(1,3)    =  R(2,4)
      R(3,4)    =  R(1,3)*2./KO
      R(1,2)    =  R(3,4)
      R(4,3)    =  -0.25*KO*SN
      R(2,1)    =  R(4,3)
      GO TO 5001
C
C     21. -- WIEN FILTER
C
 2100 B=DATA(I+2)*UNIT(9)
      IF(SM.NE.0.0) GO TO 2140
      IF (FORMIO) WRITE(NOUT,2130)
 2130 FORMAT(' PARTICLE MASS - IN ELECTRON UNITS - MUST BE GIVEN VIA A 16.
     A CARD BEFORE A 21. CARD IS USED.')
      CALL MENU(1)
      RETURN
 2140 GAMMA=SQRT(1.0+(RI/SM)**2)
      H=B*CHARGE/RI
      J=1
      KQ2=(H/GAMMA)**2
      CALL FOCUS
      R(1,6)=-(1.-CS)/H
      R(2,6)=-SN/GAMMA
      R(3,4)=L
      GO TO 5001
C
C
 5001 R(5,6) = R(5,6)  +  L * SM**2/(RI**2 + SM**2)
      RECENT = .FALSE.
      RETURN
      END
      SUBROUTINE ROTM(  J,  K,  X,  ISBK  )
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      REAL CX(3,3,3), X(6,6)
      DATA  CX /  0. , 0. , 0. , 0. , 0. , 1. , 0. , -1. , 0. , 0. ,
     1   0. , -1. , 0. , 0. , 0. , 1. , 0. , 0. , 0. , 1. , 0. , -1. ,
     2   0. , 0. , 0. , 0. , 0.   /
      DO  1  N = 1,3,1
      S = 0.0
      DO  2  L = 1,3,1
      S1 = 0.0
      DO  3  M = 1,3,1
      S1  =  S1  + O(IR,K,M) * CX(L,M,N)
    3 CONTINUE
      S  =  S  + O(IR,J,L) * S1
    2 CONTINUE
      X( ISBK, 2*N )  =  S
    1 CONTINUE
      RETURN
      END
      SUBROUTINE SECORD
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC3/  TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC5/ VSTOR(20), TIE(NND)
      INTEGER VSTOR, TIE
      COMMON /BLOC5A/ LABEL(NNL), LABM(20)
      CHARACTER       LABEL*4, LABM*4
      COMMON /BLOC11/ R(6,6), RV(6,6), T(6,6,6), TV(6,6,6)
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     1                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC21/ EN, ES, BE, APB(2), LAYL, LAYX, RAB1,RAB2,RINVL
      REAL LAYL, LAYX
      COMMON /BLOC22/ BE1, SB, TB, TB1
      COMMON /BLOC23/ H, AL, NB, BDB, CHARGE, LILENS, EQUAD, EBEND
      REAL NB
      LOGICAL LILENS, EQUAD, EBEND
      COMMON /BLOC24/ B, KQ2, KVK, K2H, K2V, CS, SN, CM1N, J
      REAL KQ2, KVK, K2H, K2V
      COMMON /BLOC25/ AP, CAP, JANET
      LOGICAL CAP
      COMMON /BLOC31/ J1, TYP1
      INTEGER TYP1
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC33/ FOTILT, SM
      COMMON /BLOC35/ KL, KO, SOLSEG
      REAL KL, KO
      LOGICAL SOLSEG
      COMMON /BLOC36/ VARS(4), SEXMAX, SEXLIM
      INTEGER VARS
      LOGICAL SEXLIM
      COMMON /BLOC37/ INT1(2), INT2(2), INT3(2), INT4(2), INT5(2),
     A                INT6(2), INT7(2), INT8(2), INT9(2), INT10(2),
     B                INT11(2)
      REAL INT1, INT2, INT3, INT4, INT5, INT6, INT7, INT8,INT9, INT10,
     A     INT11
      COMMON /BLOC48/ MPS, DRIFT
      LOGICAL DRIFT
      COMMON /BLOC50/ XI1, XI2, XI3
      COMMON /BLOC63/ Z216(216), U36(36)
C
      IF (TYPE .EQ. 14 .AND. TYP1 .EQ. 14) GO TO 1400
      JH = 1
      JU = 3
      SIG = 1.0
      CALL UCOPY(Z216,T,216)
      IF (TYPE .EQ. 50) GO TO 5200
      GO TO (5100,200,300,400,500,5200,5200,5200,5200,5200,5200,5200,
     1       5200,1400,5200,5200,5200,1800,1900,5200,2100,5200,5200,
     2       5200,5200), TYPE
C
C     2. -- POLE FACE ROTATION
C
  200 IF (DATA(I+1) .GE. 1000) GO TO 220
      IF (EBEND) GO TO 5200
      TB2 = TB**2
      SB2 = SB**2
      SB3 = SB2*  SB
      IF(  ES  .EQ.  1. )  GO TO 212
      RABT = RAB2
      GO TO 213
  212 RABT = RAB1
  213 T(JH+1,JH,6) = - H*TB
      T(JU+1,JU,6) = H*TB
      T(JH,JH,JH) = - 0.5*SIG*ES*H*TB2
      T(JH,JU,JU) = 0.5*SIG*ES*H*SB2
      T(JH+1,JH,JH) = SIG*(0.5*H*RABT*SB3
     1 - TB*(NB + 0.5*(1.0 - EN)*TB2)*H**2)
      T(JH+1,JH,JH+1) = SIG*H*ES*TB2
      T(JH+1,JU,JU) = SIG*(H**2*TB*(NB + EN*(0.5 + TB2)
     1 - 0.5*(1.0 - EN)*TB2) - 0.5*H*RABT*SB3)
      T(JH+1,JU,JU+1) = - SIG*H*ES*TB2
      T(JU,1,3) = SIG*H*ES*TB2
      T(JU+1,1,3) = SIG*( - H*RABT*SB3
     1 + H**2*TB*(2.0*NB + (1.0 - EN)*SB2))
      T(JU+1,(JH+1)/2,(JU+5)/2) = - SIG*H*ES*TB2
      T(JU+1,(JU+1)/2,(JH+5)/2) = - SIG*H*ES*SB2
      GO TO 5100
C
C     2. -- FRINGE FOR QUADS
C
  220 AUX = 1. - R(1,1)
      T(1,1,6) =  AUX
      T(2,2,6) = -AUX
      T(3,3,6) = -AUX
      T(4,4,6) =  AUX
      GO TO 5100
C
C     3. -- DRIFT SPACE
C
  300 TANFO = TAN(FOTILT/57.29578)
      IF (TANFO .EQ. 0.) GO TO 310
      DRIFT = .FALSE.
      T(3,1,4) = TANFO/2.
      T(3,4,1) = TANFO/2.
      T(1,1,2) = TANFO/2.
      T(1,2,1) = TANFO/2.
  310 T(5,2,2) = - 0.5*L
      T(5,4,4) = - 0.5*L
      GO TO 520
C
C     4. -- BENDING MAGNET
C
  400 IF (EBEND) GO TO 5200
      IF (H .EQ. 0) GO TO 310
      BEB = BDB/H**2
      CSH = R(JH,JH)
      SKH = - R(JH+1,JH)
      SOKH = R(JH,JH+1)
      CSV = R(JU,JU)
      SKV = - R(JU+1,JU)
      SOKV = R(JU,JU+1)
      DISP = SIG*R(JH,6)
      DDISP = SIG*R(JH+1,6)
      C2 = CSH**2 - SOKH**2*K2H
      S2K = 2.0*SKH*CSH
  420 OM5N = 1.0 - 5.0*NB
  490 T(JH,JH,JH) = SIG*H*(3.0*(3.0*NB - 2.0*BEB - 1.0)
     1 - 4.0*(NB - BEB)*CSH
     A - (5.0*NB - 2.0*BEB - 3.0)*C2)/(12.0*(1.0 - NB))
      T(JH,JH,JH+1) = SIG*H*(4.0*(NB - BEB)*SOKH
     A - 2.0*(5.0*NB - 2.0*BEB - 3.0)*SOKH*CSH)/(6.0*(1.0 - NB))
      T(JH,JH+1,JH+1) = SIG*H*( - 3.0*(3.0*NB - 2.0*BEB - 1.0)*CM1N
     A + (5.0*NB - 2.0*BEB - 3.0)*CSH*CM1N
     B - (5.0*NB - 2.0*BEB - 3.0)*(1.0 - NB)*SOKH**2)/
     C (12.0*(1.0 - NB)**2)
      T(JH+1,JH,JH) = SIG*H*(NB - BEB)*(SKH + 2.0*SKH*CSH)/
     1 (3.0*(1.0 - NB))
      T(JH+1,JH,JH+1) = 2.0*SIG*H*(NB - BEB)*(CSH - C2)/
     1 (3.0*(1.0 - NB))
      T(JH+1,JH+1,JH+1) = SIG*H*((7.0*NB - 4.0*BEB - 3.0)*SOKH/6.0
     A - 2.0*(NB - BEB)*SOKH*CSH/3.0)/(1.0 - NB)
      T(JH,JH,6) = (3.0*( - 3.0*NB + 2.0*BEB + 1.0)
     1 + 4.0*(NB - BEB)*CSH + (5.0*NB - 2.0*BEB - 3.0)*C2
     2 + 3.0*(NB**2 + NB - 2.0*BEB)*L*SKH)/(6.0*(1.0 - NB)**2)
      T(JH,JH+1,6) = ((3.0*NB**2 - 7.0*NB - 2.0*BEB + 6.0)*SOKH
     A + 2.0*(5.0*NB - 2.0*BEB - 3.0)*SOKH*CSH
     B - 3.0*(NB**2 + NB - 2.0*BEB)*L*CSH)/(6.0*(1.0 - NB)**2)
      T(JH,6,6) = SIG*( - H*CM1N*(3.0*(7.0*NB - 6.0*BEB - 1.0)
     A + (5.0*NB - 2.0*BEB - 3.0)*CSH)
     B + ( 5.0*NB - 2.0*BEB - 3.0)*(1.0 - NB)*H*SOKH**2
     C - 6.0*(NB**2 + NB - 2.0*BEB)*L*(1.0 - NB)*H*SOKH)/
     D (12.0*(1.0 - NB)**3)
      T(JH+1,JH,6) = (((3.0*NB**2 - 7.0*NB - 2.0*BEB + 6.0)/6.0)*SKH
     A - (2.0*(NB - BEB)/3.0)*S2K + ((NB**2 + NB - 2.0*BEB)/2.0)*
     B L*K2H*CSH) /(1.0 - NB)**2
      T(JH+1,JH+1,6) = ((2.0*(NB - BEB)/3.0)*( - CSH + C2) +
     A ((NB**2 + NB - 2.0*BEB)/2.0)*L*SKH)/(1.0 - NB)**2
      T(JH+1,6,6) = SIG*H*(( - 3.0*NB**2 + 11.0*NB - 2.0*BEB - 6.0)*SOKH
     A + 4.0*(NB - BEB)*SOKH*CSH
     B + 3.0*( - NB**2 - NB + 2.0*BEB)*L*CSH)/(6.0*(1.0 - NB)**2)
      INT1(1)  =  0.5 * SOKV * L
      INT1(2) = 0.5*(CSV*L + SOKV)
      IF (ABS(K2V*L**2) .GT. 1.0E-4) GO TO 421
      INT2(1)  =  L **3 / 6.
      INT2(2)  =  L **2 / 2.
      GO TO 422
  421 INT2(1) = (SOKV - L*CSV)/(2.0*K2V)
      INT2(2)  =  L * SOKV / 2.
  422 INT3(1) = ( - 2.0*NB*SOKV*SOKH - CSV*CM1N)/OM5N
      INT3(2) = ( - 2.0*NB*(CSV*SOKH + SOKV*CSH) + SKV*CM1N
     A + CSV*SOKH*(1.0 - NB))/OM5N
      INT4(1) = (2.0*CSV*SOKH - SOKV*(CSH + 1.0))/OM5N
      INT4(2) = ( - 2.0*SKV*SOKH + 2.0*CSV*CSH - CSV*(CSH + 1.0)
     A + SOKV*SKH)/OM5N
      INT5(1) = SOKV/(1.0 - NB) + (2.0*SOKV*(CSH + 1.0)*NB/(1.0 - NB)
     A - CSV*SOKH)/OM5N
      INT5(2) = CSV/(1.0 - NB) + (2.0*(CSV*(CSH + 1.0) - SOKV*SKH)
     A *NB/(1.0 - NB) + (SKV*SOKH - CSV*CSH))/OM5N
      INT6(1) = ( - 2.0*CSV*CM1N/(1.0 - NB) - SOKV*SOKH)/OM5N
      INT6(2) = (2.0*(SKV*CM1N/(1.0 - NB) + CSV*SOKH) - CSV*SOKH
     A - SOKV*CSH)/OM5N
  470 INT7(1) = - CM1N/(1.0 - NB)
      INT7(2) = SOKH
      INT8(1) = (CSV*SOKV - SOKH)/OM5N
      INT8(2) = (2.0*CSV**2 - CSH - 1.0)/OM5N
      INT9(1) = (SOKV**2 + 2.0*CM1N/(1.0 - NB))/OM5N
      INT9(2) = 2.0*(CSV*SOKV - SOKH)/OM5N
      INT10(1) = H*SOKV
      INT10(2) = H*CSV
      INT11(1)  =  0
      INT11(2)  =  1.
      DO 480 II = 1, 2
      IH = JH + II - 1
      IV = JU + II - 1
      T(IH,JU,JU) = SIG*H**3*((BEB - 0.5*NB)*INT7(II) - BEB*NB*INT9(II))
      T(IH,JU,JU+1) = 2.0*SIG*H*BEB*INT8(II)
      T(IH,JU+1,JU+1) = SIG*(- 0.5*H*INT7(II) + H*BEB*INT9(II))
      T(IV,1,3) = SIG*( - 2.0*H**3*(NB - BEB)*INT3(II)
     1 + NB*(1.0 - NB)*H**3*INT6(II) + H*CSH*SKV*INT11(II))
      T(IV,(JH+1)/2,(JU+5)/2) = SIG*( - 2.0*H*(NB - BEB)*INT4(II)
     1 - H*(1.0 - NB)*INT5(II) + INT10(II) - H*CSH*CSV*INT11(II))
      T(IV,(JU+1)/2,(JH+5)/2) = SIG*( - 2.0*H*(NB - BEB)*INT5(II)
     1  - H*NB*INT4(II) + H*SOKH*SKV*INT11(II))
      T(IV,2,4) = SIG*( - 2.0*H*(NB - BEB)*INT6(II) + H*INT3(II)
     1 - H*SOKH*CSV*INT11(II))
      T(IV,JU,6) = 2.0*H**2*(NB - BEB)*INT3(II)/(1.0 - NB)
     A - H**2*(2.0*(NB - BEB)/(1.0 - NB) - NB)*INT1(II)
     B - K2V*INT6(II) + H*DISP*SKV*INT11(II)
      T(IV,JU+1,6) = 2.0*(NB - BEB)*INT4(II)/(1.0 - NB)
     A - H**2*(2.0*(NB - BEB)/(1.0 - NB) - NB)*INT2(II)
     B + INT5(II) - H*DISP*CSV*INT11(II)
  480 CONTINUE
      GI2 = SM**2/(SM**2 + RI**2)
      T(5,JH,JH) = - ((NB*(3.0*NB - 1.0) - 2.0*BEB)*(L - SOKH*CSH)
     1 + 4.0*(NB - BEB)*(L - SOKH))*H**2/(12.0*(1.0 - NB))
      T(5,JH,JH+1) = - 2.0*(NB - BEB)*(1.0 - CSH)/(3.0*(1.0 - NB)**2)
     1 - (NB*(1.0 - 3.0*NB) + 2.0*BEB)*H**2*SOKH**2/(6.0*(1.0 - NB))
      T(5,JH,6) = SIG*( - (NB*(NB + 1.0) - 2.0*BEB)*H*(SOKH - L*CSH)/
     1 (2.0*(1.0 - NB)**2)
     2 + 2.0*(NB - BEB)*H*(L - SOKH)/(3.0*(1.0 - NB)**2)
     3 + (NB*(3.0*NB - 1.0) - 2.0*BEB)*H*(L - SOKH*CSH)/
     4 (6.0*(1.0 - NB)**2) + GI2*DDISP)
      T(5,JH+1,JH+1) = - (2.0*(7.0*NB - 4.0*BEB - 3.0)*(L - SOKH)
     1 - (5.0*NB - 2.0*BEB - 3.0)*(L - SOKH*CSH))/(12.0*(1.0 - NB)**2)
     2 - 0.25*(L + SOKH*CSH)
      T(5,JH+1,6) = SIG*((3.0*NB**2 - 2.0*NB - 4.0*BEB + 3.0)*H*
     1 CM1N/(3.0*(1.0 - NB)**3)
     2 + ((NB**2 + NB - 2.0*BEB)*H*L*SOKH/2.0
     3 - (3.0*NB**2 - NB - 2.0*BEB)*H*SOKH**2/6.0)/(1.0 - NB)**2
     4 + GI2*DISP)
      T(5,6,6) = - (4.0*(NB - BEB)*(L - SOKH)/3.0
     1 - (NB*(1.0 + NB) - 2.0*BEB)*(SOKH - L*CSH)/2.0
     2 + (3.0*NB**2 - NB - 2.0*BEB)*(L - CSH*SOKH)/12.0)/(1.0 - NB)**3
     3 + GI2*(L - SOKH)
      T(5,JU,JU) = - (2.0*BEB*(1.0 - 3.0*NB)/OM5N - NB)*H**2
     1 *(L - SOKH)/(2.0*(1.0 - NB))
     2 - ( - 2.0*BEB/OM5N + NB)*H**2*(L - SOKV*CSV)/4.0
      T(5,JU,JU+1) = - (BEB/OM5N - 0.5*NB)*H**2*SOKV**2
     1 + 2.0*BEB*(1.0 - CSH)/(OM5N*(1.0 - NB))
      IF (NB .NE. 0.0) GLOP = (L - SOKV*CSV)/(2.0*NB)
      IF (NB .EQ. 0.0) GLOP = H**2*L**3/3.0
      T(5,JU+1,JU+1) = - BEB*(GLOP
     1 - 2.0*(L - SOKH)/(1.0 - NB))/OM5N
     2 + (L - SOKH)/(2.0*(1.0 - NB)) - 0.25*(L + SOKV*CSV)
      GO TO 5000
C
C     5. -- QUADRUPOLE
C
  500 J = 1
      KQ2 = K2H
  510 CS =  R(J,J)
      SK  =  -R(J+1,J)
      SOK  =  R(J,J+1)
      AUX = 0.25 * SK * L
      T(J,J,6) = AUX
      T(J,6,J) = AUX
      T(J+1,J+1,6) = AUX
      T(J+1,6,J+1) = AUX
      AUX = 0.25 * (SOK - L*CS)
      T(J,J+1,6) = AUX
      T(J,6,J+1) = AUX
      AUX = 0.25 * (SK + KQ2*L*CS)
      T(J+1,J,6) = AUX
      T(J+1,6,J) = AUX
      T(5,J,J) = - 0.25*(KQ2*L + R(J+1,J)*R(J+1,J+1))
      AUX = - 0.25 * R(J,J+1) * R(J+1,J)
      T(5,J,J+1) = AUX
      T(5,J+1,J) = AUX
      T(5,J+1,J+1) = - 0.25*(L + R(J,J)*R(J,J+1))
      IF (J .NE. JH) GO TO 520
      J = 3
      IF (.NOT. LILENS) THEN
       KQ2 = K2V
      ENDIF
      GO TO 510
C
  520 IF (SM .EQ. 0.) RETURN
c      T(5,6,6) = - L*(SM**2 + 1.5*RI**2)*SM**2/(SM**2 + RI**2)**2
c      AUX = 0.5 * SM**2/(SM**2 + RI**2)
c      T(5,5,6) = AUX
c      T(5,6,5) = AUX
C
C      NEW: from SLAC version 1.6 (George Gillespie, e-mail: 11-Sept-2007)
C
       GAMMA = SQRT(1.0 + (RI/SM)**2)
       BETA = SQRT(1.0 - 1.0 / GAMMA**2)
       GI2 = 1.0 / (GAMMA**2)
       T(5,6,6) = - 1.5 * L * BETA**2 * GI2
       T(5,5,6) = 0.0
       T(5,6,5) = 0.0
      RETURN
C
C     14. -- ARBITRARY MATRIX
C
 1400 IF (DATA(I+8) .NE. 0.0) GO TO 1420
      IX = I + 9
      DO 1410 J = 1, 6
      DO 1410 K = J, 6
      T(J1,J,K) = DATA(IX)*UNIT(J1)/(UNIT(J)*UNIT(K))
      IX = IX + 1
 1410 CONTINUE
 1420 IF(NUM+1.GT.NEL)GO TO 5100
      IPNOTY=ISTOR(NUM+1)
      IF (IFIX(DATA(IPNOTY)) .EQ. 14) RETURN
      GO TO 5100
C
C     18. -- SEXTUPOLE
C
 1800 VARS(4) = TIE(I+2)
      B  =  DATA(I+2) * UNIT(9)
      AP  =  DATA(I+3) * UNIT(1)
      W2  =  2. * B * CHARGE /(RI * AP **2  )
      S  =  -W2 * (L / 2.) **2
      T(JH,JH,JH) = SIG*S
      T(JH+1,JH,JH) = 2.0*SIG*S/L
      S  =  -W2 * L **4 / 24.
      T(JH,JH+1,JH+1) = SIG*S
      T(JH+1,JH+1,JH+1) = 4.0*SIG*S/L
      S  =  W2 * (L / 2.) **2
      T(JH,JU,JU) = SIG*S
      T(JH+1,JU,JU) = 2.0*SIG*S/L
      S  =  W2 * L **4 / 24.
      T(JH,JU+1,JU+1) = SIG*S
      T(JH+1,JU+1,JU+1) = 4.0*SIG*S/L
      S  =  -W2 * L **3 / 6.
      T(JH,JH,JH+1) = SIG*S
      T(JH+1,JH,JH+1) = 3.0*SIG*S/L
      S  =  W2 * L **3 / 6.
      T(JH,JU,JU+1) = SIG*S
      T(JH+1,JU,JU+1) = 3.0*SIG*S/L
      S  =  W2 * L **2 / 2.
      T(JU,1,3) = SIG*S
      T(JU+1,1,3) = 2.0*SIG*S/L
      S  =  W2 * L **3 / 6.
      T(JU,(JU+1)/2,(JH+5)/2) = SIG*S
      T(JU,(JH+1)/2,(JU+5)/2) = SIG*S
      T(JU+1,(JU+1)/2,(JH+5)/2) = 3.0*SIG*S/L
      T(JU+1,(JH+1)/2,(JU+5)/2) = 3.0*SIG*S/L
      S  =  W2 * L **4 / 12.
      T(JU,2,4) = SIG*S
      T(JU+1,2,4) = 4.0*SIG*S/L
      T(5,2,2) = - 0.5*L
      T(5,4,4) = - 0.5*L
      GO TO 5000
C
C     19. -- SOLENOID
C
 1900 B  =  DATA(I+2) * UNIT(9)
      TEMP = 0.5*KO*L*SN
      T(1,1,6) = TEMP
      T(2,2,6) = TEMP
      T(3,3,6) = TEMP
      T(4,4,6) = TEMP
      T(1,2,6) = SN/KO - L*CS
      T(3,4,6) = T(1,2,6)
      TEMP = - 0.5*KO*L*CS
      T(1,3,6) = TEMP
      T(2,4,6) = TEMP
      T(4,2,6) = - TEMP
      T(3,1,6) = - TEMP
      T(1,4,6) = (1.0 - CS)/KO - L*SN
      T(3,2,6) = - T(1,4,6)
      T(2,1,6) = 0.25*KO*(KO*L*CS + SN)
      T(4,3,6) = T(2,1,6)
      T(2,3,6) = 0.25*KO*(1.0 - CS + KO*L*SN)
      T(4,1,6) = - T(2,3,6)
      T(5,2,2) = - 0.5*L
      T(5,4,4) = - 0.5*L
      GO TO 5000
C
C     WIEN FILTER TREATED AS DUMMY DRIFT
C
 2100 T(5,2,2) = - 0.5*L
      T(5,4,4) = - 0.5*L
      GO TO 520
C
C     PATH LENGTH TERMS
C
 5000 IF (SM .NE. 0.) THEN
c      T(5,6,6) = T(5,6,6) - L*(SM**2 + 1.5*RI**2)*SM**2/
c     1 (SM**2 + RI**2)**2
c      T(5,5,6) = SM**2/(SM**2 + RI**2)
C
C      NEW: from SLAC version 1.6 (George Gillespie, e-mail: 11-Sept-2007)
C
       GAMMA = SQRT(1.0 + (RI/SM)**2)
       BETA = SQRT(1.0 - 1.0 / GAMMA**2)
       GI2 = 1.0 / (GAMMA**2)
       T(5,6,6) = T(5,6,6) - 1.5 * L * BETA**2 * GI2
       T(5,5,6) = 0.0
      END IF
C
C     CHANGE TRIANGULAR MATRIX INTO SQUARE MATRIX
C
 5100 DO 5110 IA = 1, 5
      DO 5110 IB = 1, 5
      IBP1 = IB + 1
      DO 5110 IC = IBP1, 6
      T(IA,IB,IC) = 0.5*T(IA,IB,IC)
      T(IA,IC,IB) = T(IA,IB,IC)
 5110 CONTINUE
 5200 CONTINUE
      RETURN
      END
      SUBROUTINE SHFT
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC17/ COD(6)
      COMMON /BLOC18/ SIT(6,6), CEN(6), RECENT
      LOGICAL RECENT
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
C
C     CHANGE IN SIGMA MATRIX
C
      DO 10 J = 1, 6
      DO 10 K = 1, J
      SI(J,K) = SI(J,K) + COD(J)*COD(K)
      SI(K,J) = SI(J,K)
   10 CONTINUE
      IF (.NOT. S1P) GO TO 50
      DO 20 J = 1, 6
      DO 20 K = 1, J
      SI(J,K) = SI(J,K) + COD(J)*CO(K) + CO(J)*COD(K)
      SI(K,J) = SI(J,K)
   20 CONTINUE
C
C     CHANGE IN BEAM CENTROID
C
   50 IF (S1P) GO TO 70
      CALL UCOPY(COD,CO,6)
      GO TO 100
   70 CALL MADD(CO,COD,6)
  100 S1P = .TRUE.
      RECENT = .FALSE.
      SOFA = .TRUE.
      RETURN
      END
      REAL FUNCTION  SIGNF(X)
      INTEGER X
      IF(X) 1,2,1
    1 SIGNF  =  ISIGN(1 , X)
      RETURN
    2 SIGNF  =  0.
      RETURN
      END
      SUBROUTINE SOLVE
C
C     CANCELLATION AFTER ITER STEPS BUILT IN BY URS ROHRER (PSI)
C     JANUARY 17, 1990
C
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC29/ A(21), CW, CA(21,21), SCALE(21), CASAV(21,21),
     1                PMARQ, CHSMIN, XNORM, GNORM, EPS
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      COMMON /BLOC49/ NL, FAILED, ITER
      LOGICAL FAILED
      COMMON /BLO49A/ LABS(20)
      CHARACTER       LABS*4
      LOGICAL OK
      REAL CS(21)
      REAL OUTPUT(20)
C
      FAILED = .FALSE.
      IF (FORMIO) WRITE (NOUT,1000)
 1000 FORMAT('0*CORRECTIONS*')
C
C     INITIALIZE VARIABLES AND MAKE FIRST PASS
C
      NSTEP = 0
      OK = .FALSE.
      NV2 = 0
      CHSMIN = - 1.0
      CALL FORM
      N1P1 = NV1 + 1
      NMAR = 0
      PAR = 0.0
      PMARQ = PAR
      IF (LINEAR) GO TO 100
      CRIT = MAX(1,NC-NV1)
C
C     ITERATE FROM HERE IF NEW LOW CHI-SQUARED FOUND
C
   20 NSTEP = NSTEP + 1
      IF (NSTEP .GT. ITER) GO TO 205
      CS(1) = CA(1,1)
      IF (CA(1,1) .LT. CRIT) GO TO 100
      IF (NMAR .EQ. 0) PMARQ = 0.0
      IF (NMAR .GE. 1) PMARQ = PAR*(2.0**NMAR - 1.0)
      CALL INQ
      IF (NMAR .NE. 0) GO TO 35
      PAR = PMARQ
      PMARQ = 0.0
   35 DO 40 J = 2, N1P1
   40 CS(J) = CA(J,1)
      EPS = 0.5**NMAR
      CALL ALTER(CS)
      DSS = 0.0
      DO 42 J = 2, N1P1
   42 DSS = DSS + CASAV(J,1)*CS(J)
      DSM = 0.0
      DO 45 J = 2, N1P1
      DMX = 0.0
      DO 44 K = 2, N1P1
   44 DMX = DMX + CASAV(J,K)*CS(K)
   45 DSM = DSM + DMX*CS(J)
      DSS = 2.0*DSS - DSM
      GOLD = GNORM
      CALL FORM
      CRIT = MAX(1,NC-NV1)
      IF (CA(1,1) .LT. CRIT) GO TO 100
      IF (DSS .EQ. 0.0) GO TO 200
C
C     REFERENCE ON WHEN TO CHANGE RELAXATION FACTOR
C     KLAUS HALBACH, PAPER AT SECOND INTERNATIONAL
C     CONFERENCE ON MAGNET TECHNOLOGY AT OXFORD 1967
C
      R = (CS(1) - CA(1,1))/DSS
      IF (R .GT. 0.8 .AND. DSS .LT. MIN(0.1*CA(1,1),CRIT)
     1 .AND. NMAR .EQ. 0) GO TO 100
      IF (DSS .LT. CRIT .AND. GNORM .LT. 0.1*GOLD) GO TO 100
   60 IF (R .GT. 0.75) NMAR = MAX(0,NMAR-1)
      IF (R .GT. 0.25) GO TO 20
   80 IF (NMAR .GT. 6 .AND. (XNORM .LT. 0.00001 .OR. PMARQ .GT. 0.5))
     1 GO TO 200
      NMAR = NMAR + 1
      IF (R .GT. 0.0) GO TO 20
      NSTEP = NSTEP + 1
      IF (NSTEP .GT. ITER) GO TO 205
   90 DO 92 J = 2, N1P1
      DO 92 K = 1, N1P1
   92 CA(J,K) = CASAV(J,K)
      IF (NMAR .EQ. 0) PMARQ = 0.0
      IF (NMAR .GE. 1) PMARQ = PAR*(2.0**NMAR - 1.0)
      CALL INQ
      IF (NMAR .EQ. 0) PAR = PMARQ
      DO 95 J = 2, N1P1
   95 CS(J) = - CS(J) + CA(J,1)
      EPS = -0.5**NMAR
   97 CALL ALTER(CS)
      DO 98 J = 2, N1P1
   98 CS(J) = CA(J,1)
      CALL FORM
      CRIT = MAX(1,NC-NV1)
      IF (OK) GO TO 210
      IF (CA(1,1) .LT. CRIT) GO TO 100
      IF (CA(1,1) - CS(1)) 20, 80, 80
C
C     FITTING PROCEDURE SATISFIES CONVERGENCE TEST
C
  100 OK = .TRUE.
      NSTEP = NSTEP + 1
      IF (NSTEP .GT. ITER) GO TO 205
      IF (NMAR .EQ. 0) PMARQ = 0.0
      IF (NMAR .GE. 1) PMARQ = PAR*(2.0**NMAR - 1.0)
      CALL INQ
      DO 140 J = 2, N1P1
  140 CS(J) = CA(J,1)
      EPS = 0.5**NMAR
      CALL ALTER(CA)
      CALL FORM
      IF (LINEAR) GO TO 210
      IF (CA(1,1) .LT. CS(1)) GO TO 210
      DO 145 J = 2, N1P1
  145 CS(J) = - CS(J)
      NSTEP = NSTEP + 1
      IF (NSTEP .GT. ITER) GO TO 205
      GO TO 97
C
C     CONCLUSION OF FITTING - PRINT OUT RESULT
C
  200 IF (FORMIO) WRITE (NOUT,1012)
 1012 FORMAT('0*FAILED*')
      GO TO 209
  205 IF (FORMIO) WRITE (NOUT,1014) ITER
 1014 FORMAT('0*CANCELLED AFTER',I3,' STEPS*')
  209 FAILED = .TRUE.
C
  210 PMARQ = 0.0
      CALL INQ
      IF (FORMIO) WRITE (NOUT,1013) CA(1,1)
 1013 FORMAT('0*COVARIANCE* (FIT',E12.5,')')
      IF (NV1 .LT. 1) GO TO 310
      DO 250 J = 2, N1P1
      IF (CA(J,J) .LT. 0.0) CA(J,J) = 0.0
      CA(1,J)  =  SQRT( CA(J,J)  )
  250 CONTINUE
      DO 300 J = 2, N1P1
      JMIN1 = J - 1
      IF (J .GE. 3) GO TO 270
      IF (FORMIO) WRITE (NOUT,1020) CA(1,J)
      GO TO 300
  270 DO 280 K = 2, JMIN1
      OUTPUT(K)  =  CA(J,K) /(DEN(CA(1,J) * CA(1,K)) )
  280 CONTINUE
      IF (FORMIO) WRITE (NOUT,1020) (OUTPUT(K), K = 2, JMIN1), CA(1,J)
 1020 FORMAT(1X,10F12.3)
  300 CONTINUE
  310 RETURN
      END
      SUBROUTINE SPACEC
C
C     NEW SUBROUTINE FOR SPACE CHARGE. COMPUTES R MATRIX
C
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC3/ TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC4/ LC, TOTANG, LCV(20)
      REAL LC, LCV
      COMMON /BLOC11/ R(6,6), RV(6,6), T(6,6,6), TV(6,6,6)
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     A                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC14/ RC3(6,6), TC3(6,6,6), R3P
      LOGICAL R3P
      COMMON /BLOC15/ RS(6,6),RT(6,6), TS(6,6,6), TT(6,6,6)
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC18/ SIT(6,6), CEN(6), RECENT
      LOGICAL RECENT
      COMMON /BLOC23/ H, AL, NB, BDB, CHARGE, LILENS, EQUAD, EBEND
      REAL NB
      LOGICAL LILENS, EQUAD, EBEND
      COMMON /BLOC24/ B, KQ2, KVK, K2H, K2V, CS, SN, CM1N, J
      REAL KQ2, KVK, K2H, K2V
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
      COMMON /BLOC35/ KL, KO, SOLSEG
      REAL KL, KO
      LOGICAL SOLSEG
      COMMON /BLOC38/ MOR,TOR,ANIN,NPFR
      LOGICAL MOR,TOR,ANIN
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC48/ MPS, DRIFT
      LOGICAL DRIFT
      COMMON /BLOC60/ ALONG, CENUN(6), SIUN(6), R12, R34, R56, R13, R24,
     A                RMTX(13), SRMTX(105), PLOT, TOTROT
      LOGICAL PLOT
      COMMON /BLOC62/ RL, EFLAG
      LOGICAL EFLAG
      COMMON /BLOC63/ Z216(216), U36(36)
      COMMON/SC/STEP,AMP,BFREQ,GAMMA,CAPPA,IPTFQ,SC1P,SC3P
      LOGICAL SC1P,SC3P,SC4P
      DIMENSION E(6,6),RM(6,6)
      DIMENSION REM1(6,6),REM2(6,6),REM3(6,6)
      LOGICAL REM2P, PRINT
C
C     SC4P=.TRUE. IF CURRENT=0.0
C
      SC4P=CAPPA.EQ.0.
      IF(.NOT.(ALIGN.OR.LAY)) GO TO 100
      IF (FORMIO) WRITE(NOUT,1001)
 1001 FORMAT('0NO MISALIGNMENT OR LAYOUT WITH SPACE CHARGE')
      CALL MENU(1)
      RETURN
  100 CONTINUE
C
C     REMEMBER L, R2P, RS , RC2 & SIT,  SET R & RM EQ UNITY MATRIX
C
      IF(TYPE.EQ.11) CALL ACINIT(FINV,P0,PGRAD)
      RL = DATA(I+1) * UNIT(8)
      REMLC=LC+RL
      REM2P=R2P
      CALL UCOPY(RS,REM1,36)
      CALL UCOPY(RC2,REM2,36)
      CALL UCOPY(SIT,REM3,36)
      CALL UCOPY(U36,R,36)
      CALL UCOPY(U36,RM,36)
C
C     UPDATE RC2 (FOR BEAM) WHILE RUNNING THROUGH DERIVE
C
      IF(SC3P) GO TO 360
      IF(.NOT.R3P) GO TO 350
      IF(R2P) GO TO 330
      CALL UCOPY(RC3,RC2,36)
      GO TO 350
  330 CALL CAB(RS,RC3,RC2)
      CALL UCOPY(RS,RC2,36)
  350 R2P=.TRUE.
  360 CONTINUE
C
C     DIVIDE INTO MX SEGMENTS OF LENGTH L=STEP (NO DIVISION FOR ACC)
C
      L=SIGN(STEP,RL)
      MX=ABS(RL)/STEP+1.E-6
      IF(MX.LT.1)  GO TO 14
      IF(TYPE.NE.11) CALL RMAT
C     RMAT GENERATES R MATRIX FOR LENGTH L = STEP
C
C     MX TIMES ELEMENT OF LENGTH L
C
      DO 11 K=1,MX
      L=SIGN(STEP,RL)
      OUT=L
      IF(TYPE.EQ.11) CALL ACRMAT(0.0,P0,PGRAD)
      DRIFT = .FALSE.
      IF(TYPE.EQ.3) DRIFT = .TRUE.
      CALL STEPS(R,RM)
C     STEPS UPDATES RM MATRIX, RM = R*RM
      IF (SC4P) GO TO 3
      DRIFT = .FALSE.
      CALL EMAT(E)
      L=0.
      EFLAG = .TRUE.
      CALL STEPS(E,RM)
      EFLAG = .FALSE.
C
C     SUPPRESS OUTPUT WHILE RUNNING THROUGH SOLVE
C
    3 ISAVE2 = IPTFQ
      IF(.NOT.SC3P) GO TO 11
      PRINT = FORMIO .AND. .NOT. TOR
C      IF (.NOT.PRINT) IPTFQ = 1
      IF(MOD(K,IPTFQ) .NE. 0) GO TO 11
      IF (PRINT) WRITE(NOUT,1000) OUT, XDIME(8)
 1000 FORMAT('0*SCINT*',31X,F12.5,1X,A4)
      IF (PLOT .OR. PRINT) THEN
      RECENT=.FALSE.
      CALL QEO
      CALL RCO(1)
      END IF
      IF (.NOT. FORMIO .AND. PLOT) THEN
      ISAVE=TYPE
      TYPE=30
      CALL PLOTFL
      TYPE=ISAVE
      END IF
   11 CONTINUE
      IPTFQ = ISAVE2
C
C     REST OF ELEMENT
C
   14 L=SIGN(1.,RL)*(ABS(RL)-FLOAT(MX)*STEP)
C      IF(L.LT.1.E-6 .AND. TYPE.NE.11) GO TO 4
      CALL UCOPY(U36,R,36)
      IF(TYPE.NE.11) CALL RMAT
      IF(TYPE.EQ.11) CALL ACRMAT(FINV,P0,PGRAD)
      DRIFT = .FALSE.
      IF(TYPE.EQ.3) DRIFT = .TRUE.
      CALL STEPS(R,RM)
      IF (SC4P) GO TO 4
      DRIFT = .FALSE.
      CALL EMAT(E)
      L=0.
      EFLAG = .TRUE.
      CALL STEPS(E,RM)
      EFLAG = .FALSE.
C
C     RESTORE L, R2P RS , RC2 & SIT, SET R=RM
C
    4 CALL UCOPY(REM1,RS,36)
      CALL UCOPY(REM2,RC2,36)
      CALL UCOPY(REM3,SIT,36)
      CALL UCOPY(RM,R,36)
      L=RL
      IF(TYPE.EQ.4) AL=H*L
      IF(TYPE.NE.19) GO TO 13
      KL=KO*L
      SN=SIN(KL)
      CS=COS(KL)
   13 CONTINUE
      LC=REMLC
      R2P=REM2P
      RECENT=.FALSE.
      DRIFT=.FALSE.
      IF(SC4P .AND. TYPE.EQ.3) DRIFT=.TRUE.
      RETURN
      END
      SUBROUTINE SPESHL(JA)
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC4/ LC, TOTANG, LCV(20)
      REAL LC, LCV
      COMMON /BLOC5/ VSTOR(20), TIE(NND)
      INTEGER VSTOR, TIE
      COMMON /BLOC5A/ LABEL(NNL), LABM(20)
      CHARACTER       LABEL*4, LABM*4
      COMMON /BLOC6/ PERIDX, PERIDY, PERIDC, RCPER, EMITX, EMITY
      LOGICAL PERIDX, PERIDY, PERIDC, RCPER
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC21/ EN, ES, BE, APB(2), LAYL, LAYX, RAB1,RAB2,RINVL
      REAL LAYL, LAYX
      COMMON /BLOC23/ H, AL, NB, BDB, CHARGE, LILENS, EQUAD, EBEND
      REAL NB
      LOGICAL LILENS, EQUAD, EBEND
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC33/ FOTILT, SM
      COMMON /BLOC36/ VARS(4), SEXMAX, SEXLIM
      INTEGER VARS
      LOGICAL SEXLIM
      COMMON /BLOC39/ VAR5
      INTEGER VAR5
      COMMON /BLOC49/ NL, FAILED, ITER
      LOGICAL FAILED
      COMMON /BLOC50/ XI1, XI2, XI3
      COMMON /BLOC59/ SLITS
      LOGICAL SLITS
      COMMON /BLOC70/ RANOPT, NITER, ALOW(20), AHIGH(20)
      LOGICAL RANOPT
      COMMON /BLOC78/ ICONF
      COMMON/SC/STEP,AMP,BFREQ,GAMMA,CAPPA,IPTFQ,SC1P,SC3P
      LOGICAL SC1P,SC3P
C
      J = JA
      IF (J .EQ. 40) GOTO 400
      IF (J .EQ. 93) GOTO 930
      IF (J .EQ. 94) GOTO 940
      IF (J .EQ. 95) GOTO 950
      IF (J .EQ. 96) GOTO 960
      IF (J .EQ. 97) GOTO 970
      IF (J .EQ. 98) GOTO 980
      GO TO (10,20,30,40,40,60,70,80,90,100,110,120,130,140,150,
     A 160,160,160,190,200,210,220,900,900,250,260,270,900,290,
     B 900,310,320,900,900,900,900,900,900,900), J
C
C     BENDING MAGNET FIELD SECOND DERIVATIVE
C
   10 BDB = DATA(I+2)/UNIT(1)**2
      VARS(3) = TIE(I+2)
      RETURN
   20 DB = DATA(I+2)
      CALL UPDAT2
      DO 3400  J = 1,5,1
      SI(J,6)  = 0
      SI(6,J)  =  0
 3400 CONTINUE
      SI(6,6) = (DB * UNIT(6))  **2
      RETURN
C
C     PARTICLE MASS
C
   30 SM = DATA(I+2) * UNIT(10)
      GAMMA = SQRT(1.0 + (RI/SM)**2)
      RETURN
C
C     BENDING MAGNET APERTURES
C
   40 APB(J-3)  =  DATA(I+2) * UNIT(2*J-7)
      IF(J.EQ.5) VAR5 = TIE( I + 2 )
      RETURN
C
C     CUMULATIVE LENGTH OF SYSTEM
C
   60 LC = DATA(I+2) * UNIT(8)
      IF (NV1 .LT. 1) RETURN
      DO 65 N = 1, NV1
      LCV(N) = 0.0
   65 CONTINUE
      RETURN
C
C     FRINGING FIELD INTEGRALS
C
   70 LAYL  =  DATA(I+2)
      RETURN
   80 LAYX  =  DATA(I+2)
      RETURN
C
C     PERIODIC SOLUTION
C
   90 EMITX = DATA(I+2)
      PERIDX = .TRUE.
      IF(DATA(I+2) .EQ. 0.0) PERIDX = .FALSE.
      RETURN
  100 EMITY = DATA(I+2)
      PERIDY = .TRUE.
      IF(DATA(I+2) .EQ. 0.0) PERIDY = .FALSE.
      RETURN
  110 IF(EMITX.NE.0.0 .OR. EMITY.NE.0.0) GO TO 111
      IF (FORMIO) WRITE(NOUT,1000)
 1000 FORMAT(' With  the 16. 11. 0.; card you are asking for a
     X periodic solution, but'/' 16. 9. EMIX; and/or 16. 10.
     X EMIY; cards before the beam card are missing.')
      CALL MENU(1)
      RETURN
  111 PERIDC = .TRUE.
      RETURN
C
C     BENDING MAGNET ENTRANCE AND EXIT FACE CURVATURES
C
  120 RAB1 =  DATA(I+2) / UNIT(8)
      VARS(1) = TIE(I+2)
      RETURN
  130 RAB2  =  DATA(I+2)/ UNIT(8)
      VARS(2) = TIE(I+2)
      RETURN
C
C     LIMITS TO ENTRANCE AND EXIT FACE CURVATURES FOR BENDS WHILE FITTING
C
  210 RINVL =  DATA(I+2)/ UNIT(8)
      RETURN
C
C     MAXIMUM OF FIT ITERATIONS
C
  220 ITER  = NINT(DATA(I+2))
      NITER = ITER   ! FOR RANDOM OPTIMIZER
      RETURN
C
C     SLITS INSTEAD OF UPDATE
C
  140 SLITS = .TRUE.
      RETURN
C
C     TILT OF FOCAL PLANE
C
  150 FOTILT = DATA(I+2)
      RETURN
C
C     FLOOR COORDINATES OF BEGINNING OF BEAM
C
  160 J = J - 15
      X0(4,J) = DATA(I+2)*UNIT(8)
      RETURN
C
C     INITIAL DIRECTION OF BEAM LINE
C
  190 TH = DATA(I+2) * UNIT(7)
      CS = COS(TH)
      SN = SIN(TH)
      O(4,1,1) = CS
      O(4,1,3) = - SN
      O(4,3,1) = SN
      O(4,3,3) = CS
      RETURN
C
  200 PH = DATA(I+2) * UNIT(7)
      CS = COS(PH)
      SN = SIN(PH)
      O(1,2,2) = CS
      O(1,2,3) = - SN
      O(1,3,2) = SN
      O(1,3,3) = CS
      RETURN
C
C     FRINGE FIELD INTEGRALS I1 TO I4 FOR QUADS
C
  250 XI1 = DATA(I+2)
      RETURN
  260 XI2 = DATA(I+2)
      RETURN
  270 XI3 = DATA(I+2)
      RETURN
C
C     CHARGE OF PARTICLE
C
  290 CHARGE = DATA(I+2)
      RETURN
C
C     TURN ON RANDOM OPTIMIZER SOLVE2
C
  310 RANOPT = .TRUE.
      RETURN
C
C     TURN OFF RANDOM OPTIMIZER SOLVE2
C
  320 RANOPT = .FALSE.
      RETURN
C
C     FOR ELECTROSTATIC ACCELERATOR SPECIAL
C
  400 ICONF = DATA(I+2)
      RETURN
C
C     BEND IS NORMAL
C
  930 EBEND = .FALSE.
      RETURN
C
C     BEND IS AN ELECTROSTATIC PRISM
C
  940 EBEND = .TRUE.
      RETURN
C
C     QUAD IS NORMAL
C
  950 EQUAD = .FALSE.
      RETURN
C
C     QUAD IS AN ELECTROSTATIC QUAD
C
  960 EQUAD = .TRUE.
      RETURN
C
C     QUAD IS NORMAL
C
  970 LILENS = .FALSE.
      RETURN
C
C     QUAD HAS SAME BEHAVIOR IN X AND Y (LITHIUM OR PLASMA LENS)
C
  980 LILENS = .TRUE.
      RETURN
C
C     UNDEFINED OPERATIONS
C
  900 IF (FORMIO) WRITE(NOUT,999) J
  999 FORMAT('SPESHL: UNDEFINED TYPE CODE 16.',I3,'. ;')
C
      RETURN
      END

      SUBROUTINE STEPS(A,RM)
C
C     NEW SUBROUTINE FOR SPACE CHARGE
C     ADVANCES RM AND RC2 BY ONE STEP (A)
C
      COMMON /BLOC3/ TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC4/ LC, TOTANG, LCV(20)
      REAL LC, LCV
      COMMON /BLOC11/ R(6,6), RV(6,6), T(6,6,6), TV(6,6,6)
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     A                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC14/ RC3(6,6), TC3(6,6,6), R3P
      LOGICAL R3P
      COMMON /BLOC15/ RS(6,6), RT(6,6), TS(6,6,6), TT(6,6,6)
      COMMON /BLOC18/ SIT(6,6), CEN(6), RECENT
      LOGICAL RECENT
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC,TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
      COMMON /BLOC31/ J1, TYP1
      INTEGER TYP1
      COMMON /BLOC62/ RL, EFLAG
      LOGICAL EFLAG
      DIMENSION A(6,6), B(6,6), RM(6,6)
C
C     ADVANCE RM BY A
C
      IF (.NOT.EFLAG) CALL CABF(B,A,RM)
      IF   (EFLAG)    CALL CABE(B,A,RM)
      CALL UCOPY(B,RM,36)
C
C     INITIALIZE RC2 IN CASE NOT YET DONE
C
      IF (R2P.OR.R3P) GO TO 200
      R2P = .TRUE.
      CALL UCOPY(RM,RC2,36)
      GO TO 300
C
C     ADVANCE RC2 BY A
C
  200 IF (.NOT.EFLAG) CALL CABF(RS,A,RC2)
      IF   (EFLAG)    CALL CABE(RS,A,RC2)
      CALL UCOPY(RS,RC2,36)
  300 CONTINUE
      RECENT = .FALSE.
      TYP1 = TYPE
      LC = LC + L
      RETURN
      END

      SUBROUTINE TFL
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC27/ CT(6,6), CT0(6,6), CT1(3,3), VM(6), DMC, NM
      LOGICAL DMC
      COMMON /BLOC63/ Z216(216), U36(36)
C
      CALL UCOPY(Z216,CT,36)
  398 CT1(1,2) =  X0(IR,3)
      CT1(2,1)  =  -CT1(1,2)
      CT1(3,1)  =  X0(IR,2)
      CT1(1,3)  =  -CT1(3,1)
      CT1(2,3)  =  X0(IR,1)
      CT1(3,2)  =  -CT1(2,3)
      DO 400  J=1,3,1
      DO 400  K=1,3,1
      CT(2*J-1,2*K-1)  =  O(IR,J,K)
      S = 0.0
      DO 401   N = 1,3,1
      S = S + O(IR,J,N)*CT1(N,K)
  401 CONTINUE
      CT(2*J-1,2*K)  =  S
  400 CONTINUE
      DO 402 K = 1, 3
      CT(2,2*K) = O(IR,2,K)
      CT(4,2*K) = - O(IR,1,K)
  402 CONTINUE
C
      RETURN
      END
      SUBROUTINE UNITS(J)
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC40/ UORIG(11), UNTAB(21)
      COMMON /BLO40A/ XORIG(11), XDTAB(21)
      CHARACTER*4     XORIG,     XDTAB
C
      IF (J .EQ. 0) GO TO 300
C
C     J .NE. 0 -- CHANGE UNIT NUMBER J
C
      III      = DATA(I+2)
      XDIME(J) = DSTOR(III)
      UNIT(J)  =  UORIG(J) * DATA(I+3)
      IF( J .GE. 3)  RETURN
      UNIT(J+2)  =  UNIT(J)
      XDIME(J+2)  =  XDIME(J)
      RETURN
C
C     J = 0 -- RESET STANDARD UNITS
C
  300 DO 310 II = 1, 11
      UNIT(II) = UORIG(II)
      XDIME(II) = XORIG(II)
  310 CONTINUE
      RETURN
      END
      SUBROUTINE UPDAT2
      COMMON /BLOC12/ RC(6,6), RCV(6,6,20), TC(6,6,6), RCP, RVP(20)
      LOGICAL RCP, RVP
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     A                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC14/ RC3(6,6), TC3(6,6,6), R3P
      LOGICAL R3P
      COMMON /BLOC15/ RS(6,6), RT(6,6), TS(6,6,6), TT(6,6,6)
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      DIMENSION  RCVL(36,20), R2VL(36,20)
      EQUIVALENCE (RCV,RCVL),  (R2V,R2VL)
C
      IF (R3P) CALL UPDAT3
C
C     BEAM UPDATE
C
      CALL UPSIG
C
C     PARTIAL DERIVATIVES OF ACCUMULATED R MATRIX
C
   15 IF (NV1 .LT. 1) GO TO 200
      DO 190 N = 1, NV1
C
C     R2 TIMES DERIVATIVE OF R1
C
      IF (.NOT. RVP(N)) GO TO 100
      CALL CAB(RS,RC2,RCVL(1,N))
      CALL UCOPY(RS,RCVL(1,N),36)
C
C     DERIVATIVE OF R2 TIMES R1
C
  100 IF (RCP) GO TO 130
      CALL UCOPY(R2VL(1,N),RCVL(1,N),36)
      GO TO 180
C
  130 IF (.NOT. R2VP(N)) GO TO 180
      CALL CAB (RS, R2VL(1,N), RC)
      IF (RVP(N)) GO TO 160
      CALL UCOPY(RS,RCVL(1,N),36)
      GO TO 180
C
  160 CALL MADD(RCVL(1,N),RS,36)
  180 RVP(N) = RVP(N) .OR. R2VP(N)
      R2VP(N) = .FALSE.
  190 CONTINUE
C
C     ACCUMULATED R
C
  200 IF (RCP) GO TO 230
      CALL UCOPY(RC2,RC,36)
      IF (SEC) CALL UCOPY(TC2,TC,216)
      GO TO 280
C
  230 IF (.NOT. SEC) CALL CAB(RS,RC2,RC)
      IF (SEC) CALL MTMPLY(RS,TS,RC2,TC2,RC,TC)
      CALL UCOPY(RS,RC,36)
      IF (SEC) CALL UCOPY(TS,TC,216)
  280 RCP = RCP .OR. R2P
      R2P = .FALSE.
      RETURN
      END
      SUBROUTINE UPDAT3
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     A                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC14/ RC3(6,6), TC3(6,6,6), R3P
      LOGICAL R3P
      COMMON /BLOC15/ RS(6,6), RT(6,6), TS(6,6,6), TT(6,6,6)
      COMMON /BLOC19/ TR(6,6,6)
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      DIMENSION  R2VL(36,20), TC3L(36,6), TRL(36,6)
      EQUIVALENCE (R2V,R2VL), (TC3,TC3L), (TR,TRL)
C
C     PRELIMINARY CALCULATION
C
      IF (.NOT. R2P .OR. .NOT. SEC) GO TO 100
      DO 10 M = 1, 6
   10 CALL CAB(TRL(1,M),TC3L(1,M),RC2)
C
C     CUMULATIVE R2 MATRIX
C
  100 IF (R2P) GO TO 150
      CALL UCOPY(RC3,RC2,36)
      IF (SEC) CALL UCOPY(TC3,TC2,216)
      GO TO 300
C
  150 IF (.NOT. SEC) CALL CAB(RS,RC3,RC2)
      IF (SEC) CALL MSMPLY(RS,TS,RC3,TC3,RC2,TC2)
      CALL UCOPY(RS,RC2,36)
      IF (SEC) CALL UCOPY(TS,TC2,216)
C
C     R3 TIMES DERIVATIVE OF R2
C
  200 IF (NV1 .LT. 1) GO TO 300
      DO 270 N = 1, NV1
      IF (.NOT. R2VP(N)) GO TO 270
      IF (.NOT. SEC) CALL CAB(RS,RC3,R2VL(1,N))
      IF (SEC) CALL MXMPLY(RS,TS,RC3,TC3,R2VL(1,N),T2V(1,N))
      CALL UCOPY(RS,R2VL(1,N),36)
      IF (SEC) CALL UCOPY(TS,T2V(1,N),216)
  270 CONTINUE
C
  300 R2P = R2P .OR. R3P
      R3P = .FALSE.
      RETURN
      END
      SUBROUTINE UPDATE
      COMMON /BLOC12/ RC(6,6), RCV(6,6,20), TC(6,6,6), RCP, RVP(20)
      LOGICAL RCP, RVP
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     A                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC14/ RC3(6,6), TC3(6,6,6), R3P
      LOGICAL R3P
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      CALL UPSIG
      RCP = .FALSE.
      R2P  =  .FALSE.
      R3P = .FALSE.
      IF (NV1 .LT. 1) GO TO 200
      DO 100 N = 1, NV1
      RVP(N) = .FALSE.
      R2VP(N) = .FALSE.
  100 CONTINUE
  200 IF (.NOT. ALIGN) RETURN
      CALL RESET(2)
      RETURN
      END
      SUBROUTINE UPMIS
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     1 R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC15/ RS(6,6), RT(6,6), TS(6,6,6), TT(6,6,6)
      COMMON /BLOC27/ CT(6,6), CT0(6,6), CT1(3,3), VM(6), DMC, NM
      LOGICAL DMC
      COMMON /BLOC77/ COM(6,6,20), SIM(36,6,20)

      REAL FOOD(6), WORK(6,6)
C
C     MISALIGNMENT TABLE BEAM CENTROID
C
      DO 100 N = 1, NM
      DO 100 M = 1, 6
      DO 10 L = 1, 6
      S = 0.0
      DO 5 K = 1, 6
      S = S + RC2(L,K)*COM(K,M,N)
    5 CONTINUE
      FOOD(L) = S
   10 CONTINUE
      DO 20 L = 1, 6
      COM(L,M,N) = FOOD(L)
   20 CONTINUE
C
C     MISALIGNMENT TABLE BEAM SIZE
C
      DO 30 L1 = 1, 6
      DO 30 L2 = 1, 6
      S = 0.0
      DO 25 L3 = 1, 6
      LPL = 6*L3 + L2 - 6
      S = S + RC2(L1,L3)*SIM(LPL,M,N)
   25 CONTINUE
      WORK(L1,L2) = S
   30 CONTINUE
      DO 40 L1 = 1, 6
      DO 40 L2 = 1, L1
      LPL = 6*L1 + L2 - 6
      LXL = 6*L2 + L1 - 6
      S = 0.0
      DO 35 L3 = 1, 6
      S = S + RC2(L1,L3)*WORK(L2,L3)
   35 CONTINUE
      SIM(LPL,M,N) = S
      SIM(LXL,M,N) = SIM(LPL,M,N)
   40 CONTINUE
  100 CONTINUE
      RETURN
      END
      SUBROUTINE UPSIG
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     A                R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC15/ RS(6,6), RT(6,6), TS(6,6,6), TT(6,6,6)
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     A                SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC18/ SIT(6,6), CEN(6), RECENT
      LOGICAL RECENT
      COMMON /BLOC27/ CT(6,6), CT0(6,6), CT1(3,3), VM(6), DMC, NM
      LOGICAL DMC
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC34/ SEC, SOFA, LINEAR
      LOGICAL         SEC, SOFA, LINEAR
      REAL FOOD(6)
C
C     CALCULATION OF BEAM PARAMETERS
C
      IF (NM .GT. 0) CALL UPMIS
      IF (.NOT. RECENT) CALL BEAM
C
C     PARTIAL DERIVATIVES OF BEAM PARAMETERS
C
      IF (NV1 .LT. 1) GO TO 105
      DO 100 N = 1, NV1, 1
C
C     TRANSFORMATION OF PARTIAL DERIVATIVES OF PREVIOUS BEAM PARAMETERS
C
      IF (.NOT. SVP(N)) GO TO 50
      IF (.NOT. S1P) GO TO 20
      DO 15 ISBK = 1, 6
      GHOST = 0.0
      DO 10 JSBK = 1, 6
      GHOST = GHOST + RC2(ISBK,JSBK)*COV(JSBK,N)
   10 CONTINUE
      FOOD(ISBK) = GHOST
   15 CONTINUE
      DO 16 ISBK = 1, 6
      COV(ISBK,N) = FOOD(ISBK)
   16 CONTINUE
      GO TO 25
   20 DO 21 ISBK = 1, 6
      COV(ISBK,N) = 0.0
   21 CONTINUE
   25 CALL CAB(RT,RC2,SV(1,1,N))
      CALL CABT(SV(1,1,N),RC2,RT)
C
C     EFFECT OF DERIVATIVE OF R MATRIX ON PREVIOUS BEAM PARAMETERS
C
   50 IF (.NOT. R2VP(N)) GO TO 100
      IF (.NOT. S1P) GO TO 70
      DO 60 JU = 1, 6
      GHOST = 0.0
      DO 55 KU = 1, 6
      GHOST = GHOST + R2V(JU,KU,N)*CO(KU)
   55 CONTINUE
      FOOD(JU) = GHOST
   60 CONTINUE
   70 CALL CSABT(RT,R2V,RS,N)
      IF (SVP(N)) GO TO 80
C
      IF (.NOT. S1P) GO TO 73
      DO 72 JU = 1, 6
      COV(JU,N) = FOOD(JU)
   72 CONTINUE
      GO TO 75
   73 DO 74 ISBK = 1, 6
      COV(ISBK,N) = 0.0
   74 CONTINUE
   75 DO 76 JU = 1, 6
      DO 76 KU = 1, 6
      SV(JU,KU,N) = RT(JU,KU) + RT(KU,JU)
      SV(KU,JU,N) = SV(JU,KU,N)
   76 CONTINUE
      GO TO 95
C
   80 IF (.NOT. S1P) GO TO 85
      DO 82 JU = 1, 6
      COV(JU,N) = COV(JU,N) + FOOD(JU)
   82 CONTINUE
   85 DO 90 JU = 1, 6
      DO 90 KU = 1, JU
      SV(JU,KU,N) = SV(JU,KU,N) + RT(JU,KU) + RT(KU,JU)
      SV(KU,JU,N)  =  SV(JU,KU,N)
   90 CONTINUE
   95 CONTINUE
      SVP(N)  =  .TRUE.
  100 CONTINUE
C
C     NEW BEAM PARAMETERS
C
  105 IF (.NOT. S1P) GO TO 120
      CALL UCOPY(CEN,CO,6)
  120 CALL UCOPY(SIT,SI,36)
      IF (SEC) SOFA = .TRUE.
      RETURN
      END
      INTEGER FUNCTION VARGAP(TYPE)
      COMMON /BLOC39/ VAR5
      INTEGER TYPE,VAR5
      IF(TYPE.EQ.2) GO TO 2
      VARGAP=0
      RETURN
    2 VARGAP = VAR5
      RETURN
      END
      INTEGER FUNCTION VARSEC(TYPE)
      COMMON /BLOC21/ EN, ES, BE, APB(2), LAYL, LAYX, RAB1,RAB2,RINVL
      REAL LAYL, LAYX
      COMMON /BLOC36/ VARS(4), SEXMAX, SEXLIM
      INTEGER VARS
      LOGICAL SEXLIM
      INTEGER TYPE
      IF (TYPE .EQ. 18) GO TO 300
      IF (TYPE .EQ. 4) GO TO 200
      IF (TYPE .EQ. 2) GO TO 100
      VARSEC = 0
      RETURN
  100 IF (ES .EQ. 1.0) GO TO 110
      VARSEC = VARS(2)
      RETURN
  110 VARSEC = VARS(1)
      RETURN
  200 VARSEC = VARS(3)
      RETURN
  300 VARSEC = VARS(4)
      RETURN
      END
      SUBROUTINE WOBBLE
      COMMON /BLOC15/ RS(6,6), RT(6,6), TS(6,6,6), TT(6,6,6)
      COMMON /BLOC16/ SI(6,6), SV(6,6,20), CO(6), COV(6,20), RI,
     1 SVP(20), S1P
      LOGICAL SVP, S1P
      COMMON /BLOC18/ SIT(6,6), CEN(6), RECENT
      LOGICAL RECENT
      COMMON /BLOC19/ TR(6,6,6)
      DIMENSION GT(6,6,6)
      EQUIVALENCE (TR(1,1,1),GT(1,1,1))
      COMMON /BLOC26/ O(4,3,3), X0(4,3), IR, RORC, TYT, ALIGN, TMK
      INTEGER RORC, TYT
      LOGICAL ALIGN, TMK
      COMMON /BLOC27/ CT(6,6), CT0(6,6), CT1(3,3), VM(6), DMC, NM
      LOGICAL DMC
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC45/ SIOL(3,6,6), COLD(3,6), SPO(3)
      LOGICAL SPO
      COMMON /BLOC46/ XM(6), XMB(6), DXM(6), GXXM(6,6)
C
      I2MOD = 2 - MOD(JV,2)
      IF (TYT/100 .NE. 0) GO TO 100
C
C     UNCERTAIN MISALIGNMENT
C
      DO 50 J = 1, 6
      IF (.NOT. SVP(NV2)) COV(J,NV2) = 0.0
      DO 50 K = 1, J
      S = CT(J,JV)*CT(K,JV)
      IF (.NOT. SPO(IR)) GO TO 20
      DO 10 M = 1, 6
      S = S + (CT(J,JV)*GT(K,M,JV) + CT(K,JV)*GT(J,M,JV))*COLD(IR,M)
   10 CONTINUE
   20 DO 30 M = 1, 6
      DO 30 N = 1, 6
      S = S + GT(J,M,JV)*GT(K,N,JV)*SIOL(IR,M,N)
   30 CONTINUE
      S = 2.0*S*VM(JV)*UNIT(I2MOD)
      IF (SVP(NV2)) GO TO 40
      SV(J,K,NV2) = S
      GO TO 45
   40 SV(J,K,NV2) = SV(J,K,NV2) + S
   45 SV(K,J,NV2) = SV(J,K,NV2)
   50 CONTINUE
      GO TO 200
C
C     KNOWN MISALIGNMENT
C
  100 DO 120 J = 1, 6
      S = CT(J,JV)
      IF (.NOT. SPO(IR)) GO TO 110
      DO 105 M = 1, 6
      S = S + GT(J,M,JV)*COLD(IR,M)
  105 CONTINUE
  110 S = S*UNIT(I2MOD)
      IF (SVP(NV2)) GO TO 115
      COV(J,NV2) = S
      GO TO 120
  115 COV(J,NV2) = COV(J,NV2) + S
  120 CONTINUE
C
      DO 190 J = 1, 6
      DO 190 K = 1, J
      S = CT(J,JV)*XM(K) + CT(K,JV)*XM(J)
      DO 125 M = 1, 6
      DO 125 N = 1, 6
      S = S + (GT(J,M,JV)*RS(K,N) + GT(K,M,JV)*RS(J,N))*SIOL(IR,M,N)
  125 CONTINUE
      DO 130 M = 1, 6
      S = S + GXXM(J,M)*GT(K,M,JV) + GXXM(K,M)*GT(J,M,JV)
  130 CONTINUE
      IF (.NOT. SPO(IR)) GO TO 150
      S = S + CT(J,JV)*CEN(K) + CT(K,JV)*CEN(J)
      S = S + CT(J,JV)*XMB(K) + CT(K,JV)*XMB(J)
      DO 140 M = 1, 6
      S = S + (XM(J)*GT(K,M,JV) + XM(K)*GT(J,M,JV))*COLD(IR,M)
      S = S + (DXM(J)*GT(K,M,JV) + DXM(K)*GT(J,M,JV))*COLD(IR,M)
  140 CONTINUE
  150 S = S*UNIT(I2MOD)
      IF (SVP(NV2)) GO TO 160
      SV(J,K,NV2) = S
      GO TO 170
  160 SV(J,K,NV2) = SV(J,K,NV2) + S
  170 SV(K,J,NV2) = SV(J,K,NV2)
  190 CONTINUE
C
  200 SVP(NV2) = .TRUE.
      RETURN
      END
      SUBROUTINE WOE
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC4/  LC, TOTANG, LCV(20)
      REAL LC, LCV
      COMMON /BLOC5/ VSTOR(20), TIE(NND)
      INTEGER VSTOR, TIE
      COMMON /BLOC5A/ LABEL(NNL), LABM(20)
      CHARACTER       LABEL*4, LABM*4
      COMMON /BLOC13/ RC2(6,6), R2V(6,6,20), TC2(6,6,6), T2V(216,10),
     1 R2P, R2VP(20)
      LOGICAL R2P, R2VP
      COMMON /BLOC15/ RS(6,6), RT(6,6), TS(6,6,6), TT(6,6,6)
      COMMON /BLOC27/ CT(6,6), CT0(6,6), CT1(3,3), VM(6), DMC, NM
      LOGICAL DMC
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLO32A/ XDIME(11), DSTOR(20)
      CHARACTER*4     XDIME, DSTOR
      COMMON /BLOC44/ BEGM(3), BEGMS(20), ENDMS(20)
      COMMON /BLOC77/ COM(6,6,20), SIM(36,6,20)
      DIMENSION OUTPUT(12)
C
    1 DO 2 J = 1, 6
      I2MOD = 2 - MOD(J,2)
    2 OUTPUT(J) = VM(J)/UNIT(I2MOD)
      IF (FORMIO) WRITE (NOUT,1000)
 1000 FORMAT (' *MISALIGNMENT EFFECT TABLE FOR MISALIGNMENTS OF')
      IF (FORMIO) WRITE (NOUT,1001)
     A OUTPUT(1), XDIME(1), OUTPUT(2), XDIME(2),
     B OUTPUT(3), XDIME(1), OUTPUT(4), XDIME(2),
     C OUTPUT(5), XDIME(1), OUTPUT(6), XDIME(2)
 1001 FORMAT (1H ,6(1X,F10.3,1X,A4,6X))
      DO 100 N = 1, NM
      BEGMST = BEGMS(N)/UNIT(8)
      ENDMST = ENDMS(N)/UNIT(8)
      IF (FORMIO) WRITE (NOUT,1002)
     A LABM(N), BEGMST, XDIME(8), ENDMST, XDIME(8)
 1002 FORMAT (' *MISALIGNMENT OF',1X,A4,'* (',F10.3,1X,A4,' TO',F10.3,
     1 1X,A4,')')
      DO 100 J = 1, 6
      JJ = 7*J - 6
      DO 30 K = 1, 6
      IF (R2P) GO TO 10
      CEO = COM(J,K,N)
      SIO = SQRT(MAX(0.0,SIM(JJ,K,N) - CEO**2))
      GO TO 20
   10 CEO = 0.0
      DO 15 L = 1, 6
      CEO = CEO + RC2(J,L)*COM(L,K,N)
   15 CONTINUE
      SIO = 0.0
      DO 16 L1 = 1, 6
      DO 16 L2 = 1, 6
      LPL = 6*L1 + L2 - 6
      SIO = SIO + RC2(J,L1)*SIM(LPL,K,N)*RC2(J,L2)
   16 CONTINUE
      SIO = SQRT(MAX(0.0,SIO - CEO**2))
   20 CONTINUE
      KL = 2*K - 1
      KH = 2*K
      OUTPUT(KL) = CEO/UNIT(J)
      OUTPUT(KH) = SIO/UNIT(J)
   30 CONTINUE
      IF (FORMIO) WRITE (NOUT,1003)
     A (OUTPUT(2*K-1), OUTPUT(2*K), XDIME(J), K = 1, 6)
 1003 FORMAT (1H ,6(2F8.3,1X,A4,1X))
   50 CONTINUE
  100 CONTINUE
      RETURN
      END
      SUBROUTINE UCOPY(A, B, N)
C
      REAL A(1), B(1)
C
C     CALL LIB$MOVC3(4 * N, A, B)
C
      DO 10 I = 1, N
   10 B(I) = A(I)
C
      RETURN
      END

C ------------------------------------------------------------------------------
C     NEW OPTIMIZING ALGORITHM FOR TRANSPORT.
C     NEEDED FOR ENVELOPE FITS WITH SPACE CHARGE.
C     URS ROHRER (PSI), SEPTEMBER 1991
C ------------------------------------------------------------------------------
C ------------------------------------------------------------------------------
C
C     DESCRIPTION OF NEW FUNCTIONS AND SUBROUTINES
C
C ------------------------------------------------------------------------------
C ------------------------------------------------------------------------------
C SUBROUTINE DOT PUTS FOR EVERY OPTIMIZING STEP A DOT ON SCREEN
C REAL FUNCTION FX(IDUM) COMPUTES CHI-SQUARED
C SUBROUTINE GETPAR(PAR,TYP) GETS INITIAL VALUES OF VARIED PARAMETERS
C SUBROUTINE RANINI INITIALIZES PARAMETERS FOR RANDOM OPTIMIZER
C REAL FUNCTION SEARCH(A,NPAR) LOCAL STOCHASTIC SEARCH PROCEDURE FOR FINDING
C                              EFFICENTLY THE MINIMA OF A FUNCTION FX(A)
C SUBROUTINE SETPAR(PAR) CHANGES VARIED PARAMETERS TO NEW VALUES
C SUBROUTINE SOLVER DIRECTS RANDOM OPTIMIZATION
C SUBROUTINE TERWRT(CHAR) PRINTS OUT CHARACTER TO TERMINAL TT
C REAL FUNCTION XNORMAL(IDUM) CREATES QUASI GAUSSIAN DISTRIBUTION
C ------------------------------------------------------------------------------

      SUBROUTINE SOLVER
C
      COMMON /BLOC2/  NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC29/ A(21), CW, CA(21,21), SCALE(21), CASAV(21,21),
     1                PMARQ, CHSMIN, XNORM, GNORM, EPS
      COMMON /BLOC49/ NL, FAILED, ITER
      LOGICAL FAILED
      COMMON /BLOC70/ RANOPT, NITER, ALOW(20), AHIGH(20)
      LOGICAL RANOPT
C
      REAL    PAR(20)
      INTEGER TYP(20)
      INTEGER*4 ISEED(1)
C
      FAILED = .FALSE.
      NPAR   = NV1
      IF (NPAR .GT. 20) THEN
        WRITE(NOUT,*) 'SEARCH: MORE THAN 20 PARAMTERS -- EXIT'
        CALL MENU(1)
        RETURN
      ENDIF
C
      ISEED(1) = SECNDS(0.0)
      M=1
      CALL RANDOM_SEED(SIZE=M)
      CALL RANDOM_SEED(PUT=ISEED(1:1))
C
      IF (FORMIO) THEN
        WRITE(NOUT,1000)
1000    FORMAT('0*CORRECTIONS* (performed by stochastic solver)')
      ENDIF
C
      XXX = FX(0)
      CALL GETPAR(PAR,TYP) ! GET INITIAL PARAMETERS 
C
      DO 10 J = 1, NPAR
        IF (ALOW(J).EQ.0.0 .AND. AHIGH(J).EQ.0.0) THEN
          IF (TYP(J) .EQ. 1) THEN
            ALOW(J)  =  0.0001
            AHIGH(J) =  2. * PAR(J)
          ELSE IF (TYP(J) .EQ. 12) THEN
            ALOW(J)  = -0.9999
            AHIGH(J) =  0.9999
          ELSE
            ALOW(J)  = -2. * ABS(PAR(J))
            AHIGH(J) =  2. * ABS(PAR(J))
          ENDIF
        ENDIF
10    CONTINUE
C
      CA(1,1) = SEARCH(PAR,NPAR)
C
      IF (FORMIO) THEN
        IF (FAILED) THEN
          WRITE(NOUT,1001)
1001      FORMAT('0*FAILED*')
        ELSE
          WRITE(NOUT,1002) CA(1,1)
1002      FORMAT('0*COVARIANCE* (FIT',E12.5,')')
        ENDIF
      ENDIF
C
      RETURN
      END

C-------------------------------------------------------------------------------

      REAL FUNCTION FX(IDUM)
C
C     COMPUTE CHI-SQUARED
C
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC3/ TYPE, L, LV
      INTEGER TYPE
      REAL L, LV
      COMMON /BLOC5/ VSTOR(20), TIE(NND)
      INTEGER VSTOR, TIE
      COMMON /BLOC5A/ LABEL(NNL), LABM(10)
      CHARACTER       LABEL*4, LABM*4
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
      COMMON /BLOC30/ CDB, NOR, LAY
      INTEGER CDB
      LOGICAL NOR, LAY
      COMMON /BLOC32/ UNIT(11)
      COMMON /BLOC47/ REG(10), DREG(10,20), LREG(10)
      LOGICAL LREG
C
      FX  = 0.
      SUM = 0.
      CALL INITZE
      IF (NEL .LE. 0) GO TO 5300
C
C     LOOP OVER ALL ELEMENTS
C
   10 I    = ISTOR(NUM)
      TYPE = DATA(I)
      IF(TYPE .EQ. 9) CALL REPEAT
      IF(TYPE .EQ. 13) THEN
       CDB = DATA(I+1)
       CALL IO
      ENDIF
      IF(TYPE .EQ. 24) THEN
       CALL ASSESS
       REG(DATA(I+3)) = COC
       LREG(DATA(I+3)) = .TRUE.
      ENDIF
      IF(TYPE .EQ. 25) CALL COMBIN(0)
      IF(TYPE .LE. 0) GO TO 5002
      CALL ELICIT
C
C     COMPUTE CHI-SQUARED SUM
C
      IF (TYPE .EQ. 10) THEN
       CALL ASSESS
       SUM = SUM + ( (COC - DATA(I+3)) / DATA(I+4) )**2
      ENDIF
C
C     ADVANCE TO NEXT ELEMENT
C
 5002 NUM = NUM + 1
      IF (NUM .LE. NEL) GO TO 10
      FX = SUM
C
C     END OF BEAM LINE
C
 5300 RETURN
      END

C-------------------------------------------------------------------------------

      SUBROUTINE GETPAR(PAR,TYP)
C
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC5/ VSTOR(20), TIE(NND)
      INTEGER VSTOR, TIE
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
C
      INTEGER TYPE, VARY
      REAL    PAR(20)
      INTEGER TYP(20)
C
C     GET INITIAL VALUES OF VARIED PARAMETERS
C
      DO 70 NUM = 1, NEL
        I    = ISTOR(NUM)
        TYPE = DATA(I)
        IF (TYPE .LE. 0) GO TO 70
        NVT  = NIV(TYPE)
        IF (NVT .LT. 1) GO TO 70
        DO 60 J  = 1, NVT
          IPLUSJ = I + J
          VARY   = TIE(IPLUSJ)
          IF (VARY .EQ. 0) GO TO 60
          IVARY  = IABS(VARY)
          PAR(IVARY) = DATA(IPLUSJ)
          TYP(IVARY) = TYPE
   60   CONTINUE
   70 CONTINUE
C
      RETURN
      END

C-------------------------------------------------------------------------------

      SUBROUTINE SETPAR(PAR)
C
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC5/ VSTOR(20), TIE(NND)
      INTEGER VSTOR, TIE
      COMMON /BLOC28/ COC, DEO, SD, CTY, JV, NC, NV1, NV2, NV3
      INTEGER CTY
C
      INTEGER TYPE, VARY
      REAL    PAR(20)
C
C     CHANGE VARIED PARAMETERS TO NEW VALUES
C
      DO 70 NUM = 1, NEL
        I    = ISTOR(NUM)
        TYPE = DATA(I)
        IF (TYPE .LE. 0) GO TO 70
        NVT  = NIV(TYPE)
        IF (NVT .LT. 1) GO TO 70
        DO 60 J  = 1, NVT
          IPLUSJ = I + J
          VARY   = TIE(IPLUSJ)
          IF (VARY .EQ. 0) GO TO 60
          IVARY  = IABS(VARY)
          SIG    = SIGNF(VARY)
          DATA(IPLUSJ) = SIG * PAR(IVARY)
   60   CONTINUE
   70 CONTINUE
C
      RETURN
      END

C-------------------------------------------------------------------------------

      REAL FUNCTION XNORMAL(IDUM)
C
C     CREATE QUASI GAUSSIAN DISTRIBUTION
C
      Z = 0.
      DO 10 J = 1, 12
        CALL RANDOM_NUMBER(RND)
        Z = Z + RND
 10   CONTINUE
      XNORMAL = Z - 6.
C
      RETURN
      END

C-------------------------------------------------------------------------------

      REAL FUNCTION SEARCH(A,NPAR)
C
C     LOCAL STOCHASTIC SEARCH PROCEDURE FOR FINDING EFFICENTLY THE MINIMA
C     OF A FUNCTION FX(A). BY U. WITZKE (C'T MAGAZINE 7/91, P.182 FF.)
C     TRANSLATION TURBO PASCAL TO FORTRAN F77 BY U. ROHRER (PSI), SEPT. 1991
C
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
      COMMON /BLOC49/ NL, FAILED, ITER
      LOGICAL FAILED
      COMMON /BLOC70/ RANOPT, NITER, ALOW(20), AHIGH(20)
      LOGICAL RANOPT
C
      REAL A(*)
      REAL C(20), B(20), X(20), AS(20)
      LOGICAL BETTER
      INTEGER FAILS
C
C     DEFINE SOME PARAMETERS
C
      DATA GAMMA / 10. /  ! AFTER N0 STEPS -> MAGNIFICATION OF STEP
      DATA ALPHA / 2.  /  ! INCREASING STEP SIZE AFTER SUCCESS
      DATA BETA  / 0.5 /  ! DECREASING STEP SIZE AFTER FAILURE
      DATA N0    / 10  /  ! AFTER N0 STEPS MAGNIFICATION OF SEARCH HORIZON
      DATA NS    / 2   /  ! MAX NUMBER OF SEARCHES WITHOUT SUCCESS
      DATA ASF   / 0.2 /  ! FRACTION OF FULL RANGE FOR INITIAL SEARCH RANGE
C
C     STARTING POINT
C
      FAILS  = 0
      FA     = FX(0)
      FBEGIN = FA
      BETTER = .FALSE.
      N      = -1
      IF (FORMIO) THEN
        WRITE(NOUT,1000) N+1,FA,(A(J),J=1,NPAR)
1000    FORMAT(I5,E12.5,10F10.4/17X,10F10.4)
      ENDIF
C
C     INITIAL STEP SIZE FOR RANDOM VARIATION OF VARIABLES
C
      DO 5 J  = 1, NPAR
        AS(J) = ASF * (AHIGH(J)-ALOW(J))
 5    CONTINUE
C
C     DO NITER ITERATIONS
C
      ICOUNT   = 0
      NV       = 0
      DO 500 N = 0, NITER - 1
C
C      CREATE RANDOM VECTOR X ON THE UNITY SPHERE
C
       CALL DOT
       SUM     = 0.0
       DO 10 J = 1, NPAR
         X(J)  = XNORMAL(IDUM)
         SUM   = SUM + X(J) * X(J)
10     CONTINUE
       SUM     = SQRT(SUM)
       DO 20 J = 1, NPAR
         X(J)  = X(J) / SUM
20     CONTINUE
C
C      COMPUTE NEW SEARCH POINT C WITH ACTUAL STEP SIZE
C
       DO 30 J = 1, NPAR
         C(J)  = A(J) + AS(J) * X(J)
         IF (C(J) .LT. ALOW(J))  C(J) = ALOW(J)
         IF (C(J) .GT. AHIGH(J)) C(J) = AHIGH(J)
30     CONTINUE
       CALL SETPAR(C)
       FC = FX(0)
C
C      DECIDE WHICH ALTERNATIVE (LONGER) STEP SIZE TO TAKE
C
       IF (N .EQ. ICOUNT*N0) THEN
         FACTOR = GAMMA
         ICOUNT = ICOUNT + 1
       ELSE
         FACTOR = ALPHA
       ENDIF
C
C      COMPUTE NEW SEARCH POINT B WITH MODIFIED SEARCH STEP SIZE
C
       DO 40 J = 1, NPAR
         B(J)  = A(J) + FACTOR * AS(J) * X(J)
         IF (B(J) .LT. ALOW(J))  B(J) = ALOW(J)
         IF (B(J) .GT. AHIGH(J)) B(J) = AHIGH(J)
40     CONTINUE
       CALL SETPAR(B)
       FB = FX(0)
C
C      AFTER COMPUTING FB AND FC, WE HAVE TO DECIDE, WHICH POINT IS
C      BETTER AND HOW TO MODIFY THE STEP SIZE FOR THE NEXT SEARCH STEP.
C
       IF (FB .LT. FA) THEN          ! IF B BETTER THAN A (BEST POINT SO FAR) ..
         IF (FB .LT. FC) THEN        ! BIG STEP IS BETTER (TELESCOPE)
           DO 50 J = 1, NPAR
             AS(J) = FACTOR * AS(J)  ! INCREASE STEP BUT ONLY 1/6 OF FULL RANGE
             IF (AS(J) .GT. (AHIGH(J)-ALOW(J))/6.) THEN
               AS(J) = (AHIGH(J)-ALOW(J))/6.
             ENDIF
             A(J) = B(J)             ! B IS NOW THE BEST POINT
 50        CONTINUE
           FA = FB
           NV = 0
           BETTER = .TRUE.
         ELSE                        ! NO STEP SIZE MODIFICATION
           DO 60 J = 1, NPAR
             A(J)  = C(J)            ! C IS NOW THE BEST POINT
 60        CONTINUE
           FA = FC
           NV = 0
           BETTER = .TRUE.
         ENDIF
       ELSE                          ! OTHERWISE ..
         IF (FC .GE. FA) THEN
           IF (NV .EQ. NS) THEN ! MAX NUMBER OF FAILURES REACHED -> MICROSCOPE
             DO 70 J = 1, NPAR
               AS(J) = BETA * AS(J)
 70          CONTINUE
             NV = 0
           ELSE
             NV = NV + 1             ! INCREMENT NUMBER OF FAILURES
           ENDIF
         ELSE
           DO 80 J = 1, NPAR
             A(J)  = C(J)
 80        CONTINUE
           FA = FC                   ! C IS NOW THE BEST POINT
           NV = 0
           BETTER = .TRUE.
         ENDIF
       ENDIF
C
      IF (FORMIO .AND. BETTER) THEN
        WRITE(NOUT,1000) N+1,FA,(A(J),J=1,NPAR)
        BETTER = .FALSE.
      ELSE
	FAILS = FAILS + 1
      ENDIF
C
500   CONTINUE
C
      IF (FA .GE. FBEGIN) FAILED = .TRUE.
      IF (FORMIO) WRITE(NOUT,1111) 100.0*FLOAT(FAILS)/FLOAT(NITER)
1111  FORMAT('0*Solver statistics: failing rate =',F5.1,'%*')
      CALL SETPAR(A)
      SEARCH = FA
C
      RETURN
      END      

C-------------------------------------------------------------------------------

      SUBROUTINE RANINI
C
      PARAMETER (NND=5000, NNL=1250)
      COMMON /BLOC1/ NEL, NUM, I, IP, ISTOR(NNL), DATA(NND)
      COMMON /BLOC70/ RANOPT, NITER, ALOW(20), AHIGH(20)
      LOGICAL RANOPT
C
      INTEGER TYPE
C
C     SET DEFAULTS
C
      NITER   = 50
      DO 10 J = 1, 20
        ALOW(J)  = 0.
        AHIGH(J) = 0.
   10 CONTINUE
C
C     CHECK IF RANOPT HAS TO BE SET .TRUE. OR .FALSE.
C
      DO 20 NUM = 1, NEL
        I = ISTOR(NUM)
        TYPE = DATA(I)
        IF (TYPE .EQ. 16) THEN
          J = DATA(I+1)
          IF (J.EQ.31 .OR. J.EQ.32) CALL SPESHL(J)
        ENDIF
   20 CONTINUE
C
      RETURN
      END

C-------------------------------------------------------------------------------

      SUBROUTINE DOT
C
C     PUTS FOR EVERY OPTIMIZING STEP A DOT ON SCREEN (75 PER LINE)
C
      DATA LINE, N / 10, 0 /
C
      II = MOD(N,80)
      N  = N + 1
      IF (II .EQ. 0) THEN
        LINE = LINE + 1
        ICOL = 0
      ELSE
        ICOL = ICOL + 1
      ENDIF
C      CALL GOTOXY(LINE,ICOL)
C      CALL PUTCHA('.')      
C
      RETURN
      END

      SUBROUTINE MENU(IFLAG)
C
      COMMON /EXITFLAG/ NNFLAG
C
      IF (IFLAG .EQ. 1) THEN
       NNFLAG = 2   ! error in FOR001.DAT input
      ELSE IF (IFLAG .EQ. 2) THEN
       NNFLAG = 3   ! input FOR001.DAT not found
      ELSE
       NNFLAG = 1   ! finished
      ENDIF
C
      RETURN
      END

      SUBROUTINE ABOUT
C
      COMMON /BLOC2/ NIN, NOUT, FORMIO
      LOGICAL FORMIO
C
      WRITE(NOUT,*) ' '
      WRITE(NOUT,1000)
 1000 FORMAT('Trans32.DLL computational part for Transport',
     X     ' Framework, compiled by U. Rohrer (PSI), 8-Dec-2009')
      WRITE(NOUT,*) ' '
C
      RETURN
      END
C------------------------------------- EOF -------------------------------------
