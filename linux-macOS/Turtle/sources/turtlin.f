      PROGRAM TURTLE
C     (TRACE UNLIMITED RAYS THROUGH LUMPED ELEMENTS)
C     MAKES ONE AND TWO DIMENSIONAL HISTOGRAMS FROM TRANSPORT DECK
C     INCLUDES EFFECTS OF MANY HIGHER ORDER ABERRATIONS
C     CREATED BY DAVID C. CAREY    APRIL 1971
C
C     CERN VERSION 2.0, AUGUST 21, 1973.
C     REWRITTEN BY CH. ISELIN TO INCLUDE DECAY.
C
C     MODIFIED FOR PROSPERO FORTRAN-77 COMPILER (ANSI 77) FOR ATARI ST
C     BY URS ROHRER (SIN) IN JANUARY 1987
C
C     MODIFIED FOR MS-FORTRAN COMPILER FOR IBM-PC
C     BY URS ROHRER (PSI) IN APRIL 1989
C
C     MODIFIED FOR LAHEY F77L/EM32 FORTRAN COMPILER FOR IBM-PC
C     BY URS ROHRER (PSI) IN MARCH 1990
C
C     MODIFIED FOR DPMI-TURTLE FOR WINDOWS
C     BY URS ROHRER (PSI) IN OCTOBER 1992
C
C     MODIFIED FOR POWERSTATION FORTRAN (VERSION 1.0)
C     BY URS ROHRER (PSI) IN NOVEMBER 1993
C
C     MULTIPLE SCATTERING, NUCLEAR ELASTIC SCATTERING AND NUCLEAR
C     ABSORPTION THROUGH THIN LAYERS OF MATTER ADDED TO THIS VERSION
C     BY U.ROHRER SIN 18-DEC-1981 (EXTRACTED FROM TRIUMF'S REVMOC).
C
C     WIEN FILTER ELEMENT HAS BEEN ADDED TO THIS VERSION BY U.ROHRER
C     SIN 22-SEP-1981 (TM-37-14 BY R.FROSCH, SEPT 1980).
C
C     DECAY HAS BEEN MODIFIED FOR BETA < 1 AND MASSN > 0 BY U.ROHRER
C     SIN 15-MAR-1983.
C
C     SOME OTHER FEATURES ADDED BY U.ROHRER SIN (SEE SPECIAL REPORT).
C
C     POLARISATION OF PI --> MU + NU DECAY INCLUDED BY U.ROHRER(SIN)
C     NOVEMBER 1984
C
C     FRINGE FIELD FOR QUADRUPOLE LENSES HAS BEEN INCLUDED LIKE IN PROG
C     GIOS (H. WOLLNIK, GIESSEN) BY U. ROHRER (SIN), JULY 1986
C
C     3RD-ORDER FOR QUADS, SEXT, OCTU AND BEND-FRINGE (N=0) INCLUDED
C     BY U. ROHRER (SIN), JULY 1986
C
C     OCTUPOLE INCLUDED LIKE IN D.C. CAREY'S 3RD ORDER TRANSPORT (1985)
C     BY U. ROHRER (SIN), JULY 1986
C
C     CHARGE AND ACCELERATOR ADDED BY U. ROHRER (PSI), JANUARY 2001
C     ELECTROSTATIC QUADRUPOLE LENS ADDED BY U. ROHRER, PSI, FEB 2001
C     FRINGE FIELD AND 3RD ORDER FOR EQUAD ADDED BY U. ROHRER, MAR 2001
C     ELECTROSTATIC PRISM (DEFLECTOR) ADDED BY U. ROHRER, PSI, MAR 2001
C     RANDOM ADDITION TO (E)QUAD FIELD ADDED BY U. ROHRER, PSI, APR 2001
C     RANDOM ADDITION TO P0 IN BENDS ADDED BY U. ROHRER, PSI, APR 2001
C     SELECTIVE ORDER-CALCULATION ADDED BY U. ROHRER, PSI, MAY 2001
C     2 ERRORS FOR QUAD FRINGING FIELD CORRECTED, HINTS BY T. PROKSCHA
C     HALTON QUASI-RANDOM GENERATOR ADDED BY U. ROHRER (PSI), APRIL 2002
C     SOLENOID (RUNGE-KUTTA) TRACKING ADDED BY U. ROHRER (PSI), FEB 2004
C     BEND2 FOR ZERO B-FIELD ADDED BY U. ROHRER (PSI), FEB 2004
C     2 OVERLAPPING SOLENOIDS (TC 28) BY U. ROHRER (PSI), MARCH 2004
C
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
C      DESCRIPTION OF FUNCTIONS AND SUBROUTINES
C
C ----------------------------------------------------------------------
C BLOCKDATA  CONTAINS TABLES FOR MOLIERE AND LANDAU DISTRIBUTIONS.
C SUBROUTINE APLIM PRINTS A TABLE OF PARTICLES HITTING APERTURES.
C FUNCTION   BCDW(INTGER) RETURNS INTEGER AS RIGHT-JUSTIFIED EBCDIC
C                  WORD.
C SUBROUTINE BEND TRACKS CHARGED PARTICLES THROUGH A BENDING MAGNET.
C SUBROUTINE BEND2 TAKES A BEND AS A DRIFT IF B-FIELD IS ZERO.
C SUBROUTINE BKOLL(IAP,LFLAG,*,*) TREATS COLLIMATOR FILLED WITH BALLS
C LGL. FUNC. BSTOP RETURNS .TRUE., IF A PARTICLE HITS A BENDING OR
C                  WIEN FILTER APERTURE
C SUBROUTINE CHKBIN(X1,X2,DX,INTVL) CHECKS HISTOGRAM BINNING PARAMETERS.
C SUBROUTINE CORREL(CHI,X1,X2,NR) RETURNS TWO CORRELATED RANDOM NUMBERS FOR
C                              GAUSSIAN DISTRIBUTION.
C SUBROUTINE CORRL2(CHI,XM,X1,X2,NR) RETURNS TWO CORRELATED RANDOM NUMBERS
C                                  FOR BINOMIAL DISTRIBUTION.
C SUBROUTINE DECAY TREATS DECAY CINEMATICS.
C SUBROUTINE DECAYP PREPARES DATA FOR DECAY.
C SUBROUTINE DECAYZ GENERATES RANDOM DECAY POSISTION.
C SUBROUTINE DEDXD HANDLES DE/DX-DATA INPUT IN SBR SETUP
C ENTRY      DEDXD2 PREPARES DE/DX-DATA IN SBR RAYRUN FOR SBR MULT
C FUNCTION   DIGIT(INT,IR) RETURNS ONE DIGIT OF AN INTEGER AS A
C                  RIGHT-JUSTIFIED EBCDIC WORD.
C FUNCTION   DINLAN(X) COMPUTES THE LANDAU DISTRIBUTION
C SUBROUTINE EFIELD TRACKS CHARGED PARTICLE THROUGH CROSSED E-B-FIELD
C SUBROUTINE EHIST(LOST)     ENTERS A RAY INTO HISTOGRAMS
C SUBROUTINE ELLIPS(IPLOT,AMIN,NA,DA,DMIN,ND,DD) COMPUTES ELLIPSE PARA-
C                    METERS OF 2-DIM HISTOGRAMS.
C SUBROUTINE EMIT(IER)  GENERATES A RANDOM INITIAL RAY.
C SUBROUTINE ENTMAT(A,D,MATRIX,AMIN,AMAX,NA,DA,DMIN,DMAX,ND,DD,W) ENTERS
C                  (X,Y) COORDINATE FOR 2 DIMENSIONAL HISTOGRAMS.
C SUBROUTINE EPRISM TRACKS PARTICLE THROUGH A ELECTROSTATIC PRISM
C SUBROUTINE FILEIO HANDELS INTERMEDIATE IO TO DISKFILE.
C SUBROUTINE FOCBND COMPUTES 3RD-ORDER MATRIX-ELEMENTS FOR BEND FRINGE
C SUBROUTINE FOCSG COMPUTES TRANSFER MATRICES FOR LINEAR DIPOLES AND
C                        QUADRUPOLES.
C SUBROUTINE FOCSG3 COMPUTES 3RD-ORDER MATRIX-ELEMENTS FOR QUADS
C SUBROUTINE FOCSG3E COMPUTES 3RD-ORDER MATRIX-ELEMENTS FOR E-QUADS
C SUBROUTINE getfield COMPUTES MAGNETIC FIELD VALUES FOR SOLORUKA
C SUBROUTINE HEDING     PRINTS LIST OF HISTOGRAMS DESIRED.
C SUBROUTINE HISCAP PRINTS HISTOGRAM CAPTIONS.
C SUBROUTINE HISTLO(LFLAG,WABS) ENTERS LOSSES IN LOSS HISTOGRAMS.
C SUBROUTINE HISTO(X,NHST,M,A,B,DX,W) ENTERS X INTO HISTOGRAM ARRAY NHST
C SUBROUTINE HSTUN  FINDS CONVERSION FACTOR FOR HISTOGRAM COORDINATE.
C REAL FUNC. HSTVAL(NCO,LFLAG)  RETURNS THE VALUE TO BE HISTOGRAMMED.
C SUBROUTINE INITZR CLEARS DATA STORAGE BEFORE SETTING UP SYSTEM.
C SUBROUTINE JUMP(IAP) JUMPS OVER COLLIMATOR ELEMENTS, IF PARTICLE DOES NOT HIT
C SUBROUTINE LOADX(XSS,NUM) INSERTS X'S INTO ACTUAL HISTOGRAM.
C SUBROUTINE MULT(LFLAG,IAP,STOPED) COMPUTES THE MULTIPLE SCATTERING,
C                  THE ELASTIC NUCLEAR SCATTERING AND ABSORBTION.
C SUBROUTINE MULTI TREATS MULTIPOLE ABERRATIONS IN QUADRUPOLES.
C INT. FUNC. NEXTI(I,ITYPE) FIND I OF NEXT CARD WITH TYPE CODE ITYPE
C INT. FUNC. NU(TYPE) NUMBER OF DATA ELEMENTS STORED INTERNALLY IN
C                  PROGRAM TO REPRESENT A GIVEN TYPE CODE.
C SUBROUTINE OCTO TRACKS PARTICLE THROUGH A OCTUPOLE.
C LGL. FUNC. OSTOP RETURNS .TRUE. IF A PARTICLE HITS A OCTUPOLE APERTURE.
C SUBROUTINE OHIST HISTOGRAM OUTPUT ROUTINE.
C SUBROUTINE OKOLL(IAP,LFLAG,*) CHECKS OUTER COLLIMATOR DIMENSIONS
C SUBROUTINE OUTMAT PRINTS 2 DIMENSIONAL HISTOGRAMS
C SUBROUTINE PKOLL(IAP,LFLAG,*,*) TREATS COLLIMATOR CUT BY COOLING PIPES
C SUBROUTINE PRINT1 PRINTS DATA FOR ONE ELEMENT
C LGL. FUNC. QSTOP RETURNS .TRUE. IF A PARTICLE HITS A QUADRUPOLE APERTURE.
C SUBROUTINE QUAD   TRACKS CHARGED PARTICLES THROUGH A QUADRUPOLE.
C SUBROUTINE RAYRUN  TRACKS RAYS AND GENERATES HISTOGRAMS.
C SUBROUTINE RDELMT READS DATA FOR ONE ELEMENT
C SUBROUTINE RDFIX  READS ONE INTEGER
C SUBROUTINE RDFLT  READS ONE FLOATING-POINT NUMBER
C SUBROUTINE RDNEXT DELIVERS THE NEXT INPUT CHARACTER
C SUBROUTINE RDSKIP SKIPS COMMENTS ON INPUT.
C SUBROUTINE RDSTRG READS A CHARACTER STRING
C SUBROUTINE REPETI KEEPS TRACK OF TYPE CODE 9 (REPEAT ELEMENT).
C SUBROUTINE RESLIT RESTORES INITIAL SLIT DIMENSION (IF CONE=.TRUE.).
C SUBROUTINE RSETR(A,B)  COPIES RAY B INTO RAY A
C SUBROUTINE RMSADD HANDELS RMS ADDITIONS TO THE BEAM.
C SUBROUTINE SAVSLT STORES ALL INITIAL SLIT DIMENSIONS FOR RESLIT.
C LGL. FUNC. SESTOP RETURNS .TRUE. IF A PARTICLE HITS A SEXTUPOLE APER.
C SUBROUTINE SETUP DIRECTS READING OF DATA " PREPROCESSES IT FOR USE IN
C                  RAY TRACING.
C SUBROUTINE SEXT TRACKS CHARGED PARTICLES THROUGH A SEXTUPOLE.
C SUBROUTINE SOLO TRACKS CHARGED PARTICLES THROUGH A SOLENOID.
C SUBROUTINE SOLORUKA TRACKS THROUGH SOLENOID WITH RUNGE-KUTTA
C LGL. FUNC. SOSTOP RETURNS .TRUE. IF A PARTICLE HITS A SOLENOID APER.
C LGL. FUNC. SOSTOP2 RETURNS .TRUE. IF A PARTICLE HITS A SOLO2 APER.
C SUBROUTINE SPSHLR(NM,LFLAG) TREATS SPECIAL PARAMETERS IN RAYRUN.
C SUBROUTINE SPSHLS(NM,*,*) TREATS SPECIAL PARAMETERS IN SETUP.
C SUBROUTINE TRHIST(NAME,NHST,M,A,D) PRINTS ONE DIMENSIONAL HISTOGRAM.
C SUBROUTINE WIEN TRACKS CHARGED PARTICLES THROUGH A WIEN FILTER.
C SUBROUTINE ZERO CLEARS HISTOGRAM STORAGE.
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
C      DESCRIPTION OF COMMON BLOCKS AND VARIABLES
C
C ----------------------------------------------------------------------
C BLOC1               REPRESENTATION OF BEAM LINE
C DATA(NND)              STORAGE FOR TYPE CODES, RELATED MATRIX
C                        ELEMENTS, ETC.
C I                      POINTER WITHIN DATA ARRAY.
C I1                     MAXIMUM VALUE OF I.
C NEL                    NUMBER OF ELEMENT IN INPUT DECK.
C BLOC1A              REPRESENTATION OF BEAM LINE
C LABEL(NNL) CHAR*4      CONTAINS USER PROVIDED LABELS.
C ----------------------------------------------------------------------
C BLOC2               UNITS CHANGES
C UNIT(12)               CONVERSION UNITS.
C BLOC2A              UNITS CHANGES
C NAME(12)   CHAR*4      NAMES OF UNITS.
C NOM(12)    CHAR*4      NAMES OF COMPONENTS OF THE COORDINATE VECTOR.
C NOM1(4)    CHAR*4      NAMES OF ALGEBRAIC COORDINATE COMBINATIONS.
C DSTOR(20)  CHAR*4      NAMES OF UNITS ON 15. CARDS
C ----------------------------------------------------------------------
C BLOC3               FORTRAN I/O UNITS
C NIN                    UNIT NUMBER FOR INPUT DATA.
C NOUT                   UNIT NUMBER FOR PRINTOUT.
C ----------------------------------------------------------------------
C BLOC4               INPUT PHASE SPACE
C RAYMAX(6)              MAXIMUM EXTENTS OF ORIGINAL PHASE SPACE.
C PBEAM                  ORIGINAL CENTRAL MOMENTUM OF THE BEAM.
C P0                     DESIGN MOMENTUM OF THE BEAM LINE.
C NORAYS                 NUMBER OF RAYS.
C ----------------------------------------------------------------------
C BLOC5               SPECIAL THINGS
C SEC          LOGICAL   TRUE IF THIS IS A SECOND ORDER RUN.
C CAP(3)       LOGICAL   TELLS IF APERTURES ARE TO BE OBSERVED.
C MPA          LOGICAL   TRUE IF MULTIPOLES FOR QUARS ARE USED.
C THIRD        LOGICAL   TRUE IF THIS IS A THIRD ORDER RUN.
C ----------------------------------------------------------------------
C BLOC6               COUNTS OF HISTOGRAMS " STORAGE
C NHISTS                 TOTAL NUMBER OF HISTOGRAMS.
C NHIST                  NUMBER OF CURRENT HISTOGRAMS.
C LIMNO                  AMOUNT OF STORAGE USED FOR HISTOGRAMS.
C ----------------------------------------------------------------------
C BLOC7               INFORMATION ABOUT HISTOGRAMS
C MTYPE(100)             TYPE OF HISTOGRAM. (50, 51, OR 52)
C NENTRY(100)            BEGINNING OF HISTOGRAM STORAGE IN MTABLE.
C NCOOR(100)             COORDINATE TO BE HISTOGRAMED.
C INTVLS(100)            NUMBER OF INTERVALS TO BE IN HISTOGRAM.
C BEGIN(100)             LOWER LIMIT.
C END(100)               UPPER LIMIT.
C STEP(100)              STEP SIZE.
C ZHIST(100)             LONGITUDINAL POSITION OF HISTOGRAM REQUEST.
C BLOC7A              INFORMATION ABOUT HISTOGRAMS
C LTAG(100)   CHAR*4     USER PROVIDED LTAG (LABEL IN TRANSPORT).
C ----------------------------------------------------------------------
C BLOC8               HISTOGRAM STORAGE
C MTABLE(50000) REAL
C ----------------------------------------------------------------------
C BLOC9               QUANTITIES DESCRIBING DIPOLES
C L            REAL      LENGTH OF ELEMENT.
C H                      1/RADIUS OF CURVATURE.
C N            REAL      NORMALIZED FIELD GRADIENT.
C BDB                    NORMALIZED SECOND DERIVATIVE OF B.
C ----------------------------------------------------------------------
C BLOC10              PERTAINS TO FRINGING FIELDS
C APB(2)                 PARAMETER ON 16. 4. AND 16. 5. CARDS.
C LAYL         REAL      K(1) ON 16. 7. CARD, PAGE 16-4 SLAC 91.
C LAYX         REAL      K(2) ON 16. 8. CARD, PAGE 16-4 SLAC 91.
C RAB1                   CODE 12 ON PAGE 16-3 SLAC 91.
C RAB2                   CODE 13 ON PAGE 16-3 SLAC 91.
C FACE                   BETA ANGLE OF POLE FACE ROTATION.
C ----------------------------------------------------------------------
C BLOC11              ELLIPTICAL APERTURE FOR QUADRAPOLES
C QAP(3)                 DIMENSIONS FOR QUADRUPOLE APERTURES.
C ELLIPS       LOGICAL   TRUE IF ELLIPTICAL APERTURE FOR QUADS HAS
C                        BEEN SPECIFIED.
C HYPER        LOGICAL   TRUE IF HYPERBOLIC APERTURE FOR QUADS HAS
C                        BEEN SPECIFIED.
C ---------------------------------------------------------------------
C BLOC12              PERTAINS TO HISTOGRAM FLAGGING
C VALUE(100)             VALUES TO BE HISTOGRAMMED.
C XMOM(100)              FIRST MOMENTS.
C XMOM2(100)             SECOND MOMENTS.
C NFLAG(100)             FLAG NUMBER FOR HISTOGRAM.
C SET(100)     LOGICAL   TELLS IF COORDINATE TO BE HISTOGRAMMED HAS
C                        BEEN STORED INTO VALUE
C KFLAG(100)             PARTICLE KIND TO BE HISTOGRAMMED
C IFLAG(3,0:9) LOGICAL   IFLAG(I,K) TELLS IF PARTICLE I HAS ENCOUNTERED
C                        THE FLAG K.
C ZFLAG(9)               LOCATION OF FLAG.
C WZ(100)                WEIGHT OF PARTICLE.
C UFLAG(100)   LOGICAL   TRUE IF FLAGGING IS LOGICALLY REVERSED
C INVFL        LOGICAL   TRUE IF FLAGGING IS LOGICALLY REVERSED
C ZC           REAL      Z-COORDINATE FOR HISTOGRAMS
C --------------------------------------------------------------------
C BLOC13              DATA FOR THE CURRENT PARTICLE TO BE TRACKED.
C RAY(6)                 CURRENT RAY COORDINATES
C RAYC(6)                STARTING CONDITIONS FOR CHARGED DAUGHTER
C RAYN(6)                STARTING CONDITIONS FOR NEUTRAL DAUGHTER
C P                      MOMENTUM OF PARENT
C PC                     MOMENTUM OF CHARGED DAUGHTER
C PN                     MOMENTUM OF NEUTRAL DAUGHTER
C FLD                    DECAY LENGTH / MOMENTUM
C MASS         REAL      PARENT MASS
C MASSC        REAL      CHARGED DAUGHTER MASS
C MASSN        REAL      NEUTRAL DAUGHTER MASS
C PSTAR                  MOMENTUM IN C.M. FOR THE PARTICULAR DECAY
C FC                     ENERGY / MOMENTUM IN C.M. OF CHARGED DAUGHTER
C FN                     ENERGY / MOMENTUM IN C.M. OF NEUTRAL DAUGHTER
C ZMAX                   IF NON-ZERO, MAXIMUM LENGTH OF DECAY CHANNEL
C DKFLAG       LOGICAL   TRUE, IF DECAY IS TO BE CONSIDERED
C Z                      CURRENT LONGITUDINAL POSITION OF PARTICLE
C                        TRACKED.
C ----------------------------------------------------------------------
C BLOC14              DATA FOR MULTIPOLE ABERRATIONS IN QUADRUPOLES
C MMAX                   LARGEST ORDER OF MULTIPOLES TO BE CONSIDERED
C GTOP                   FACTOR FOR MULTIPOLES
C DB(20)                 MULTIPOLE COEFFICIENTS
C COSM(20)               COSINE OF PHASE ANGLES
C SINM(20)               SINE OF PHASE ANGLES
C ----------------------------------------------------------------------
C BLOC15              MISCELLANEOUS DATA FOR TRACKING
C LL           REAL      LENGTH OR FRACTIONAL LENGTH OF AN ELEMENT
C KH2          REAL      KX ** 2
C KV2          REAL      KY ** 2
C KH           REAL      KX
C KV           REAL      KY
C KHL          REAL      KX * L
C KVL          REAL      KY * L
C RAY2(6)                TEMPORARY STORE FOR RAY COORDINATES
C RH(4)                  HORIZONTAL FIRST ORDER MATRIX
C RV(4)                  VERTICAL FIRST ORDER MATRIX
C LILENS       LOGICAL   TRUE IF QUADS ARE TO BE TAKEN AS LITHIUM LENSES
C SOLSEG       LOGICAL   TRUE IF SOLENOID IS DIVIDED INTO ENTRANCE FRINGE
C                        FIELD, HOMOGENEOUS AND EXIT FRINGE FIELD SECTIONS
C ----------------------------------------------------------------------
C BLOC15A             MISCELLANEOUS DATA FOR TRACKING
C EQUAD        LOGICAL   TRUE IF QUAD IS A ELECTROSTATIC QUAD
C EBEND        LOGICAL   TRUE IF BEND IS A ELECTROSTATIC PRISM
C BSCAL        REAL      SCALING FACTOR FOR FIELD IN TYPE CODE 28 (FIRST)
C BSCAL2       REAL      SCALING FACTOR FOR FIELD IN TYPE CODE 28 (SECOND)
C NSCAL        INT       1 OR 2 FOR BSCAL OR BSCAL2 FOR REMAINIG 28 CODES.
C ISWITCH      INT       1 IF AUTOMATIC SWITCH FROM 2 TO 1
C ----------------------------------------------------------------------
C BLOC16              TABLE OF PARTICLES HITTING THE APERTURES
C ISTOP(3,9998)           NUMBER OF PARTICLES HITTING APERTURES
C BLO16A              TABLE OF PARTICLES HITTING THE APERTURES
C KPART(3)     CHAR*4     PARTICLE NAMES
C ----------------------------------------------------------------------
C BLOC17              PERTAINS TO REPEAT ELEMENT
C IP                     LEVEL OF NESTED REPEATS
C IC(4)                  REPETITION COUNT
C IS(4)                  POINTS TO BEGIN OF REPETITION SECTIONS
C INEL(4)                POINTS TO BEGINNING ELEMENT NUMBER
C ----------------------------------------------------------------------
C BLOC18              LOSS HISTOGRAMS
C LOSS                   NUMBER OF LOSS HISTOGRAMS SPECIFIED
C NBLK (20)              BLOCK ADDRESS OF COUNTER AREA
C KFLG (20)              PARTICLE FLAG
C XSTRT(20)              LOWER X COORDINATE
C XEND (20)              UPPER X COORDINATE
C LTHX (20)              NUMBER OF X BINS
C XBIN (20)              X BIN SIZE
C NUNX (20)              NUMBER OF X UNIT
C YSTRT(20)              LOWER Y COORDINATE
C YEND (20)              UPPER Y COORDINATE
C LTHY (20)              NUMBER OF Y BINS
C YBIN (20)              Y BIN SIZE
C NUNY (20)              NUMBER OF Y UNIT
C ----------------------------------------------------------------------
C BLOC19              CONTAINS SLIT APERTURES FOR CONICAL COLLIMATORS
C CONE         LOGICAL   TRUE IF 16. 177. CARD ENCOUNTERED
C ISTOR(100)   INTEGER   I-POINTER FOR SLIT CARDS
C SLIT1(100)   REAL      FIRST HALF AXIS
C SLIT2(100)   REAL      SECOND HALF AXIS
C NSLIT        INTEGER   NUMBER OF SLIT CARDS.
C ORIG         LOGICAL   TRUE IF SLIT DIMENSIONS ARE RESET
C ISLT         INTEGER   I-POINTER TO SLIT CARD
C IFF          INTEGER   FIRST COORDINATE ON SLIT CARD
C IFG          INTEGER   SECOND COORDINATE ON SLIT CARD
C A            REAL      FIRST HALF APERTURE ON SLIT CARD
C B            REAL      SECOND HALF APERTURE ON SLIT CARD
C RECTA        LOGICAL   TRUE IF SLIT CONTOURS ARE RECTANGULAR
C ----------------------------------------------------------------------
C BLOC20              CONTAINS DATA FOR COLLIMATOR FILLED WITH BALLS
C BALLS        LOGICAL   TRUE IF COOLIMATOR IS FILLED WITH BALLS
C BDIAM        REAL      DIAMETER OF BALLS
C WTHIK        REAL      WALL THICKNESS OF COLLIMATOR CASE
C ----------------------------------------------------------------------
C BLOC21              CONTAINS DATA FOR COLLIMATOR CUT BY COOLING PIPES
C PIPES        LOGICAL   TRUE IF COOLIMATOR IS CUT BY COOLING PIPES
C DIST         REAL      Y-DISTANCE OF COOLING PLATE FROM COLLIMATOR AXIS
C PTHIK        REAL      THICKNESS OF COOLING REGION
C PRAD         REAL      OUTER RADIUS OF COOLING TUBING
C PPER         REAL      DISTANCE BETWEEN COOLING TUBES
C TTHIK        REAL      WALL THIKNESS OF COOLING TUBES
C ----------------------------------------------------------------------
C BLOC22              CONTAINS DATA FOR OUTER DIMENSIONS OF COLLIMATOR
C ODIMX        REAL      OUTER X-HALF DIMENSION OF COLLIMATOR
C ODIMY        REAL      OUTER Y-HALF DIMENSION OF COLLIMATOR
C OUTREC       LOGICAL   TRUE IF OUTER DIMENSIONS ARE RECTANGULAR
C OUTDIM       LOGICAL   TRUE IF OUTER DIMENSIONS OF COLLIMATOR GIVEN
C ----------------------------------------------------------------------
C BLOC23              CONTAINS DATA FOR SBR APLIM
C NCOUNT                 CONCATINATION FACTOR FOR SLIT LOSSES
C ----------------------------------------------------------------------
C BLOC41              CONTAINS DATA FOR ELEMENT JUST READ
C LW                     LENTH OF TITLE
C FLUSH        LOGICAL   TELLS IF RUN HAS BEEN FLUSHED
C INDIC                  NOT USED
C NTYPE                  TYPE CODE OF ELEMENT CURRENTLY BEING READ
C LENGTH                 EXPECTED NUMBER OF DATA ITEMS
C NWORD                  ACTUAL NUMBER OF DATA ITEMS
C NVARY                  NUMBER OF VARY CODES
C DATUM(30)              DATA ITEMS READ FOR CURRENT ELEMENT
C VARY(30)     INTEGER   VARY CODES FOR CURRENT ELEMENT
C BLO41A              CONTAINS DATA FOR ELEMENT JUST READ
C IMAGE(80)    CHAR*1    RUN TITLE IN (80A1)
C LABLE        CHAR*1    LABEL OF THIS ELEMENT
C --------------------------------------------------------------------
C BLOC42              CHARACTER CODES USED FOR FREE-FORMAT DECODING
C TABLE(36)    CHAR*1    DIGITS AND LETTERS
C PLUS(2)      CHAR*1    + &
C MINUS        CHAR*1    -
C BLANK        CHAR*1    BLANK
C PERIOD       CHAR*1    .
C SEMI(5)      CHAR*1    ; ' * ! ?
C QUOTE(6)     CHAR*1    / ' # $ = "
C PAR1(2)      CHAR*1    ( <
C PAR2(2)      CHAR*1    ) >
C --------------------------------------------------------------------
C BLOC43              CURRENT INPUT CARD BEING DECODED
C NCD                    NUMBER OF CURRENT INPUT CARD
C MC                     CURRENT INPUT CHARACTER POSITION
C EMPTY        LOGICAL   TELLS IF CURRENT CARD IS EMPTY
C BLO43A              CURRENT INPUT CARD BEING DECODED
C CARD(120)    CHAR*1    CURRENT INPUT CARD IMAGE
C ITEM         CHAR*1    CURRENT INPUT CHARACTER VALUE
C ----------------------------------------------------------------------
C BLOC44              FOR SLITS AND SEPTA
C LINV         LOGICAL   TRUE IF SLITS ARE TO BE TAKEN INVERSE
C                        FALSE IF NORMAL SLITS
C                        TRUE IF 16. 160. CARD ENCOUNTERD
C                        FALSE IF 16. 161. CARD ENCOUNTERED
C SINV         LOGICAL   TRUE IF SIGN OF ANGLE SHIFT IS DEPENDENT ON
C                        SIGN OF POSITION OF RAY
C                        TRUE IF 16. 170. CARD ENCOUNTERED
C                        FALSE IF 16. 171. CARD ENCOUNTERED
C SINV2        LOGICAL   TRUE IF ANGLE SHIFT APPLIES ONLY FOR
C                        POSITIVE RAY POSITION
C                        TRUE IF 16. 172. CARD ENCOUNTERED
C                        FALSE IF 16. 171. CARD ENCOUNTERED
C MULTSC       LOGICAL   TRUE IF MULTIPLE SCATTERING INSTEAD OF RMSADD
C                        TRUE IF 16. 165. CARD ENCOUNTERD
C                        FALSE IF 16. 166. CARD ENCOUNTERD
C ----------------------------------------------------------------------
C BLOC45              FOR EMIT
C CHIX         REAL      X,X'-CORRELATION PHASE ANGLE
C SNCHIX       REAL      SINE OF PHASE ANGLE
C CSCHX2       REAL      SQUARE OF COSINE OF PHASE ANGLE
C CHIY         REAL      Y,Y'-CORRELATION PHASE ANGLE
C SNCHIY       REAL      SINE OF PHASE ANGLE
C CSCHY2       REAL      SQUARE OF COSINE OF PHASE ANGLE
C GAUSS        LOGICAL   TRUE IF GAUSSIAN DISTRIBUTIONS ARE TAKEN
C VOL4         LOGICAL   TRUE IF 4VOL DISTRIBUTION IS TAKEN IN EMIT
C ----------------------------------------------------------------------
C BLOC46              FOR WIEN FILTER AND MULTIPLE SCATTERING
C SM           REAL      PARTICLE MASS IN UNITS OF ELECTRON MASSES
C GAMMA0       REAL      RELATIVISTIC EXPRESSION (M/M0)
C BETA0        REAL      RELATIVISTIC EXPRESSION (V0/C)
C CHARGE       REAL      PARTICLE CHARGE IN UNITS OF ELECTRON CHARGE
C ----------------------------------------------------------------------
C BLOC47              FOR RANDOM INITIALIZATION
C IRAN                   SEED OF RANDOM GENERATOR (IF NOT ZERO)
C ----------------------------------------------------------------------
C BLOC48              FRINGE FIELD INTEGRALS FOR QUADS
C XI1          REAL   SEE NUCL. INST. AND METH. 103 (1972) P.117-124
C XI2          REAL
C XI3          REAL
C XI4          REAL   ONLY FOR THIRD ORDER CONTRIBUTIONS
C ----------------------------------------------------------------------
C BLOC49              TABLES FOR MULTIPLE SCATTERING
C F(40)        REAL      TABLE FOR MOLIERE ANGULAR DISTRIBUTION
C F0(40)       REAL        "    "     "       "         "
C F1(40)       REAL        "    "     "       "         "
C F2(40)       REAL        "    "     "       "         "
C FM1A(40)     REAL        "    "     "       "         "
C BL(260)      REAL        "    "  LANDAU DISTRIBUTION
C ----------------------------------------------------------------------
C BLOC50              LOSS HISTOGRAMS: SUPPRESSION OF ENTRIES
C NOSUP        INTEGER   NUMBER OF SUPPRESSED ENTRIES
C LABSUP(20)   INTEGER   LABEL WITH SUPPRESSED ENTRY
C ----------------------------------------------------------------------
C BLOC51              FOR INTERMEDIATE OUTPUT
C IOCASE(5)    INTEGER   WHICH WAY TO SELECT IN SUBROUTINE FILEIO
C IOUNIT(5)    INTEGER   FILE UNIT ON WHICH TO READ/WRITE DATA
C IONUM        INTEGER   NUMBER OF I/O-FILES
C UNIT1        INTEGER   FILE UNIT FROM WHICH RAYS ARE READ
C ----------------------------------------------------------------------
C BLOC52              FOR TRANSFERING STAT WEIGHT OF PARTICLE AND POL
C W            REAL      WEIGHT OF PARTICLE (SEE REVMOC)
C POLX(0:2)    REAL      X-COMP OF POLARIZATION (0: PARENT PARTICLE)
C POLY(0:2)    REAL      Y-COMP OF POLARISATION (1: CHARGED DAUGHTER)
C POLZ(0:2)    REAL      Z-COMP OF POLARISATION (2: NEUTRAL DAUGHTER)
C POLCAL       LOGICAL   TRUE IF POLARISATION HAS TO BE COMPUTED
C ----------------------------------------------------------------------
C BLOC53              MOMENTUM OR ENERGY ON BEAM CARD ?
C ENERGY       LOGICAL   TRUE IF ENTRIES ON BEAMCARD MEAN ENERGY VALUES
C ----------------------------------------------------------------------
C BLOC54              BINOMIAL DISTRIBUTION
C BINOM        LOGICAL   TRUE IF BEAM DISTRIBUTIONS ARE BINOMIAL
C XM           REAL      PARAMETER FOR (X,X')-DISTRIBUTION
C YM           REAL      PARAMETER FOR (Y,Y')-DISTRIBUTION
C ZM           REAL      PARAMETER FOR (Z,DP/P)-DISTRIBUTION
C XNORM        REAL      PARAMETER FOR NORMALISATION IN X
C YNORM        REAL      PARAMETER FOR NORMALISATION IN Y
C ZNORM        REAL      PARAMETER FOR NORMALISATION IN Z
C ----------------------------------------------------------------------
C BLOC55              DE/DX - DATA FOR INTERPOLATION IN SBR MULT
C DEDX(3)      LOGICAL   TRUE IF DATA ARE PRESENT, INDEX: PART-ID / 100
C VEKIN(3,5)   REAL      LOG10-VALUES OF ENERGIES, 1ST INDEX: PART-ID / 100
C VDEDX(3,5)   REAL      LOG10-VALUES OF DE/DX-VALUES, 2ND INDEX: ENERGY
C ----------------------------------------------------------------------
C BLOC60              RAY - INFORMATION
C NCT          INTEGER   CURRENT RAY NUMBER
C ----------------------------------------------------------------------
C BLOC61              SPECIAL - INFORMATION
C DBQ          REAL   AMPLITUDE FOR RANDOM ADDITION TO QUAD FIELD
C DBQQ         REAL   ACTUAL RANDOM VALUE FOR ADDITION TO QUAD FIELD
C OLDG         REAL   SAVED VALUE OF FIELD GRADIENT OF PREVIOUS QUAD
C DPP0         REAL   AMPLITUDE FOR RANDOM ALTERATION TO P0
C P0SV         REAL   SAVED VALUE OF P0
C ----------------------------------------------------------------------
C BLOC62              SPECIAL - INFORMATION
C IUNIT3RD            UNIT NUMBER OF FILE TO STORE 3RD ORDER INFO
C NUMLIM              NUMBER OF RAYS TO RECORD
C ZZ                  Z COORDINATE
C ----------------------------------------------------------------------
C ----------------------------------------------------------------------
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC2/  UNIT(12)
      COMMON /BLOC2A/ NAME(12), NOM(12), NOM1(4), DSTOR(20)
      CHARACTER*4     NAME, NOM, NOM1, DSTOR
      COMMON /BLOC3/ NIN, NOUT
      COMMON /BLOC4/ RAYMAX(6), PBEAM, P0, NORAYS
      COMMON /BLOC5/ SEC, CAP(3), MPA, THIRD
      LOGICAL         SEC, CAP, MPA, THIRD
      COMMON /BLOC6/ NHISTS, NHIST, LIMNO
      COMMON /BLOC7/ MTYPE(100), NENTRY(100), NCOOR(100), INTVLS(100),
     A                BEGIN(100), END(100), STEP(100), ZHIST(100)
      COMMON /BLOC7A/ LTAG(100)
      CHARACTER*4     LTAG
      COMMON /BLOC8/ MTABLE(50000)
      REAL           MTABLE
      COMMON /BLOC9/ L, H, N, BDB
      REAL            L, N
      COMMON /BLOC10/ APB(2), LAYL, LAYX, RAB1, RAB2, FACE
      REAL            LAYL, LAYX
      COMMON /BLOC11/ QAP(3), ELLIPS, HYPER
      LOGICAL         ELLIPS, HYPER
      COMMON /BLOC12/ VALUE(100), XMOM(100), XMOM2(100), NFLAG(100),
     A                SET(100), KFLAG(100), IFLAG(3,0:9), ZFLAG(9),
     A                WZ(100), UFLAG(100), INVFL, ZC
      LOGICAL SET, IFLAG, UFLAG, INVFL
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC14/ MMAX, GTOP, DB(20), COSM(20), SINM(20)
      COMMON /BLOC15/ LL, KH2, KV2, KH, KV, KHL, KVL, RAY2(6),
     A                RH(4), RV(4), LILENS, SOLSEG
      LOGICAL LILENS, SOLSEG
      REAL LL, KH2, KV2, KH, KV, KHL, KVL
      COMMON /BLOC16/ ISTOP(3,9998)
      REAL ISTOP
      COMMON /BLO16A/ KPART(3)
      CHARACTER*4     KPART
      COMMON /BLOC17/ IP, IC(4), IS(4), INEL(4)
      COMMON /BLOC18/ LOSS, NBLK(20), KFLG(20),
     A                XSTRT(20), XEND(20), LTHX(20), XBIN(20), NUNX(20),
     A                YSTRT(20), YEND(20), LTHY(20), YBIN(20), NUNY(20)
      COMMON /BLOC19/ CONE, ISTOR(100), SLIT1(100), SLIT2(100), NSLIT,
     A                ORIG, ISLT, IFF, IFG, A, B, RECTA
      LOGICAL CONE, ORIG, RECTA
      COMMON /BLOC20/ BALLS, BDIAM, WTHIK
      LOGICAL         BALLS
      COMMON /BLOC21/ PIPES, DIST, PTHIK, PRAD, PPER, TTHIK
      LOGICAL         PIPES
      COMMON /BLOC23/ NCOUNT
      COMMON /BLOC41/ LW, FLUSH, INDIC, NTYPE, LENGTH,
     A                NWORD, NVARY, DATUM(30), VARY(30)
      INTEGER VARY
      LOGICAL FLUSH
      COMMON /BLO41A/ IMAGE(80), LABLE
      CHARACTER       IMAGE*1, LABLE*4
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
      COMMON /BLOC43/ NCD, MC, EMPTY
      LOGICAL EMPTY
      COMMON /BLO43A/ CARD(120), ITEM
      CHARACTER*1     CARD, ITEM
      COMMON /BLOC44/ LINV, SINV, SINV2, MULTSC
      LOGICAL LINV, SINV, SINV2, MULTSC
      COMMON /BLOC46/ SM, GAMMA0, BETA0, CHARGE
      COMMON /BLOC47/ IRAN
      COMMON /BLOC48/ XI1, XI2, XI3, XI4
      COMMON /BLOC49/ F(40),F0(40),F1(40),F2(40),FM1A(40),BL(260)
      COMMON /BLOC50/ NOSUP
      COMMON /BLO50A/ LABSUP(20)
      CHARACTER*4     LABSUP
      COMMON /BLOC51/ IOCASE(5), IOUNIT(5), IONUM, UNIT1
      INTEGER UNIT1
      COMMON /BLOC60/ NCT
      COMMON /BLOC61/ DBQ, DBQQ, OLDG, DPP0, P0SV
      COMMON /BLOC62/ IUNIT3RD, NUMLIM, ZZ
      COMMON /hal/ halton, ipn(10) ,iseries(10)
      LOGICAL HALTON
C
      CHARACTER INPUTF*60
      INTEGER*4 I2RAN
      halton = .FALSE.
C
      IUNIT3RD = 0
      write(*,*) ' '

      OPEN (UNIT = NOUT, FILE = 'FOR002.DAT', STATUS = 'UNKNOWN')
      CALL ABOUT
  100 CALL INITZR
      CALL SETUP
C
      IF (IRAN .NE. 0) THEN
       I2RAN = IRAN
      ELSE
       I2RAN = 0
       DO 101 I = 1, 10
        CALL GETSECS(ISEC)
        I2RAN = I2RAN + ISEC
  101  CONTINUE
      ENDIF
      CALL SEED(I2RAN)
C
      IF (HALTON) THEN
       CALL ERATOS
       DO 104 J = 1,6
         CALL RANDOM(RND)      
         iseries(J) = 12345678.0 * RND
  104  CONTINUE
       WRITE(NOUT,*)
     X   'Using Halton quasi-random generator for emittance.'
      ENDIF
C
      IF(NHISTS + LOSS .EQ. 0) GO TO 900
      CALL ZERO
 1000 FORMAT (/,' ',I5,'  places left for histogram storage.')
      CALL RAYRUN
      CALL FILEIO
      CALL HEDING
      LEFT = 50000 - LIMNO
      WRITE (NOUT, 1000) LEFT
      CALL OHIST
      CALL APLIM
  900 CONTINUE
      GO TO 100
      END
      BLOCK DATA
C
      COMMON /BLOC2/  UNIT(12)
      COMMON /BLOC2A/ NAME(12), NOM(12), NOM1(4), DSTOR(20)
      CHARACTER*4     NAME, NOM, NOM1, DSTOR
      COMMON /BLOC3/ NIN, NOUT
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
      COMMON /BLOC48/ XI1, XI2, XI3, XI4
      COMMON /BLOC49/ F(40),F0(40),F1(40),F2(40),FM1A(40),BL(260)
      DIMENSION B01(90),B91(90),B181(80)
      EQUIVALENCE (B01(1),BL(1)),(B91(1),BL(91)),(B181(1),BL(181))
C
C     BLOCK DATA
C
      DATA UNIT / 0.01, 0.001, 0.01, 0.001, 0.01, 0.01, 0.01745329,
     A            1.0, 1.0, 1.0, 1.0, 1.0 /
      DATA NAME / 'cm  ', 'mrad',  'cm  ', 'mrad',  'cm  ', '%   ',
     A            'deg ', 'm   ',  'KG  ', 'em  ',  'GeVc', 'GeV '/
      DATA NOM  / '   x', '  x''', '   y', '  y''', 'JUNK', 'dp/p',
     A            'JUNK', '   z',  'JUNK', 'JUNK',  '   p', 'Ekin'/
      DATA NOM1 / '   r', '  xi',  ' psi', 'zeta' /
      DATA NIN ,NOUT /1,2/
      DATA TABLE / '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
     A             'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
     B             'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
     C             'U', 'V', 'W', 'X', 'Y', 'Z' /
      DATA    PLUS  / '+', '&' /
      DATA    MINUS / '-' /
      DATA    BLANK / ' ' /
      DATA    PERIOD/ '.' /
      DATA    SEMI  / ';', ',',  '*', '!', '?' /
      DATA    QUOTE / '/', '''', '#', '$', '=', '"' /
      DATA    PAR1  / '(', '<' /
      DATA    PAR2  / ')', '>' /
      DATA    XI1, XI2, XI3, XI4 /0.209, -0.0768, 0.0552, -0.33/
C
      DATA B01
     1    / .004572, -.000808,  .004650, -.000851,  .004730, -.000894,
     2      .004812, -.000940,  .004896, -.000987,  .004983, -.001036,
     3      .005072, -.001087,  .005165, -.001141,  .005261, -.001198,
     4      .005361, -.001257,  .005463, -.001318,  .005568, -.001381,
     5      .005676, -.001445,  .005786, -.001512,  .005899, -.001580,
     6      .006015, -.001651,  .006134, -.001724,  .006257, -.001801,
     7      .006385, -.001881,  .006517, -.001964,  .006654, -.002052,
     8      .006796, -.002144,  .006942, -.002239,  .007094, -.002338,
     9      .007250, -.002441,  .007411, -.002547,  .007577, -.002656,
     A      .007747, -.002770,  .007923, -.002888,  .008106, -.003011,
     B      .008295, -.003140,  .008491, -.003276,  .008696, -.003417,
     C      .008908, -.003566,  .009129, -.003721,  .009358, -.003882,
     D      .009594, -.004050,  .009839, -.004224,  .010092, -.004405,
     E      .010355, -.004594,  .010627, -.004792,  .010911, -.004999,
     F      .011207, -.005217,  .011516, -.005446,  .011838, -.005687/
      DATA B91
     1    / .012174, -.005938,  .012524, -.006202,  .012887, -.006477,
     2      .013266, -.006764,  .013659, -.007065,  .014070, -.007380,
     3      .014499, -.007712,  .014948, -.008062,  .015418, -.008430,
     4      .015912, -.008819,  .016428, -.009228,  .016969, -.009657,
     5      .017535, -.010109,  .018126, -.010583,  .018746, -.011083,
     6      .019396, -.011610,  .020080, -.012167,  .020799, -.012757,
     7      .021557, -.013381,  .022356, -.014043,  .023197, -.014742,
     8      .024083, -.015481,  .025016, -.016262,  .025999, -.017090,
     9      .027037, -.017969,  .028135, -.018903,  .029298, -.019898,
     A      .030531, -.020957,  .031838, -.022085,  .033225, -.023285,
     B      .034696, -.024564,  .036257, -.025926,  .037916, -.027382,
     C      .039684, -.028939,  .041569, -.030609,  .043583, -.032399,
     D      .045736, -.034319,  .048036, -.036379,  .050498, -.038592,
     E      .053134, -.040972,  .055963, -.043537,  .059004, -.046306,
     F      .062280, -.049301,  .065811, -.052541,  .069622, -.056051/
      DATA B181
     1    / .073739, -.059855,  .078193, -.063989,  .083022, -.068488,
     2      .088269, -.073398,  .093982, -.078763,  .100212, -.084633,
     3      .107015, -.091067,  .114459, -.098134,  .122622, -.105916,
     4      .131601, -.114508,  .141501, -.124017,  .152441, -.134565,
     5      .164561, -.146291,  .178023, -.159370,  .193028, -.174007,
     6      .209811, -.190445,  .228648, -.208966,  .249863, -.229909,
     7      .273849, -.253689,  .301095, -.280823,  .332196, -.311935,
     8      .367877, -.347790,  .409035, -.389351,  .456813, -.437850,
     9      .512673, -.494864,  .578483, -.562419,  .656678, -.643194,
     A      .750517, -.740814,  .864427, -.860218, 1.004503,-1.008317,
     B     1.179429,-1.195127, 1.401966,-1.435562, 1.691464,-1.752770,
     C     2.078797,-2.184707, 2.616067,-2.797585, 3.398175,-3.717997,
     D     4.617145,-5.219771, 6.726056,-8.021656,11.099163,-14.783587,
     E     24.693592,-49.761426/
C
      DATA F / 0.0    , 0.10000, 0.20000, 0.30000, 0.40000, 0.50000,
     #0.60000, 0.70000, 0.80000, 0.90000, 1.00000, 1.10000, 1.20000,
     #1.30000, 1.40000, 1.50000, 1.60000, 1.70000, 1.80000, 1.90000,
     #2.00000, 2.20000, 2.40000, 2.60000, 2.80000, 3.00000, 3.20000,
     #3.40000, 3.60000, 3.80000, 4.00000, 5.00000, 6.00000, 7.00000,
     #8.00000, 9.00000,10.00000,11.00000,12.00000,13.00000/
      DATA F0/ 0.0    , 0.009991,0.03924, 0.08610, 0.14790, 0.22120,
     #0.30230, 0.38740, 0.47270, 0.55520, 0.63220, 0.70180, 0.76310,
     #0.81550, 0.85920, 0.89460, 0.92270, 0.94450, 0.96090, 0.97300,
     #0.98170, 0.99210, 0.99690, 0.99890, 0.99960, 0.99990, 0.99999,
     #1.00000, 1.00000, 1.00000, 1.00000, 1.00000, 1.00000, 1.00000,
     #1.00000, 1.00000, 1.00000, 1.00000, 1.00000, 1.00000/
      DATA F1 / 0.0    , 0.004208,0.01553, 0.03107, 0.04648, 0.05697,
     # 0.05814, 0.04688, 0.02186,-0.01626,-0.06499,-0.12050,-0.17820,
     #-0.23350,-0.28240,-0.32180,-0.35000,-0.36650,-0.37180,-0.36730,
     #-0.35490,-0.31480,-0.26650,-0.22050,-0.18140,-0.15040,-0.12630,
     #-0.10780,-0.09324,-0.08167,-0.07227,-0.04333,-0.02912,-0.02092,
     #-0.01575,-0.01227,-0.00981,-0.00801,-0.00665,-0.00559/
      DATA F2 / 0.0    , 0.01240, 0.04570, 0.09146, 0.13750, 0.17150,
     # 0.18400, 0.17050, 0.13230, 0.07637,+0.01279,-0.04712,-0.09346,
     #-0.11970,-0.12330,-0.10620,-0.07317,-0.03107, 0.01306, 0.05306,
     # 0.08456, 0.11490, 0.10640, 0.07683, 0.04383, 0.01764, 0.00093,
     #-0.00787,-0.01150,-0.01231,-0.01180,-0.00642,-0.00344,-0.00188,
     #-.001040,-0.00055,-0.00025,-0.000059,0.00007, 0.000159/
C
      END

      SUBROUTINE APLIM
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC2/  UNIT(12)
      COMMON /BLOC2A/ NAME(12), NOM(12), NOM1(4), DSTOR(20)
      CHARACTER*4     NAME, NOM, NOM1, DSTOR
      COMMON /BLOC3/ NIN, NOUT
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC16/ ISTOP(3,9998)
      REAL ISTOP
      COMMON /BLO16A/ KPART(3)
      CHARACTER*4     KPART
      COMMON /BLOC17/ IP, IC(4), IS(4), INEL(4)
      COMMON /BLOC23/ NCOUNT
C
      REAL SUM(3)
      CHARACTER*4 TYPE(4), TYPE2(4), TYPE3(3), LABLE
      REAL KSTOP(3)
      DATA TYPE / 'Bend', 'Quad', 'Slit', 'Accl' /
      DATA TYPE2/ 'Sext', 'Solo', 'Roto', 'Wien' /
      DATA TYPE3/ 'Octo', 'ExB ', 'Sol2' /
C
      LAST = 1
      IF(DKFLAG) LAST = 3
      WRITE (NOUT, 899)
      IF(LAST.EQ.1) WRITE(NOUT,900) KPART(1)
      IF(LAST.EQ.2) WRITE(NOUT,911) (KPART(J),J=1,2)
      IF(LAST.EQ.3) WRITE(NOUT,912) (KPART(J),J=1,3)
      DO 10 J = 1, LAST
   10 KSTOP(J) = 0.0
      IAP = 0
      I   = 1
      NEL = 0
      ZC  = 0.0
      NC = 0
      SUM(1) = 0.0
      SUM(2) = 0.0
      SUM(3) = 0.0
      FZ = 1.0 / UNIT(8)
   20 NTYPE = IDATA(I)
      NEL = NEL + 1
      LABLE = LABEL(NEL)
      IF(NEL.NE.1 .AND. LABLE.EQ.'    ') LABLE = LABEL(NEL-1)
      IF(NTYPE .LE. 0 .OR. NTYPE .GT. 28) GO TO 90
C
      GO TO (90, 90, 50, 30, 30, 30, 90, 90, 60, 90, 30, 90, 90, 90,
     A       90, 70, 90, 30, 30, 90, 30, 90, 90, 90, 90, 30, 30, 30)
     B      , NTYPE
C
   30 IAP = IAP + 1
      IF (NTYPE .NE. 6) THEN
       IF(ISTOP(1,IAP) + ISTOP(2,IAP) + ISTOP(3,IAP) .EQ. 0) GO TO 50
      ENDIF
      DO 40 J = 1, LAST
   40 KSTOP(J) = KSTOP(J) + ISTOP(J,IAP)
      Z = ZC * FZ
C
      IF (NTYPE .LT. 6)
     A WRITE (NOUT, 910) Z, NAME(8), TYPE(NTYPE-3), LABLE,
     A                  (ISTOP(J,IAP), J = 1, LAST)
C
      IF (NTYPE .EQ. 6) THEN
       NC = NC + 1
       SUM(1) = SUM(1) + ISTOP(1,IAP)
       SUM(2) = SUM(2) + ISTOP(2,IAP)
       SUM(3) = SUM(3) + ISTOP(3,IAP)
       IF (NC.EQ.NCOUNT .OR. IC(1).EQ.1) THEN 
        IF (SUM(1) + SUM(2) + SUM(3) .NE. 0.0) 
     A   WRITE (NOUT, 910) Z, NAME(8), TYPE(3), LABLE,
     A                  (SUM(J), J = 1, LAST)
        SUM(1) = 0.0
        SUM(2) = 0.0
        SUM(3) = 0.0
        NC = 0
       ENDIF
      ENDIF
C
      IF (NTYPE .EQ. 11)
     A WRITE (NOUT, 910) Z, NAME(8), TYPE(4), LABLE,
     A                  (ISTOP(J,IAP), J = 1, LAST)
C
      IF (NTYPE.GE.18 .AND. NTYPE.LE.21)
     A WRITE (NOUT, 910) Z, NAME(8), TYPE2(NTYPE-17), LABLE,
     A                  (ISTOP(J,IAP), J = 1, LAST)
C
      IF (NTYPE .EQ. 26)
     A WRITE (NOUT, 910) Z, NAME(8), TYPE3(1), LABLE,
     A                  (ISTOP(J,IAP), J = 1, LAST)
C
      IF (NTYPE .EQ. 27)
     A WRITE (NOUT, 910) Z, NAME(8), TYPE3(2), LABLE,
     A                  (ISTOP(J,IAP), J = 1, LAST)
C
      IF (NTYPE .EQ. 28)
     A WRITE (NOUT, 910) Z, NAME(8), TYPE3(3), LABLE,
     A                  (ISTOP(J,IAP), J = 1, LAST)
C
   50 IF(NTYPE .EQ. 6) GO TO 90
      IF (NTYPE.EQ.28 .AND. DATA(I+1).LT.0.0) GO TO 90
      ZC = ZC + DATA(I+1)
      GO TO 90
   60 CALL REPETI
      GO TO 90
   70 NM = IDATA(I+1)
      IF (NM .EQ. 198) NCOUNT = DATA(I+2)
      IF (NM .EQ. 93) TYPE(1) = 'Bend'
      IF (NM .EQ. 94) TYPE(1) = 'Pris'
      IF (NM .EQ. 95) TYPE(2) = 'Quad'
      IF (NM .EQ. 96) TYPE(2) = 'Equa'
   90 I = I + NU(NTYPE)
      IF(I .LE. I1) GO TO 20
      WRITE (NOUT, 920) (KSTOP(J), J = 1, LAST)
      WRITE (NOUT, 902)
      RETURN
C
  899 FORMAT(/,
     A       '1         Summary of particles stopped by apertures.'
     A,/,    '          ------------------------------------------')
  900 FORMAT(/'          position',8X,'type',4X,'label',8X,A4/)
  911 FORMAT(/'          position',8X,'type',4X,'label',2(8X,A4)/)
  912 FORMAT(/'          position',8X,'type',4X,'label',3(8X,A4)/)
  902 FORMAT(////)
  910 FORMAT(1X,F15.4,1X,A4,5X,A4,5X,A4,3F12.1)
  920 FORMAT(/'          total',24X,3F12.1)
      END

      CHARACTER*1 FUNCTION BCDW (X)
C
C     RETURNS INTEGER AS RIGHT-JUSTIFIED EBCDIC WORD
C
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
C
      INTGER = X + .000001
      IF (X .GT. 0) GO TO 100
      BCDW = BLANK
      RETURN
  100 IF (INTGER .GT. 35) GO TO 200
      BCDW = TABLE(INTGER+1)
      RETURN
  200 BCDW = QUOTE(4)
      RETURN
      END

      SUBROUTINE BEND2 (KSTOP)
C
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC15/ LL, KH2, KV2, KH, KV, KHL, KVL, RAY2(6),
     A                RH(4), RV(4), LILENS, SOLSEG
      LOGICAL LILENS, SOLSEG
      REAL LL, KH2, KV2, KH, KV, KHL, KVL
C
      KSTOP = 0
      RAY(1) = RAY(1) + LL * RAY(2)
      RAY(3) = RAY(3) + LL * RAY(4)
      RETURN
      END

      SUBROUTINE BEND (KSTOP)
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC4/ RAYMAX(6), PBEAM, P0, NORAYS
      COMMON /BLOC5/ SEC, CAP(3), MPA, THIRD
      LOGICAL         SEC, CAP, MPA, THIRD
      COMMON /BLOC9/ L, H, N, BDB
      REAL            L, N
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC15/ LL, KH2, KV2, KH, KV, KHL, KVL, RAY2(6),
     A                RH(4), RV(4), LILENS, SOLSEG
      LOGICAL LILENS, SOLSEG
      REAL LL, KH2, KV2, KH, KV, KHL, KVL
C
      KSTOP = 0
      H = DATA(I+2)
      N = DATA(I+3)
      BDB = DATA(I+5)
      IF(N .EQ. 0.0 .AND. BDB .EQ. 0.0) GO TO 300
      KH2 = H ** 2 * (1.0 - N)
      KV2 = H ** 2 * N
      CALL FOCSG (KH2, LL, KH, KHL, RH)
      CALL FOCSG (KV2, LL, KV, KVL, RV)
      CX = RH(1)
      SX = RH(2)
      CY = RV(1)
      SY = RV(2)
      IF(ABS(KHL) .LT. 0.01) GO TO 10
      X10 = (1.0 - CX) / KH2
      Q1  = (LL  - SX) / KH2
      Q2  = (3.0 * Q1 - SX * X10) / KH2
      GO TO 20
   10 SKL = KHL ** 2
      X10 = LL ** 2 * (0.5 - SKL / 24.0)
      Q1  = LL ** 3 * (1.0 / 6.0 - SKL / 120.0)
      Q2  = LL ** 5 * (0.1 - SKL / 84.0)
   20 IF(ABS(KVL) .LT. 0.01) GO TO 30
      Y34 = 0.5 * (SY - LL * CY) / KV2
      GO TO 40
   30 Y34 = LL ** 3 * (1.0 / 6.0 - KV2 * LL ** 2 / 60.0)
   40 X11 = 0.5 * LL * SX
      X12 = 0.5 * (LL * X10 - Q1)
      X16 = 0.5 * (X10 ** 2 - SX * Q1)
      X21 = 0.5 * (SX + LL * CX)
      X22 = X11
      X26 = X12
      Y33 = 0.5 * LL * SY
      Y43 = 0.5 * (SY + LL * CY)
      Y44 = Y33
      D = KH2 - 4.0 * KV2
      IF(ABS(D * LL ** 2) .LT. 1.0E-6) GO TO 50
      X144 = (SY ** 2 - 2.0 * X10) / D
      X244 = 2.0 * (SY * CY - SX) / D
      Y324 = (2.0 * CY * X10 - SX * SY) / D
      Y424 = (SX * CY - CX * SY + 2.0 * RV(3) * X10) / D
      GO TO 100
   50 X144 = 2.0 * X16
      X244 = 2.0 * X12
      Y324 = 0.5 * SY * Q1
      Y424 = 0.5 * (SY * X10 + CY * Q1)
  100 X112 = SX * X10 / 3.0
      X116 = 0.5 * SX * Q1 - X10 ** 2 / 6.0
      X122 = X10 ** 2 / 3.0
      X126 = (SX * X10 ** 2 - CX * Q2) / 6.0
      X166 = (X10 ** 3 - SX * Q2) / 3.0
      X212 = (2.0 * SX ** 2 - X10) / 3.0
      X216 = 2.0 * X112 - 0.5 * (LL * X10 - Q1)
      X222 = 2.0 * X112
      X226 = SX * Q1 - X116
      X266 = 2.0 * X126
      Y323 = SY * X10 - Y424
      Y423 = CY * X10 + KV2 * Y324
      Y336 = 0.5 * (SY * Q1 - Y324)
      Y436 = 0.5 * (CY * Q1 + Y323)
      IF(ABS(KH2) .LT. 0.0001) GO TO 110
      Y346 = (Y34 + SY * X10 - 2.0 * Y424) / KH2
      GO TO 120
  110 Y346 = 0.5 * (SY * X10 - CY * Q1 - Y424) / KV2
  120 Y446 = 0.5 * (SY * Q1 + Y324)
      A1 = H ** 3 * (N + N - BDB - 1.0) * 2.0
      A2 = H * (2.0 - N)
      C1 = H ** 3 * (BDB - N) * 2.0
      C2 = H * N
      T116 = A1*X116 - KH2*H*X122 + A2*X11
      T216 = A1*X216 - KH2*H*X222 + A2*X21 - H * (RH(1)*SX + RH(3)*X10)
      T126 = A1*X126 + H*X112 + A2*X12
      T226 = A1*X226 + H*X212 + A2*X22 - H * (RH(2)*SX + RH(4)*X10)
      T166 = 0.5 * (A1*X166 + H*X122) + A2*X16
      T266 = 0.5 * (A1*X266 + H*X222) + A2*X26 - H*X10*SX
      T336 = C1*Y336 - KV2*H*Y324 + C2*Y33
      T436 = C1*Y436 - KV2*H*Y424 + C2*Y43 - H*X10*RV(3)
      T346 = C1*Y346 + H*Y323 + C2*Y34
      T446 = C1*Y446 + H*Y423 + C2*Y44 - H*X10*RV(4)
      DH = H * (P - P0) / P
      RAY2(1) = (RH(1) + DH*T116) * RAY(1) + (RH(2) + DH*T126) * RAY(2)
     A        + (X10  + DH*T166) * DH
      RAY2(2) = (RH(3) + DH*T216) * RAY(1) + (RH(4) + DH*T226) * RAY(2)
     A        + (SX   + DH*T266) * DH
      RAY2(3) = (RV(1) + DH*T336) * RAY(3) + (RV(2) + DH*T346) * RAY(4)
      RAY2(4) = (RV(3) + DH*T436) * RAY(3) + (RV(4) + DH*T446) * RAY(4)
      IF(.NOT. SEC) GO TO 200
      X111 = X10 - KH2 * X122
      X133 = X10 - KV2 * X144
      X134 = 0.5 * X244
      X211 = SX  - KH2 * X222
      X233 = SX  - KV2 * X244
      X234 = X133 - KV2 * X144
      Y313 = 0.5 * (SX * SY + KH2 * Y324)
      Y314 = 2.0 * Y424 - SY * X10
      Y413 = 0.5 * (CX * SY + SX * CY + KH2 * Y424)
      Y414 = 0.5 * (SX * SY - KH2 * Y324)
      T111 = 0.5 * (A1*X111 + KH2**2*H*X122)
      T211 = 0.5 * (A1*X211 + KH2**2*H*X222) - H*RH(1)*RH(3)
      T112 = (A1 - KH2*H) * X112 + H*RH(2)
      T212 = (A1 - KH2*H) * X212 + H * (RH(4)-RH(1)*RH(4)-RH(3)*RH(2))
      T122 = 0.5 * (A1*X122 + H*X111)
      T222 = 0.5 * (A1*X222 + H*X211) - H*RH(2)*RH(4)
      B1 = H ** 3 * (BDB + BDB - N)
      T133 = 0.5 * (B1*X133 - KV2**2*H*X144)
      T233 = 0.5 * (B1*X233 - KV2**2*H*X244)
      T134 = (B1 + KV2*H) * X134
      T234 = (B1 + KV2*H) * X234
      T144 = 0.5 * (B1*X144 - H*X133)
      T244 = 0.5 * (B1*X244 - H*X233)
      T313 = C1*Y313 + KH2*KV2*H*Y324
      T413 = C1*Y413 + KH2*KV2*H*Y424 - H*RH(1)*RV(3)
      T314 = C1*Y314 - KH2*H*Y323 + H*RV(2)
      T414 = C1*Y414 - KH2*H*Y423 + H * (RV(4) - RH(1)*RV(4))
      T323 = C1*Y323 - KV2*H*Y314
      T423 = C1*Y423 - KV2*H*Y414 - H*RH(2)*RV(3)
      T324 = C1*Y324 + H*Y313
      T424 = C1*Y424 + H*Y413 - H*RH(2)*RV(4)
      RAY2(1) = RAY2(1) +
     A     T111*RAY(1)**2 + T112*RAY(1)*RAY(2) + T122*RAY(2)**2 +
     B     T133*RAY(3)**2 + T134*RAY(3)*RAY(4) + T144*RAY(4)**2
      RAY2(2) = RAY2(2) +
     A     T211*RAY(1)**2 + T212*RAY(1)*RAY(2) + T222*RAY(2)**2 +
     B     T233*RAY(3)**2 + T234*RAY(3)*RAY(4) + T244*RAY(4)**2
      RAY2(3) = RAY2(3) + (T313*RAY(3) + T314*RAY(4)) * RAY(1) +
     A                    (T323*RAY(3) + T324*RAY(4)) * RAY(2)
      RAY2(4) = RAY2(4) + (T413*RAY(3) + T414*RAY(4)) * RAY(1) +
     A                    (T423*RAY(3) + T424*RAY(4)) * RAY(2)
  200 CALL RSETR (RAY, RAY2)
      RETURN
  300 ALFA = LL * H
      RHO0 = DATA(I+4)
      RHO = RHO0 * P / P0
      THETA1 = ATAN(RAY(2))
      COST1 = COS(THETA1)
      SINT2 = SIN(THETA1+ALFA) - SIN(ALFA) * (RAY(1) + RHO0) / RHO
      IF(ABS(SINT2) .GE. 1.0) GO TO 310
      COST2 = SQRT(1.0 - SINT2 ** 2)
      RAY(1) = (RAY(1) + RHO0) * COS(ALFA) + RHO * (COST2 -
     A     COS(THETA1+ALFA)) - RHO0
      RAY(2) = SINT2 / COST2
      RAY(3) = RAY(3) + RAY(4) * RHO * COST1 * (ALFA + THETA1 -
     A     ASIN(SINT2))
      RAY(4) = RAY(4) * COST1 / COST2
      RETURN
  310 KSTOP = 1
      RETURN
      END
      SUBROUTINE BKOLL(IAP,LFLAG,*,*)
C
C     THIS SUBROUTINE TREATS COLLIMATORS FILLED WITH BALLS
C     ONLY FOR PARENT PARTICLES
C     ONLY CIRCULAR AND ELLIPTICAL CROSS SECTION
C     MULTIPLE SCATTERING MUST BE SWITCHED ON
C     SLIT CARD MUST BE FOLLOWED BY 2 TYPE CODE 1 CARDS:
C     1ST CONTAINS DATA FOR WALL MATERIAL
C     2ND CONTAINS DATA FOR BALL MATERIAL (FILL FACTOR = FIFA)
C     THE 2 TYPE CODE 1 CARDS MUST BE FOLLOWED BY A DRIFT CARD (LENGTH OF ELE)
C     COMPILED BY U. ROHRER (SIN), APRIL 1986
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC3/ NIN, NOUT
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC19/ CONE, ISTOR(100), SLIT1(100), SLIT2(100), NSLIT,
     A                ORIG, ISLT, IFF, IFG, A, B, RECTA
      LOGICAL CONE, ORIG, RECTA
      COMMON /BLOC20/ BALLS, BDIAM, WTHIK
      LOGICAL         BALLS
      COMMON /BLOC44/ LINV, SINV, SINV2, MULTSC
      LOGICAL LINV, SINV, SINV2, MULTSC
C
      LOGICAL         FIRST, STOPED, TRANSR
      DATA            FIRST /.TRUE./
      DATA            FIFA /0.62/
C
C     PERFORM SOME CHECKS
C
      IF (FIRST) THEN
       IF (LINV .OR. RECTA .OR.
     X     IDATA(I+1).NE.1 .OR. IDATA(I+3).NE.3) THEN
        WRITE(NOUT,*) 'Collimator filled with balls only allowed
     X with circular or elliptical cross section.'
        CALL MENU(1)
       ENDIF
C
       IF (.NOT.MULTSC) THEN
        WRITE(NOUT,*) 'Collimator filled with balls only allowed
     X with multiple scattering turned on.'
        CALL MENU(1)
       ENDIF
C
       IF (IDATA(I+5).NE.1 .AND. IDATA(I+5+9).NE.1 .AND.
     X     IDATA(I+5+8).NE.0 .AND. IDATA(I+5+9+8).NE.0) THEN
        WRITE(NOUT,*) 'Slit card must be followed by 2 type code
     X 1 cards, containig information for ball-collimator.'
        CALL MENU(1)
       ENDIF
C
C      DATA ON SECOND TYPE CODE 1 CARD CONTAIN MS-DATA FOR XLD*FIFA LENGTH
C      OF BALL MATERIAL. THIS CARD MUST BE FOLLOWED BY DRIFT.
C
       IF (IDATA(I+5+9+9) .NE. 3) THEN
        WRITE(NOUT,*) '2 Type-code 1 cards must be followed by drift'
        CALL MENU(1)
       ENDIF
C
       IF (LFLAG .NE. 0) THEN
        WRITE(NOUT,*) 'Ball-Collimator only allowed for parents.'
        CALL MENU(1)
       ENDIF
       FIRST = .FALSE.
      ENDIF
C
C     CHECK IF PARTICLE DOES NOT HIT COLLIMATOR
C
      XR = RAY(1)
      YR = RAY(3)
      A  = DATA(I+2)
      B  = DATA(I+4)
      IF ((XR/A)**2 + (YR/B)**2 .LT. 1.0) THEN
       I = I + 23
       NEL = NEL + 3
       RETURN 1
      ENDIF
C
C     CHECK IF PARTICLE HITS WALL OF COLLIMATOR
C
      AW = A + WTHIK
      BW = B + WTHIK
      IF ((XR/AW)**2 + (YR/BW)**2 .LT. 1.0) THEN
       I = I + 5
       NEL = NEL + 1
       NTYPE = 1
       STOPED = .FALSE.
       CALL MULT(0,IAP,STOPED)
       IF (STOPED) RETURN 2
       I = I + 18
       NEL = NEL + 2
       RETURN 1
      ENDIF
      RAD   = BDIAM / 2.
C
C     PARTICLE HITS BALL TRANSITION REGION
C
      IF ((XR/(AW+RAD))**2 + (YR/(BW+RAD))**2 .LT. 1.0) THEN
       TRANSR = .TRUE.
       XR2    = XR**2
       YR2    = YR**2
C
C      USED FORMULA FOR DIST (DISTANCE OF POINT XR,YR FROM ELLIPSE)
C      IS AN APPROXIMATION
C
       IF (AW .NE. BW) THEN
        AW2   = AW**2
        BW2   = BW**2
        FACT  = 1. - AW * BW / SQRT (XR2 * BW2 + YR2 * AW2)
        DIST  = SQRT (XR2 + YR2) * FACT
        IF ( XR.EQ.0. .OR. YR.EQ.0.) THEN
         CONTINUE
        ELSE
         RAT  = ABS (YR / XR)
         ANG  = ATAN ( (AW2 * RAT + BW2 / RAT) / (AW2 - BW2) )
         DIST = DIST * SIN (ANG)
        ENDIF
C
C      CIRCLE
C
       ELSE
        DIST  = SQRT(XR2 + YR2) - AW
       ENDIF
C
       FACT   = SIN(1.5708 * MAX(0.01,MIN(1.,DIST / RAD)))
C
       IF (I + 14 .NE. IPOM) THEN
        IPOM = I + 14
        WM   = DATA(IPOM+1)
        BM   = DATA(IPOM+2)
        DELT = DATA(IPOM+6)
        ENLOS= DATA(IPOM+7)
        IPOS = IPOM + 10
        XLD  = DATA(IPOS)
       ENDIF
       DATA(IPOS)   = XLD   * FACT * FIFA
       DATA(IPOM+1) = WM    * FACT**0.5515
       DATA(IPOM+2) = BM    * FACT**0.0921
       DATA(IPOM+6) = DELT  * FACT
       DATA(IPOM+7) = ENLOS * FACT**1.0764
C
C     OUTSIDE TRANSITION REGION
C
      ELSE
       TRANSR       = .FALSE.
       IPOS         = I + 24
       XLD          = DATA(IPOS)
       DATA(IPOS)   = XLD * FIFA
      ENDIF
C
       I       = I + 14
       NEL     = NEL + 2
       NTYPE   = 1
       STOPED = .FALSE.
       CALL MULT(0,IAP,STOPED)
       DATA(IPOS) = XLD
       IF (TRANSR) THEN
        DATA(IPOM+1) = WM
        DATA(IPOM+2) = BM
        DATA(IPOM+6) = DELT
        DATA(IPOM+7) = ENLOS
       ENDIF
       IF (STOPED) RETURN 2
       I          = I + 9
       NEL        = NEL + 1
       RETURN 1
      END
      LOGICAL FUNCTION BSTOP(LFLAG)
C
      COMMON /BLOC5/ SEC, CAP(3), MPA, THIRD
      LOGICAL         SEC, CAP, MPA, THIRD
      COMMON /BLOC10/ APB(2), LAYL, LAYX, RAB1, RAB2, FACE
      REAL            LAYL, LAYX
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
C
      IF(.NOT. CAP(LFLAG+1)) GO TO 20
      IF(APB(1) .EQ. 0.0) GO TO 10
      IF(ABS(RAY(1)) .GT. APB(1)) GO TO 30
   10 IF(APB(2) .EQ. 0.0) GO TO 20
      IF(ABS(RAY(3)) .GT. APB(2)) GO TO 30
   20 BSTOP = .FALSE.
      RETURN
   30 BSTOP = .TRUE.
      RETURN
      END

      SUBROUTINE CORREL(CHI,X1,X2,NR)
C
      COMMON /hal/ halton, ipn(10) ,iseries(10)
      LOGICAL HALTON
C
      IF (HALTON .AND. NR .GT. 0) THEN
       RND = HALTONS(NR)
      ELSE
       CALL RANDOM(RND)      
      ENDIF
      R=SQRT(-0.5*LOG(MAX(1.E-12,1.-RND)))
      IF (HALTON .AND. NR .GT. 0) THEN
       RND = HALTONS(NR+1)
      ELSE
       CALL RANDOM(RND)      
      ENDIF
      A=RND*6.2831853
      X1=R*COS(A)
      X2=R*SIN(A+CHI)
      RETURN
      END

      SUBROUTINE CORRL2(CHI,XM,X1,X2,NR)
C
      COMMON /hal/ halton, ipn(10) ,iseries(10)
      LOGICAL HALTON
C
      IF (HALTON) THEN
       RND = HALTONS(NR)
      ELSE
       CALL RANDOM(RND)      
      ENDIF
      R=SQRT(MAX(1.E-12,1.-(RND)**(1./XM)))
      IF (HALTON) THEN
       RND = HALTONS(NR+1)
      ELSE
       CALL RANDOM(RND)      
      ENDIF
      A=RND*6.2831853
      X1=R*COS(A)
      X2=R*SIN(A+CHI)
      RETURN
      END

      SUBROUTINE CHKBIN(X1,X2,DX,INTVL)
C
      IF (DX .LT. 0.0) DX = - DX
      IF (X2 .LT. X1) THEN
      SAVE = X1
      X1 = X2
      X2 = SAVE
      END IF
      IF (DX .EQ. 0.0) DX = (X2 - X1) / 100.
      IF (DX .EQ. 0.0) DX = 0.001
      INTVL = AMAX1((X2 - X1) / DX, 1.0) + 0.001
      X2 = X1 + FLOAT(INTVL) * DX
      RETURN
      END
      SUBROUTINE DECAY
C
      COMMON /BLOC4/ RAYMAX(6), PBEAM, P0, NORAYS
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC47/ IRAN
      COMMON /BLOC52/ W, POLX(0:2), POLY(0:2), POLZ(0:2), POLCAL
      LOGICAL POLCAL
C
      BETGAM = P / MASS
      GAMMA = SQRT(1. + BETGAM ** 2)
C
      CALL RANDOM(RND)      
      COST = 2.0 * RND - 1.0
      SINT = SQRT (1.0 - COST ** 2)
      GAMCOS = GAMMA * COST
C
      FPC = GAMCOS + BETGAM * FC
      TANTEC = SINT / FPC
      PC = PSTAR * FPC
C
      FPN = GAMCOS + BETGAM * FN
      TANTEN = SINT / FPN
      PN = PSTAR * FPN
C
      CALL RANDOM(RND)      
      PHI = 6.2831853 * RND
      COSPHI = COS(PHI)
      SINPHI = SIN(PHI)
C
      RAYC(1) = RAY(1)
      RAYC(2) = RAY(2) + ATAN( COSPHI * TANTEC )
      RAYC(3) = RAY(3)
      RAYC(4) = RAY(4) + ATAN( SINPHI * TANTEC )
      RAYC(5) = RAY(5)
      RAYC(6) = (PC - P0) / P0
C
      RAYN(1) = RAY(1)
      RAYN(2) = RAY(2) - ATAN( COSPHI * TANTEN )
      RAYN(3) = RAY(3)
      RAYN(4) = RAY(4) - ATAN( SINPHI * TANTEN )
      RAYN(5) = RAY(5)
      RAYN(6) = (PN - P0) / P0
C
C     COMPUTE POLARIZATION OF MYON AND NUON  (V-A INTERACTION)
C     SEE H.-J. GERBER LHE VILLIGEN, RELATIVISTIC KINEMATICS P.151
C     BETAC AND GAMMAC FOR MYON IN REST FRAME
C     BETA FOR PION IN LAB SYSTEM
C     ETA WIGNER ANGLE
C
      IF (POLCAL) THEN
       GAMMAC = SQRT(1. + (PSTAR / MASSC)**2)
       BETAC  = SQRT(1. - 1. / GAMMAC**2)
       BETA   = SQRT(1. - 1. / GAMMA**2)
       EXPR   = GAMMAC * (BETAC / BETA + COST)
        IF (EXPR .NE. 0.0) THEN
         TANETA = SINT / EXPR
        ELSE
         TANETA = 1.E+10
        ENDIF
       ETA    = ATAN(TANETA)
        IF (TANETA .LT. 0.0) THEN
         SIG = -1.0
        ELSE
         SIG = 1.0
        ENDIF
       SINETA = SIN(ETA)
       POLX(1) = -1. * SINETA * COSPHI
       POLY(1) = -1. * SINETA * SINPHI
       POLZ(1) = -1. * COS(ETA) * SIG
       POLX(2) = -1. * POLX(1)
       POLY(2) = -1. * POLY(1)
       POLZ(2) = -1. * POLZ(1)
      ENDIF
      RETURN
      END
      SUBROUTINE DECAYP
C
      COMMON /BLOC2/  UNIT(12)
      COMMON /BLOC2A/ NAME(12), NOM(12), NOM1(4), DSTOR(20)
      CHARACTER*4     NAME, NOM, NOM1, DSTOR
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC41/ LW, FLUSH, INDIC, NTYPE, LENGTH,
     A                NWORD, NVARY, DATUM(30), VARY(30)
      INTEGER VARY
      LOGICAL FLUSH
      COMMON /BLO41A/ IMAGE(80), LABLE
      CHARACTER       IMAGE*1, LABLE*4
      COMMON /BLOC46/ SM, GAMMA0, BETA0, CHARGE
C
      MASS  = DATUM(2) * UNIT(11)
      SM = MASS
      MASSC = DATUM(3) * UNIT(11)
      MASSN = DATUM(4) * UNIT(11)
      FLD = 0.299 * DATUM(5) / MASS
      ECSTAR = (MASS ** 2 + MASSC ** 2 - MASSN ** 2) / (2.0 * MASS)
      ENSTAR = (MASS ** 2 - MASSC ** 2 + MASSN ** 2) / (2.0 * MASS)
      PSTAR  = SQRT(ECSTAR ** 2 - MASSC ** 2)
      FC = ECSTAR / PSTAR
      FN = ENSTAR / PSTAR
      RETURN
      END
      SUBROUTINE DECAYZ (ZD)
C
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG, FIRST
      COMMON /BLOC47/ IRAN
      REAL LD
      DATA FIRST /.TRUE./
C
      IF (FIRST) THEN
       TAU0 = FLD * MASS / .299
       FIRST = .FALSE.
      ENDIF
      CALL RANDOM(RND)      
      ZD = - TAU0 * LOG(1.-RND)
      RETURN
      END
      SUBROUTINE DEDXD
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC2/  UNIT(12)
      COMMON /BLOC2A/ NAME(12), NOM(12), NOM1(4), DSTOR(20)
      CHARACTER*4     NAME, NOM, NOM1, DSTOR
      COMMON /BLOC3/ NIN, NOUT
      COMMON /BLOC4/ RAYMAX(6), PBEAM, P0, NORAYS
      COMMON /BLOC41/ LW, FLUSH, INDIC, NTYPE, LENGTH,
     A                NWORD, NVARY, DATUM(30), VARY(30)
      INTEGER VARY
      LOGICAL FLUSH
      COMMON /BLO41A/ IMAGE(80), LABLE
      CHARACTER       IMAGE*1, LABLE*4
      COMMON /BLOC46/ SM, GAMMA0, BETA0, CHARGE
      COMMON /BLOC55/ DEDX(3), VEKIN(3,5), VDEDX(3,5)
      LOGICAL DEDX
C
      LOGICAL      CORRCT
      REAL         WORK(30)
      EQUIVALENCE  (WORK, DATUM)
C
C     CHECK INPUT PARAMETERS
C
      DO 10 J = 1, 10
      IF (WORK(J + 1) .LE. 0.0) THEN
       WRITE(NOUT,1000)
 1000  FORMAT(' Type Code 30: All 10 Parameters have to be positive')
       CALL MENU(1)
      ENDIF
   10 CONTINUE
C
      CORRCT = WORK(10) .LE. WORK(8) .AND.
     X          WORK(8)  .LE. WORK(6) .AND.
     X          WORK(6)  .LE. WORK(4) .AND.
     X          WORK(4)  .LT. WORK(2)
      IF (.NOT.CORRCT) THEN
       WRITE(NOUT,1001)
 1001  FORMAT(' Type Code 30: E1 > E2 > E3 > E4 > E5 > 0 is a must')
       CALL MENU(1)
      ENDIF
C
      E0 = WORK(2) * UNIT(11)
      PP = SQRT(E0 * (2. * SM + E0))
      IF (ABS(PP - P0) / P0 .GT. 0.02) THEN
       WRITE(NOUT,1002)
 1002  FORMAT(' Type Code 30: 1st Energy has to correspond to P0')
       CALL MENU(1)
      ENDIF
C
      IF (WORK(12).NE.0.0 .AND. WORK(12).NE.100.0 .AND.
     *                          WORK(12).NE.200.0      ) THEN
       WRITE(NOUT,1003)
 1003  FORMAT(
     *' Type Code 30: 12th entry has to be particle id = 0, 100 or 200')
       CALL MENU(1)
      ENDIF
C
C     PREPARE CHECKED DATA
C
      IDATA(I)   = NTYPE
      DATA(I+1)  = LOG10(E0)
      DATA(I+2)  = 0.
      DATA(I+3)  = LOG10(WORK(4) * UNIT(11))
      DATA(I+4)  = LOG10(WORK(5) / WORK(3))
      DATA(I+5)  = LOG10(WORK(6) * UNIT(11))
      DATA(I+6)  = LOG10(WORK(7) / WORK(3))
      DATA(I+7)  = LOG10(WORK(8) * UNIT(11))
      DATA(I+8)  = LOG10(WORK(9) / WORK(3))
      DATA(I+9)  = LOG10(WORK(10) * UNIT(11))
      DATA(I+10) = LOG10(WORK(11) / WORK(3))
      IDATA(I+11)= (WORK(12) + 0.01) / 100.
      RETURN
C
      ENTRY DEDXD2
C
      LFLAG            = IDATA(I+11)
      DEDX(LFLAG+1)    = .TRUE.
      VEKIN(LFLAG+1,1) = DATA(I+1)
      VEKIN(LFLAG+1,2) = DATA(I+3)
      VEKIN(LFLAG+1,3) = DATA(I+5)
      VEKIN(LFLAG+1,4) = DATA(I+7)
      VEKIN(LFLAG+1,5) = DATA(I+9)
      VDEDX(LFLAG+1,1) = DATA(I+2)
      VDEDX(LFLAG+1,2) = DATA(I+4)
      VDEDX(LFLAG+1,3) = DATA(I+6)
      VDEDX(LFLAG+1,4) = DATA(I+8)
      VDEDX(LFLAG+1,5) = DATA(I+10)
      RETURN
      END
      CHARACTER*1 FUNCTION DIGIT (INT, IR)
C
C     RETURNS ONE DIGIT OF AN INTEGER AS A RIGHT-JUSTIFIED EBCDIC WORD
C
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
C
      IF (INT .GT. 999999) INT = 999999
      MODEL = 10**(6-IR)
      MITE = INT/MODEL
      ITEN = MOD(MITE,10)
      IF (ITEN .GT. 0) GO TO 50
      DIGIT = BLANK
      IF(IR .EQ. 6 .OR. MITE .GE. 10) DIGIT = TABLE(1)
      RETURN
   50 DIGIT = TABLE(ITEN+1)
      RETURN
      END
      FUNCTION DINLAN(XX)
C
C     DINLAN(X) COMPUTES THE VALUE OF THE INVERSE FUNCTION OF THE
C     CONDITIONAL CUMULATIVE DISTRIBUTION FUNCTION OF THE LANDAU
C     DISTRIBUTION AT THE POINT XX.
C     C.KOST'S (TRIUMF) IDEA:
C     IN THIS VERSION THE FIRST CALL FILLS AN ARRAY Y(0:1000) AND
C     SUCCESSIVE CALLS LINEARLY INTERPOLATE THIS ARRAY. THIS MEANS
C     THAT THE TIME PER CALL FOR NCALLS >> 1000 WILL BE SUBSTANTAL-
C     LY REDUCED ( WITH SOME ACCURACY LOSS AS WELL ).
C
      COMMON /BLOC49/ F(40),F0(40),F1(40),F2(40),FM1A(40),BL(260)
      DIMENSION Y(0:1001)
      LOGICAL FIRST
      DATA FIRST /.TRUE./
C
C     FIRST TIME INITIALIZATION
C
      IF (FIRST) THEN
       DO 20 I=0,1000
        X=FLOAT(I)/1000.
        Z=3.1415926535898*X
        COF=2.*COS(Z)
        C1=0.
        C0=BL(1)
        DO 10 K = 2,260
         C2=C1
         C1=C0
         C0=BL(K)+COF*C1-C2
   10   CONTINUE
        Y(I)=-3.5+89.46782*X+C0*SIN(Z)
   20  CONTINUE
       Y(1001)=Y(1000)
       FIRST=.FALSE.
      ENDIF
C
C     FAST ENTRY AFTER INITIAL CALL
C
      X=XX*1000.
      I=INT(X)
      X=X-FLOAT(I)
      DINLAN=Y(I)+X*(Y(I+1)-Y(I))
      RETURN
      END
      SUBROUTINE EFIELD
C
C     COMPILED BY U. ROHRER (SIN), JULY 1986
C     DO A SINGLE STEP OF 4TH ORDER RUNGE-KUTTA INTEGRATION
C     FORCE IS GIVEN BY A E-FIELD IN X-DIRECTION AND B-FIELD IN Y-DIRECTION
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC3/  NIN, NOUT
      COMMON /BLOC4/  RAYMAX(6), PBEAM, P0, NORAYS
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC46/ SM, GAMMA0, BETA0, CHARGE
C
      XL      = DATA(I+1)
      IF (XL .EQ. 0.0) RETURN
      BETGAM = P / SM
      GAMMA   = SQRT (1.  + BETGAM**2)
      BETA    = BETGAM   / GAMMA
      RHOE    = DATA(I+2) * GAMMA * BETA**2
      RHOB    = DATA(I+3) * P
      H       = XL / BETA
      X       = RAY(1)
      VX      = RAY(2)    * BETA
      FX1     = BETA**2   * (1. / RHOE + 1. / RHOB)
C
C     FIND NEXT 27. CARD (ONLY 1 INTERVENING CARD IS ALLOWED)
C
      IF (IDATA(I+4) .EQ. 27) THEN
       RHOE   = DATA(I+6) * GAMMA * BETA**2
       RHOB   = DATA(I+7) * P
       FX2    = BETA**2   * (1. / RHOE + 1. / RHOB)
      ELSE
       NTYPE  = IDATA(I+4)
       J      = I + 4 + NU(NTYPE)
       NTYPE  = IDATA(J)
       IF (NTYPE .EQ. 27) THEN
        RHOE  = DATA(J+2) * GAMMA * BETA**2
        RHOB  = DATA(J+3) * P
        FX2   = BETA**2   * (1. / RHOE + 1. / RHOB)
       ELSE
        WRITE(NOUT,*)
     1  'Type-code 27: not more than 1 intervening card allowed.'
        WRITE(NOUT,*)
     1  'or Type-code 27: last card with zero length missing.'
        CALL MENU(1)
       ENDIF
      ENDIF
C
C     DO 4TH ORDER RUNGE-KUTTA INTEGRATION IN X-X' PHASE SPACE
C
      AKX1    = H  * VX
      AKVX1   = H  * FX1
      AKX2    = H  * (VX + .5 * AKVX1)
      AKVX2   = H  * (FX1 + FX2) / 2.
      AKX3    = H  * (VX + .5 * AKVX2)
      AKVX3   = H  * (FX1 + FX2) / 2.
      AKX4    = H  * (VX + AKVX3)
      AKVX4   = H  * FX2
      X       = X  + (AKX1  + 2. * AKX2  + 2. * AKX3  + AKX4 ) / 6.
      VX      = VX + (AKVX1 + 2. * AKVX2 + 2. * AKVX3 + AKVX4) / 6.
      RAY(1)  = X
      RAY(2)  = VX / BETA
C
C     DRIFT IN Y-Y' PHASE SPACE
C
      RAY(3)  = RAY(3) + XL * RAY(4)
C
      RETURN
      END
      SUBROUTINE EHIST(LOST)
C
C     HISTOGRAM ENTRY ROUTINE
C
      COMMON /BLOC6/ NHISTS, NHIST, LIMNO
      COMMON /BLOC7/ MTYPE(100), NENTRY(100), NCOOR(100), INTVLS(100),
     A                BEGIN(100), END(100), STEP(100), ZHIST(100)
      COMMON /BLOC7A/ LTAG(100)
      CHARACTER*4     LTAG
      COMMON /BLOC8/ MTABLE(50000)
      REAL           MTABLE
      COMMON /BLOC12/ VALUE(100), XMOM(100), XMOM2(100), NFLAG(100),
     A                SET(100), KFLAG(100), IFLAG(3,0:9), ZFLAG(9),
     A                WZ(100), UFLAG(100), INVFL, ZC
      LOGICAL SET, IFLAG, UFLAG, INVFL
      LOGICAL SCALX, LFLAG, LOST
C
      SCALX = .FALSE.
      DO 400 NH = 1, NHISTS
      NFL = NFLAG(NH)
      KFL = KFLAG(NH) + 1
      LFLAG = IFLAG(KFL,NFL)
      INVFL = UFLAG(NH)
      NAVEL = MTYPE(NH)
      GO TO (100,200,300), NAVEL
C
C     ONE DIMENSIONAL HISTOGRAM
C
  100 IF(NFL.GT.0 .AND. .NOT.LFLAG .AND. LOST .AND. INVFL) GO TO 110
      IF((NFL.GT.0 .AND. .NOT.LFLAG) .OR. INVFL) GO TO 400
  110 IF(.NOT. SET(NH)) GO TO 400
      VAL = VALUE(NH)
      M = NENTRY(NH)
      N = INTVLS(NH)
      XBEG = BEGIN(NH)
      XEND = END(NH)
      WEI = WZ(NH)
      DX = STEP(NH)
      CALL HISTO(VAL,MTABLE(M),N,XBEG,XEND,DX,WEI)
      IF( VAL.LT.XBEG .OR. VAL.GE.XEND ) GO TO 400
      XMOM(NH) = XMOM(NH) + WEI * VAL
      XMOM2(NH) = XMOM2(NH) + WEI * VAL ** 2
      GO TO 400
C
C     X COORDINATE OF TWO DIMENSIONAL HISTOGRAM
C
  200 SCALX = .FALSE.
      IF(NFL.GT.0 .AND. .NOT.LFLAG .AND. LOST .AND. INVFL) GO TO 210
      IF((NFL.GT.0 .AND. .NOT.LFLAG) .OR. INVFL) GO TO 400
  210 IF(.NOT. SET(NH)) GO TO 400
      SCALX = .TRUE.
      A = VALUE(NH)
      NA = INTVLS(NH)
      AMIN = BEGIN(NH)
      AMAX = END(NH)
      DA = STEP(NH)
      GO TO 400
C
C     Y COORDINATE OF TWO DIMENSIONAL HISTOGRAM
C
  300 IF(NFL.GT.0 .AND. .NOT.LFLAG .AND. LOST .AND. INVFL) GO TO 310
      IF((NFL.GT.0 .AND. .NOT.LFLAG) .OR. INVFL) GO TO 400
  310 IF(.NOT. (SET(NH) .AND. SCALX)) GO TO 400
      D = VALUE(NH)
      M = NENTRY(NH)
      ND = INTVLS(NH)
      DMIN = BEGIN(NH)
      DMAX = END(NH)
      WEI = WZ(NH)
      DD = STEP(NH)
      CALL ENTMAT(A,D,MTABLE(M),AMIN,AMAX,NA,DA,DMIN,DMAX,ND,DD,WEI)
  400 CONTINUE
      RETURN
      END
      SUBROUTINE ELLIPS(IPLOT,AMIN,NA,DA,DMIN,ND,DD)
C
C     PRINT ELLIPSIS PARAMETERS
C
      COMMON /BLOC3/ NIN, NOUT
      REAL IPLOT(1)
      REAL*8 SUM, SUMX, SUMXX, SUMY, SUMYY, SUMXY
      REAL*8 XM, YM, XXM, YYM, XYM
C
      MTT=(NA+1)*(ND+1)+5
      I=IPLOT(MTT)-IPLOT(MTT-1)-IPLOT(MTT-2)-IPLOT(MTT-3)-IPLOT(MTT-4)
      IF(I.LT.3) RETURN
      SUM=0.0
      SUMX=0.0
      SUMXX=0.0
      SUMY=0.0
      SUMYY=0.0
      SUMXY=0.0
      DO 5 J=1,ND
      DO 5 I=1,NA
      K=(J-1)*(NA+1)+I
      X=AMIN+(FLOAT(I-1)+0.5)*DA
      Y=DMIN+(FLOAT(J-1)+0.5)*DD
      Z=IPLOT(K)
      SUM=SUM+DBLE(Z)
      SUMX=SUMX+DBLE(X*Z)
      SUMXX=SUMXX+DBLE(X*X*Z)
      SUMY=SUMY+DBLE(Y*Z)
      SUMYY=SUMYY+DBLE(Y*Y*Z)
      SUMXY=SUMXY+DBLE(X*Y*Z)
    5 CONTINUE
      IF (SUM .LE. 0.0) RETURN
      XM=SUMX/SUM
      YM=SUMY/SUM
      XXM=SUMXX/SUM
      YYM=SUMYY/SUM
      XYM=SUMXY/SUM
      IF (XXM-XM*XM .LE. 0.0) RETURN
      IF (YYM-YM*YM .LE. 0.0) RETURN
      XXM=DSQRT(XXM-XM*XM)
      YYM=DSQRT(YYM-YM*YM)
      XYM=XYM-XM*YM
      R12=XYM/(XXM*YYM)
      IF(R12.GT.1.0) R12=1.0
      IF(R12.LT.-1.0) R12=-1.0
      EPS=XXM*YYM*SQRT(1.-R12**2)
      WRITE(NOUT,1000) XM, XXM, YM, YYM, R12, EPS
 1000 FORMAT(/25X,' **** Ellipse parameters ****'/,
     X/15X,' horizontal :  center =',F8.3,3X,'RMS half width = ',G10.3
     X/15X,' vertical   :  center =',F8.3,3X,'RMS half width = ',G10.3
     X/15X,' correlation:  sinchi =',F8.3,3X,'RMS area / pi  = ',G10.3
     X)
      RETURN
      END
      SUBROUTINE EMIT(IER)
C
      COMMON /BLOC2/  UNIT(12)
      COMMON /BLOC2A/ NAME(12), NOM(12), NOM1(4), DSTOR(20)
      CHARACTER*4     NAME, NOM, NOM1, DSTOR
      COMMON /BLOC4/ RAYMAX(6), PBEAM, P0, NORAYS
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC45/ CHIX, SNCHIX, CSCHX2, CHIY, SNCHIY,
     A                CSCHY2, GAUSS, VOL4
      LOGICAL GAUSS, VOL4
      COMMON /BLOC47/ IRAN
      COMMON /BLOC51/ IOCASE(5), IOUNIT(5), IONUM, UNIT1
      INTEGER UNIT1
      COMMON /BLOC52/ W, POLX(0:2), POLY(0:2), POLZ(0:2), POLCAL
      LOGICAL POLCAL
      COMMON /BLOC54/ BINOM, XM, YM, ZM, XNORM, YNORM, ZNORM
      LOGICAL BINOM
      COMMON /hal/ halton, ipn(10) ,iseries(10)
      LOGICAL HALTON
C
      DATA SUMW /.0/
C
      POLX(0) = 0.
      POLY(0) = 0.
      POLZ(0) = 0.
C
      IF(RAYMAX(1).LT.0.0) GO TO 30
      IF(BINOM) GO TO 100
      IF(.NOT.GAUSS .OR. VOL4) GO TO 10
C
C     GAUSSIAN DISTRIBUTION
C
      CALL CORREL(CHIX,X1,X2,1)
      RAY(1)=RAYMAX(1)*X1
      RAY(2)=RAYMAX(2)*X2
      CALL CORREL(CHIY,X1,X2,3)
      RAY(3)=RAYMAX(3)*X1
      RAY(4)=RAYMAX(4)*X2
      CALL CORREL(0.0,X1,X2,5)
      RAY(5)=RAYMAX(5)*X1
      RAY(6)=RAYMAX(6)*X2
      GO TO 25
C
C     HOMOGENEOUS DISTRIBUTION IN (X,X') AND (Y,Y')
C     OR 4VOL DISTRIBUTION (HOMOGENEOUS IN X,X',Y AND Y')
C
   10 CONTINUE
      IF (HALTON) THEN
       RND = HALTONS(1)
      ELSE
       CALL RANDOM(RND)      
      ENDIF
      X1=2.0*RND-1.0
      IF (HALTON) THEN
       RND = HALTONS(2)
      ELSE
       CALL RANDOM(RND)      
      ENDIF
      X2=2.0*RND-1.0
      IF (HALTON) THEN
       RND = HALTONS(3)
      ELSE
       CALL RANDOM(RND)      
      ENDIF
      X3=2.0*RND-1.0
      IF (HALTON) THEN
       RND = HALTONS(4)
      ELSE
       CALL RANDOM(RND)      
      ENDIF
      X4=2.0*RND-1.0

      IF (VOL4) THEN
       CHECK
     1 = (X1**2 + X2**2 - 2 * X1 * X2 * SNCHIX) / CSCHX2
     2 + (X3**2 + X4**2 - 2 * X3 * X4 * SNCHIY) / CSCHY2
       IF (CHECK.GT.1.0) GO TO 10
       FACT=1.2247449
      ELSE
       RN1 = X1**2 + X3**2
       RN2 = X2**2 + X4**2
       IF (RN1.GT.1.0 .OR. RN2.GT.1.0) GO TO 10
       FACT=1.0
      ENDIF
      RAY(1)=RAYMAX(1)*X1*FACT
      RAY(2)=RAYMAX(2)*X2*FACT
      RAY(3)=RAYMAX(3)*X3*FACT
      RAY(4)=RAYMAX(4)*X4*FACT
      IF (HALTON) THEN
       RND = HALTONS(5)
      ELSE
       CALL RANDOM(RND)      
      ENDIF
      RAY(5)=RAYMAX(5)*(2.0*RND-1.0)
      IF (HALTON) THEN
       RND = HALTONS(6)
      ELSE
       CALL RANDOM(RND)      
      ENDIF
      RAY(6)=RAYMAX(6)*(2.0*RND-1.0)
   25 P = PBEAM * (1.0 + RAY(6))
      W=1.0
      RETURN
C
C     GET BEAM DATA FROM DISK_FILE
C
   30 CONTINUE
      READ(UNIT1,1111,END=50)
     X RAY(1), RAY(2), RAY(3), RAY(4), P, W, POLZ(0)
 1111 FORMAT(7F12.5)
      SUMW=SUMW+W
      RAY(1)=RAY(1)*UNIT(1)
      RAY(2)=RAY(2)*UNIT(2)
      RAY(3)=RAY(3)*UNIT(3)
      RAY(4)=RAY(4)*UNIT(4)
      P=P*UNIT(11)
      RAY(5)=0.
      RAY(6)=P/PBEAM-1.
      RETURN
   50 IER=1
      NORAYS=SUMW
      RETURN
C
C     BINOMIAL DISTRIBUTION
C     SEE W. JOHO, SIN-REPORT TM-11-14 (1980) P. 25
C
  100 CALL CORRL2(CHIX,XM,X1,X2,1)
      RAY(1)=RAYMAX(1)*X1*XNORM
      RAY(2)=RAYMAX(2)*X2*XNORM
      CALL CORRL2(CHIY,YM,X1,X2,3)
      RAY(3)=RAYMAX(3)*X1*YNORM
      RAY(4)=RAYMAX(4)*X2*YNORM
      CALL CORRL2(0.0,ZM,X1,X2,5)
      RAY(5)=RAYMAX(5)*X1*ZNORM
      RAY(6)=RAYMAX(6)*X2*ZNORM
      GO TO 25
      END
      SUBROUTINE ENTMAT(A,D,MATRIX,AMIN,AMAX,NA,DA,DMIN,DMAX,ND,DD,W)
C
C     ENTMAT ENTERS POINT (A,D) INTO TWO DIMENSIONAL HISTOGRAM MATRIX
C
      REAL MATRIX(2000)
C
      NAA = NA + 1
      NTT = NAA*(ND + 1)
      MTT = NTT + 5
C
C     OVERFLOW OF X COORDINATE
C
      IF (A - AMIN) 5, 10, 10
    5 NRET = 1
      GO TO 35
   10 IF (A - AMAX) 20, 20, 15
   15 NRET = 2
      GO TO 35
C
C     OVERFLOW OF Y COORDINATE
C
   20 IF (D - DMIN) 25, 30, 30
   25 NRET = 3
      GO TO 35
   30 IF (D - DMAX) 40, 40, 32
   32 NRET = 4
C
   35 NOV = NTT + NRET
   36 MATRIX(NOV) = MATRIX(NOV) + W
      MATRIX(MTT) = MATRIX(MTT) + W
      RETURN
C
C     ENTRY INTO HISTOGRAM
C
 40   CONTINUE
      IA = (A - AMIN)/DA + 1.0
      ID = (D - DMIN)/DD + 1.0
      MM = (ID - 1) * NAA + IA
      NAT = ID*NAA
      NDT = ND*NAA + IA
 60   MATRIX(MM) = MATRIX(MM) + W
      MATRIX(NTT) = MATRIX(NTT) + W
      MATRIX(NAT) = MATRIX(NAT) + W
      MATRIX(NDT) = MATRIX(NDT) + W
      MATRIX(MTT) = MATRIX(MTT) + W
C
 200  RETURN
      END
      SUBROUTINE FILEIO
      COMMON /BLOC2/  UNIT(12)
      COMMON /BLOC2A/ NAME(12), NOM(12), NOM1(4), DSTOR(20)
      CHARACTER*4     NAME, NOM, NOM1, DSTOR
      COMMON /BLOC4/ RAYMAX(6),PBEAM,P0,NORAYS
      COMMON /BLOC6/ NHISTS,NHIST,LIMNO
      COMMON /BLOC7/ MTYPE(100), NENTRY(100), NCOOR(100), INTVLS(100),
     A                BEGIN(100), END(100), STEP(100), ZHIST(100)
      COMMON /BLOC7A/ LTAG(100)
      CHARACTER*4     LTAG
      COMMON /BLOC8/ MTABLE(50000)
      REAL           MTABLE
      COMMON /BLOC12/ VALUE(100), XMOM(100), XMOM2(100), NFLAG(100),
     A                SET(100), KFLAG(100), IFLAG(3,0:9), ZFLAG(9),
     A                WZ(100), UFLAG(100), INVFL, ZC
      LOGICAL SET, IFLAG, UFLAG, INVFL
      COMMON /BLOC16/ ISTOP(3,9998)
      REAL ISTOP
      COMMON /BLO16A/ KPART(3)
      CHARACTER*4     KPART
      COMMON /BLOC18/ LOSS, NBLK(20), KFLG(20),
     A                XSTRT(20), XEND(20), LTHX(20), XBIN(20), NUNX(20),
     A                YSTRT(20), YEND(20), LTHY(20), YBIN(20), NUNY(20)
      COMMON /BLOC51/ IOCASE(5), IOUNIT(5), IONUM, UNIT1
      INTEGER UNIT1
      REAL IV(50000),X(100),X2(100),KSTOP(3,9998)
C
      REAL KKSTOP(3600)
      EQUIVALENCE(KSTOP,KKSTOP)
      CHARACTER*4 XLAB(100)
      REAL ZPOS(100)
C
      CHARACTER*10 FILNAM
      DATA FILNAM  /'FOR000.DAT'/
C
C     IOCASE=-1  SKIP SUBROUTINE
C     IOCASE=0  BEGIN WITH STORING
C     IOCASE=1  DO NOT INFLUENCE CURRENT TURTLE OUTPUT
C     IOCASE=2  TURTLE OUTPUT CONTAINS SUMS OF RAYS
C
      DO 900 L = 1, IONUM
C
      IF (IOCASE(L) .EQ. -1) GO TO 900
C
C     READ IN STORING FILE
C
      IF (IOCASE(L) .GE. 0) THEN
       CALL UNIFIL(FILNAM,IOUNIT(L))
       OPEN(UNIT=IOUNIT(L),FILE=FILNAM,STATUS='OLD',ERR=6)
       IF (IOCASE(L) .EQ. 0) GO TO 5
       READ(IOUNIT(L),1235,ERR=7)  IDUM1,IDUM2,IDUM3,NOR
       READ(IOUNIT(L),1236,ERR=7)  (IV(I),I=1,LIMNO)
       READ(IOUNIT(L),1237,ERR=7)  (X(J),J=1,NHISTS)
       READ(IOUNIT(L),1237,ERR=7)  (X2(K),K=1,NHISTS)
       READ(IOUNIT(L),1236,ERR=7)  (ZPOS(K),K=1,NHISTS)
       READ(IOUNIT(L),1248,ERR=7)  (XLAB(K),K=1,NHISTS)
       READ(IOUNIT(L),1236,ERR=7) ((KSTOP(K,J),K=1,3),J=1,9998)
       REWIND(UNIT=IOUNIT(L))
       GO TO 2
      ENDIF
C
C     INITIALIZE DATA FILE
C
    6 OPEN(UNIT=IOUNIT(L),FILE=FILNAM,STATUS='NEW',ERR=7)
      GO TO 5
    7 OPEN(UNIT=IOUNIT(L),FILE=FILNAM,STATUS='UNKNOWN')
      REWIND(UNIT=IOUNIT(L))
    5 DO 1 I=1,LIMNO
    1 IV(I)=0.0
      DO 3 I=1,NHISTS
      X(I)=0.
    3 X2(I)=0.
      NOR=0
      DO 4 K=1,3
      DO 4 J=1,9998
    4 KSTOP(K,J)=0.0
C
C     HISTOGRAMM HANDLING
C
    2 CONTINUE
      DO 500 K=1,NHISTS
      M=NENTRY(K)
      N=INTVLS(K)
      X0=BEGIN(K)
      DX=STEP(K)
      NAVEL=MTYPE(K)
      GO TO (100,200,300,500),NAVEL
C
C     1 DIM HISTOGRAMMS
C
  100 MM=M+N+2
      DO 101 I=M,MM
  101 IV(I)=IV(I)+MTABLE(I)
      X(K)=XMOM(K)+X(K)
      X2(K)=XMOM2(K)+X2(K)
      GO TO 500
C
C     2 DIM HISTOGRAMM
C
  200 NA=N
      GO TO 500
  300 MM=M+(N+1)*(NA+1)+4
      DO 301 I=M,MM
  301 IV(I)=IV(I)+MTABLE(I)
  500 CONTINUE
C
C     HISTOGRAMS OF PARTICLES LOST
C
      IF(LOSS.EQ.0) GO TO 760
      DO 750 K=1,LOSS
      M=NBLK(K)
      N=LTHX(K)
      ND=LTHY(K)
      NUND=NUNY(K)
      IF(NUND.NE.0) GO TO 720
C
C     Z DISTRIBUTION
C
      MM=M+N+2
      DO 710 I=M,MM
  710 IV(I)=IV(I)+MTABLE(I)
      GO TO 750
C
C     Z VERSUS ANOTHER COORDINATE
C
  720 MM=M+(ND+1)*(N+1)+4
      DO 730 I=M,MM
  730 IV(I)=IV(I)+MTABLE(I)
  750 CONTINUE
  760 CONTINUE
C
C     LOSS TABLE
C
      NOR=NOR+NORAYS
      DO 400 K=1,3
      DO 400 J=1,9998
  400 KSTOP(K,J)=KSTOP(K,J)+ISTOP(K,J)
C
C     WRITE UPDATED DATA ON STORING FILE
C
      WRITE(IOUNIT(L),1235)  NHISTS,LIMNO,LOSS,NOR
      WRITE(IOUNIT(L),1236)  (IV(I),I=1,LIMNO)
      WRITE(IOUNIT(L),1237)  (X(J),J=1,NHISTS)
      WRITE(IOUNIT(L),1237)  (X2(K),K=1,NHISTS)
      WRITE(IOUNIT(L),1236)  (ZHIST(K)/UNIT(8),K=1,NHISTS)
      DO 401 K=1,NHISTS
       XLAB(K) = LTAG(K)
       IF (LTAG(K) .EQ. '    ') XLAB(K) = '$$$$'
 401  CONTINUE
      WRITE(IOUNIT(L),1248)  (XLAB(K),K=1,NHISTS)
      WRITE(IOUNIT(L),1236) ((KSTOP(K,J),K=1,3),J=1,9998)
C
 1235 FORMAT(4I10)
 1236 FORMAT(10F13.3)
 1237 FORMAT(10E13.5)
 1248 FORMAT(10(1X,A4))
C
C     REST OF FILE FOR GRAPHIC OUTPUT OF HISTOGRAMMS
C
      WRITE(IOUNIT(L),1238) UNIT,NAME,NOM,NOM1
 1238 FORMAT(12E13.5,/12(A4,1X),/,12(A4,1X),/,12(A4,1X))
      WRITE(IOUNIT(L),1239) (MTYPE(I),NENTRY(I),NCOOR(I),INTVLS(I),
     X BEGIN(I),END(I),STEP(I),ZHIST(I),I=1,NHISTS)
 1239 FORMAT(I2,I6,2I4,4E13.5)
      WRITE(IOUNIT(L),1234) (NBLK(I),KFLG(I),XSTRT(I),XEND(I),LTHX(I),
     X XBIN(I),NUNX(I),YSTRT(I),YEND(I),LTHY(I),YBIN(I),NUNY(I),
     X I=1,LOSS)
 1234 FORMAT(I6,I2,2E13.5,I4,E13.5,I3,2E13.5,I4,E13.5,I3)
      CLOSE(UNIT=IOUNIT(L))
C
  900 CONTINUE
C
C     INFLUENCE CURRENT TURTLE OUTPUT
C
      DO 600 L = 1, IONUM
      IF (IOCASE(L) .EQ. 2) THEN
       DO 501 I = 1, LIMNO
  501  MTABLE(I) = IV(I)
       DO 502 I = 1, NHISTS
       XMOM(I)  = X(I)
  502  XMOM2(I) = X2(I)
       NORAYS   = NOR
       DO 503 K = 1, 3
       DO 503 J = 1, 9998
  503  ISTOP(K,J) = KSTOP(K,J)
       RETURN
      ENDIF
  600 CONTINUE
      RETURN
  777 WRITE(*,*) 'ERROR'
      RETURN
      END
      SUBROUTINE FOCBND(TANB,SECB,RAB,H,ES,E)
C
C     COMPUTES THE THIRD ORDER MATRIX-ELEMENTS OF A BEND FRINGE FIELD
C     IN RADIAL DIRECTION. N = 0
C     COMPILED BY U. ROHRER (SIN), JULY 1986
C     SEE NUC. INST. AND METH. 77 (1970) P.283-292
C
      REAL E(13)
C
      TANB2 = TANB  * TANB
      TANB3 = TANB2 * TANB
      TANB4 = TANB3 * TANB
      SECB2 = SECB  * SECB
      SECB3 = SECB2 * SECB
      H2    = H     * H
      H3    = H2    * H
      AUX1  = TANB  * SECB3 * RAB / 2.
      AUX2  = TANB  * SECB3 * RAB * RAB * SECB / 2.
C
      E(1)  = - ES * AUX1 * H
      E(2)  = - TANB3 * H
      E(3)  = 3. * ES * AUX1 * H
      E(4)  = TANB * (1. + 2. * TANB2) * H
      E(5)  = TANB * SECB2 * H
      E(6)  = AUX2 * H
      E(7)  = 3. * ES * AUX1 * H
      E(8)  = 0.5 * TANB * (3. + 2. * TANB2) * H
      E(9)  = -3. * AUX2 * H
      E(10) = -6. * ES * AUX1 * H
      E(11) = .5 * TANB * (1. - 2. * TANB2) * H
      E(12) = -3. * ES * AUX1 * H
      E(13) = -2. * TANB * SECB2 * H
C
C     EXTRA TERMS FOR ENTRANCE FRINGE FIELD
C
      IF (ES .EQ. 1.) THEN
      AUX3  = (1. + 6. * TANB2) * RAB * SECB3 / 2.
      E(3)  = E(3)  - .5 * TANB2 * (1. + 2. * TANB2) * H2
      E(6)  = E(6)  + .5 * TANB3 * H3
      E(7)  = E(7)  +1.5 * TANB2 * H2
      E(9)  = E(9)  + .5 * TANB3 * H3 + AUX3 * H2
      E(10) = E(10) + 2. * TANB4 * H2
      E(12) = E(12) + 3. * TANB2 * SECB2 * H2
C
C     EXTRA TERMS FOR EXIT FRINGE FIELD
C
      ELSE
      E(1)  = E(1)  - .5  * TANB4 * H2
      E(3)  = E(3)  + .5  * TANB2 * (2. + TANB2) * H2
      E(6)  = E(6)  + .5  * TANB3 * SECB2 * H3 - 2. * TANB * AUX1 * H2
      E(7)  = E(7)  + 1.5 * TANB2 * SECB2 * H2
      E(9)  = E(9)  + 1.5 * TANB3 * SECB2 * H3
      E(10) = E(10) -       TANB2 * (2. + TANB2) * H2
      E(12) = E(12) + 1.5 * TANB2 * SECB2 * H2
      ENDIF
      RETURN
      END
      SUBROUTINE FOCSG (K2, L, K, KL, R)
C
      REAL K2, L, K, KL, R(4)
      K = SQRT(ABS(K2))
      KL = K * L
      IF(K2) 20, 10, 10
   10 R(1) = COS(KL)
      R(3) = - K * SIN(KL)
      R(4) = R(1)
      IF(ABS(KL) .LT. 0.01) GO TO 30
      R(2) = - R(3) / K2
      RETURN
   20 EXPKL = EXP(KL)
      EXIKL = 1.0 / EXPKL
      R(1) = 0.5 * (EXPKL + EXIKL)
      R(3) = 0.5 * (EXPKL - EXIKL) * K
      R(4) = R(1)
      IF(ABS(KL) .LT. 0.01) GO TO 30
      R(2) = - R(3) / K2
      RETURN
   30 R(2) = L * (1.0 - K2 * L ** 2 / 6.0)
      RETURN
      END

      SUBROUTINE FOCSG3(KH2,L,RH,RV,XMAT,YMAT)
C
C     COMPUTING 3RD ORDER MATRIX ELEMENTS FOR QUAD FIELD
C     SEE D.L. SMITH IN NUCL. INST. AND METH. 79 (1970) P.144-164
C     COMPILED BY U. ROHRER (SIN), JULY 1986
C
      REAL RH(4), RV(4), KQ2
      REAL KH2, K, KL, L, K2, K3, KI, M1, M2, M3, M4
      REAL KLS1, KLC1, KLSH1, KLCH1
      REAL ELEMH(20), ELEMV(20), XMAT(20), YMAT(20)
      LOGICAL SMITH
C
      EQUIVALENCE (U1111, ELEMH( 1))  ,(U1112, ELEMH( 2))
      EQUIVALENCE (U1122, ELEMH( 3))  ,(U1133, ELEMH( 4))
      EQUIVALENCE (U1134, ELEMH( 5))  ,(U1144, ELEMH( 6))
      EQUIVALENCE (U1222, ELEMH( 7))  ,(U1233, ELEMH( 8))
      EQUIVALENCE (U1234, ELEMH( 9))  ,(U1244, ELEMH(10))
C
      EQUIVALENCE (U2111, ELEMH(11))  ,(U2112, ELEMH(12))
      EQUIVALENCE (U2122, ELEMH(13))  ,(U2133, ELEMH(14))
      EQUIVALENCE (U2134, ELEMH(15))  ,(U2144, ELEMH(16))
      EQUIVALENCE (U2222, ELEMH(17))  ,(U2233, ELEMH(18))
      EQUIVALENCE (U2234, ELEMH(19))  ,(U2244, ELEMH(20))
C
      EQUIVALENCE (U3333, ELEMV( 1))  ,(U3334, ELEMV( 2))
      EQUIVALENCE (U3344, ELEMV( 3))  ,(U3113, ELEMV( 4))
      EQUIVALENCE (U3123, ELEMV( 5))  ,(U3223, ELEMV( 6))
      EQUIVALENCE (U3444, ELEMV( 7))  ,(U3114, ELEMV( 8))
      EQUIVALENCE (U3124, ELEMV( 9))  ,(U3224, ELEMV(10))
C
      EQUIVALENCE (U4333, ELEMV(11))  ,(U4334, ELEMV(12))
      EQUIVALENCE (U4344, ELEMV(13))  ,(U4113, ELEMV(14))
      EQUIVALENCE (U4123, ELEMV(15))  ,(U4223, ELEMV(16))
      EQUIVALENCE (U4444, ELEMV(17))  ,(U4114, ELEMV(18))
      EQUIVALENCE (U4124, ELEMV(19))  ,(U4224, ELEMV(20))
C
      SMITH = .FALSE.
      IF (SMITH) THEN
C
C     COMPUTE SOME FACTORS
C
      K2    = ABS  (KH2)
      K     = SQRT (K2)
      K3    = K * K2
      KI    = 1. / K
      KL    = K * L
      S1    = SIN  (KL)
      S2    = SIN  (2. * KL)
      S3    = SIN  (3. * KL)
      C1    = COS  (KL)
      C2    = COS  (2. * KL)
      C3    = COS  (3. * KL)
      SH1   = SINH (KL)
      SH2   = SINH (2. * KL)
      SH3   = SINH (3. * KL)
      CH1   = COSH (KL)
      CH2   = COSH (2. * KL)
      CH3   = COSH (3. * KL)
      KLS1  = KL  * S1
      KLC1  = KL  * C1
      S1SH2 = S1  * SH2
      S1CH2 = S1  * CH2
      C1SH2 = C1  * SH2
      C1CH2 = C1  * CH2
      KLSH1 = KL  * SH1
      KLCH1 = KL  * CH1
      SH1S2 = SH1 * S2
      SH1C2 = SH1 * C2
      CH1S2 = CH1 * S2
      CH1C2 = CH1 * C2
      M1    = 3. / 64.
      M2    = 1. / 64.
      M3    = 1. / 32.
      M4    = 1. / 16.
C
C     FOCUSING PLANE
C
      U1111 = M1 * K2 * (C1 - C3 - 4. * KLS1)
      U1112 = M2 * K * (15. * S1 - 9. * S3 + 12. * KLC1)
      U1122 = M2 * (9. * C3 - 9. * C1 - 28. * KLS1)
      U1133 = M3 * K2 * (C1CH2 - 3. * S1SH2 - C1 + 4. * KLS1)
      U1134 = M4 * K * (C1SH2 - 3. * S1CH2 + S1)
      U1144 = M3 * (C1CH2 - 3. * S1SH2 - C1 - 12. * KLS1)
      U1222 = M2 * KI * (3. * S3 - 37. * S1 + 28. * KLC1)
      U1233 = M3 * K * (S1CH2 + 3. * C1SH2 - 3. * S1 - 4. * KLC1)
      U1234 = M4 * (3. * C1CH2 + S1SH2 - 3. * C1)
      U1244 = M3 * KI * (3. * C1SH2 + S1CH2 - 19. * S1 + 12. * KLC1)
C
      U2111 = M1 * K3 * (3. * S3 - 5. * S1 - 4. * KLC1)
      U2112 = M2 * K2 * (27. * C1 - 27. * C3 - 12. * KLS1)
      U2122 = M2 * K * (-27. * S3 - 19. * S1 - 28. * KLC1)
      U2133 = M3 * K3 * (5. * S1 - 7. * S1CH2 - C1SH2 + 4. * KLC1)
      U2134 = M4 * K2 * (C1 - C1CH2 - 7. * S1SH2)
      U2144 = M3 * K * (-7. * S1CH2 - C1SH2 - 11. * S1 - 12. * KLC1)
      U2222 = M2 * (9. * C3 - 9. * C1 - 28. * KLS1)
      U2233 = M3 * K2 * (7. * C1CH2 - 7. * C1 - S1SH2 + 4. * KLS1)
      U2234 = M4 * K * (7. * C1SH2 - S1CH2 + 3. * S1)
      U2244 = M3 * (7. * C1CH2 - 7. * C1 - S1SH2 - 12. * KLS1)
C
C     DEFUCUSING PLANE
C
      U3333 = M1 * K2 * (-CH1 + CH3 - 4. * KLSH1)
      U3334 = M2 * K * (-15. * SH1 + 9. * SH3 - 12. * KLCH1)
      U3344 = M2 * ( 9. * CH3 - 9. * CH1 + 28. * KLSH1)
      U3113 = M3 * K2 * (-CH1C2 - 3. * SH1S2 + CH1 + 4. * KLSH1)
      U3123 = M4 * K * (-CH1S2 + 3. * SH1C2 - SH1)
      U3223 = M3 * (CH1C2 + 3. * SH1S2 - CH1 + 12. * KLSH1)
      U3444 = M2 * KI * ( 3. * SH3 - 37. * SH1 + 28. * KLCH1)
      U3114 = M3 * K * (-SH1C2 -3. * CH1S2 + 3. * SH1 + 4. * KLCH1)
      U3124 = M4 * ( 3. * CH1C2 - SH1S2 - 3. * CH1)
      U3224 = M3 * KI * (3. * CH1S2 + SH1C2 - 19. * SH1 + 12. * KLCH1)
C
      U4333 = M1 * K3 * (3. * SH3 - 5. * SH1 - 4. * KLCH1)
      U4334 = M2 * K2 * (-27. * CH1 + 27. * CH3 - 12. * KLSH1)
      U4344 = M2 * K * (27. * SH3 + 19. * SH1 + 28. * KLCH1)
      U4113 = M3 * K3 * (5. * SH1 - 7. * SH1C2 - CH1S2 + 4. * KLCH1)
      U4123 = M4 * K2 * (-CH1 + CH1C2 - 7. * SH1S2)
      U4223 = M3 * K * (7. * SH1C2 + CH1S2 + 11. * SH1 + 12. * KLCH1)
      U4444 = M2 * (9. * CH3 - 9. * CH1 + 28. * KLSH1)
      U4114 = M3 * K2 * (-7. * CH1C2 + 7. * CH1 - SH1S2 + 4. * KLSH1)
      U4124 = M4 * K * (-7. * CH1S2 + SH1C2 - 3. * SH1)
      U4224 = M3 * (7. * CH1C2 - 7. * CH1 + SH1S2 + 12. * KLSH1)
C
      IF (KH2 .GT. 0.0) THEN
       DO 100 J = 1, 20
        XMAT(J) = ELEMH(J)
        YMAT(J) = ELEMV(J)
  100  CONTINUE
      ELSE
       DO 200 J = 1, 20
        YMAT(J) = ELEMH(J)
        XMAT(J) = ELEMV(J)
  200  CONTINUE
      ENDIF
C
      ELSE
C
C     COMPUTE SOME FACTORS FOR HORIZONTAL PLANE
C
      KQ2 = KH2
      CS = RH(1)
      SK = -RH(3)
      SOK = RH(2)
      CSO = RV(1)
      SKO = -RV(3)
      SOKO = RV(2)
C
C     MATRIX ELEMENTS FOR HORIZONTAL PLANE
C     TRANSPORT NOTATION:
C     U1111=U(1,1)  U1112=U(1,2)  U1122=U(1,3)  U1222=U(1,4)
C     U1133=U(1,8)  U1233=U(1,9)  U1134=U(1,14) U1234=U(1,15)
C     U1144=U(1,17) U1244=U(1,18)
C
      U1111 = KQ2**2*(13.*CS*SOK**2 - 9.*L*SOK)/48.
      U1112 = KQ2*(- 22.*SOK + 26.*KQ2*SOK**3 + 6.*L*CS)/32.
      U1122 = - KQ2*(13.*CS*SOK**2 + 3.*L*SOK)/16.
      U1222 = (- 9.*SOK - 13.*KQ2*SOK**3 + 9.*L*CS)/48.
      U1133 = KQ2**2*(- 3.*CS*SOKO**2 + 2.*L*SOK
     1 - 3.*SOK*SOKO*CSO)/16.
      U1134 = 3.*KQ2*(- CS*CSO*SOKO + SOK - KQ2*SOK*SOKO**2)/
     1 8.
      U1144 = - KQ2*(3.*CS*SOKO**2 + 2.*L*SOK
     1 + 3.*SOK*CSO*SOKO)/16.
      U1233 = KQ2*(3.*CS*CSO*SOKO - 2.*L*CS - 3.*SOK*CSO**2
     1 - 6.*SOK)/16.
      U1234 = 3.*KQ2*(CS*SOKO**2 - SOK*CSO*SOKO)/8.
      U1244 = (3.*CS*CSO*SOKO + 2.*L*CS - 3.*SOK*CSO**2
     1 - 2.*SOK)/16.
C
      U2111 = - KQ2**2*(7.*SOK + 15.*KQ2*SOK**3
     1 + 9.*L*CS)/48.
      U2112 = 3.*KQ2**2*(5.*CS*SOK**2 - L*SOK)/16.
      U2122 = KQ2*(- 26.*SOK + 30.*KQ2*SOK**3
     1 - 6.*L*CS)/32.
      U2222 = - KQ2*(5.*CS*SOK**2 + 3.*L*SOK)/16.
      U2133 = KQ2**2*(2.*L*CS - 9.*CS*CSO*SOKO - 9.*SOK
     1 - 11.*KQ2*SOK*SOKO**2)/16.
      U2134 = KQ2**2*(- 9.*CS*SOKO**2 - 11.*SOK*SOKO*CSO)/8.
      U2144 = - KQ2*(2.*L*CS + 9.*CS*CSO*SOKO
     1 + 11.*KQ2*SOK*SOKO**2 + 5.*SOK)/16.
      U2233 = KQ2**2*(11.*CS*SOKO**2 + 2.*L*SOK
     1 - 9.*SOK*CSO*SOKO)/16.
      U2234 = KQ2*(11.*CS*CSO*SOKO - 3.*SOK
     1 - 9.*KQ2*SOK*SOKO**2)/8.
      U2244 = KQ2*(11.*CS*SOKO**2 - 2.*L*SOK
     1 - 9.*SOK*CSO*SOKO)/16.
C
C     COMPUTE SOME FACTORS FOR VERTICAL PLANE 
C
      KQ2 = -KH2
      CS = RV(1)
      SK = -RV(3)
      SOK = RV(2)
      CSO = RH(1)
      SKO = -RH(3)
      SOKO = RH(2)
C
C     MATRIX ELEMENTS FOR VERTICAL PLANE
C     TRANSPORT NOTATION:
C     U3113=U(3,5)  U3123=U(3,6)  U3223=U(3,7)
C     U3333=U(3,10) U3114=U(3,11) U3124=U(3,12) U3224=U(3,13)
C     U3334=U(3,16) U3344=U(3,19) U3444=U(3,20)
C
      U3333 = KQ2**2*(13.*CS*SOK**2 - 9.*L*SOK)/48.
      U3334 = KQ2*(- 22.*SOK + 26.*KQ2*SOK**3 + 6.*L*CS)/32.
      U3344 = - KQ2*(13.*CS*SOK**2 + 3.*L*SOK)/16.
      U3444 = (- 9.*SOK - 13.*KQ2*SOK**3 + 9.*L*CS)/48.
      U3113 = KQ2**2*(- 3.*CS*SOKO**2 + 2.*L*SOK
     1 - 3.*SOK*SOKO*CSO)/16.
      U3123 = 3.*KQ2*(- CS*CSO*SOKO + SOK - KQ2*SOK*SOKO**2)/
     1 8.
      U3223 = - KQ2*(3.*CS*SOKO**2 + 2.*L*SOK
     1 + 3.*SOK*CSO*SOKO)/16.
      U3114 = KQ2*(3.*CS*CSO*SOKO - 2.*L*CS - 3.*SOK*CSO**2
     1 - 6.*SOK)/16.
      U3124 = 3.*KQ2*(CS*SOKO**2 - SOK*CSO*SOKO)/8.
      U3224 = (3.*CS*CSO*SOKO + 2.*L*CS - 3.*SOK*CSO**2
     1 - 2.*SOK)/16.
C
      U4333 = - KQ2**2*(7.*SOK + 15.*KQ2*SOK**3
     1 + 9.*L*CS)/48.
      U4334 = 3.*KQ2**2*(5.*CS*SOK**2 - L*SOK)/16.
      U4344 = KQ2*(- 26.*SOK + 30.*KQ2*SOK**3
     1 - 6.*L*CS)/32.
      U4444 = - KQ2*(5.*CS*SOK**2 + 3.*L*SOK)/16.
      U4113 = KQ2**2*(2.*L*CS - 9.*CS*CSO*SOKO - 9.*SOK
     1 - 11.*KQ2*SOK*SOKO**2)/16.
      U4123 = KQ2**2*(- 9.*CS*SOKO**2 - 11.*SOK*SOKO*CSO)/8.
      U4223 = - KQ2*(2.*L*CS + 9.*CS*CSO*SOKO
     1 + 11.*KQ2*SOK*SOKO**2 + 5.*SOK)/16.
      U4114 = KQ2**2*(11.*CS*SOKO**2 + 2.*L*SOK
     1 - 9.*SOK*CSO*SOKO)/16.
      U4124 = KQ2*(11.*CS*CSO*SOKO - 3.*SOK
     1 - 9.*KQ2*SOK*SOKO**2)/8.
      U4224 = KQ2*(11.*CS*SOKO**2 - 2.*L*SOK
     1 - 9.*SOK*CSO*SOKO)/16.
c
      DO 300 J = 1, 20
       XMAT(J) = ELEMH(J)
       YMAT(J) = ELEMV(J)
  300 CONTINUE
C
      ENDIF
C
      RETURN
      END

      SUBROUTINE FOCSG3E(KH2,L,BETA0,XMAT,YMAT)
C
C     COMPUTING 3RD ORDER MATRIX ELEMENTS FOR QUAD FIELD
C     SEE D.L. SMITH IN NUCL. INST. AND METH. 79 (1970) P.144-164
C     COMPILED BY U. ROHRER (PSI), MARCH 2001
C
      REAL KH2, K, KL, L, K2, K3, KI, M1, M2, M3, M4
      REAL KLS1, KLC1, KLSH1, KLCH1
      REAL ELEMH(20), ELEMV(20), XMAT(20), YMAT(20)
C
      EQUIVALENCE (U1111, ELEMH( 1))  ,(U1112, ELEMH( 2))
      EQUIVALENCE (U1122, ELEMH( 3))  ,(U1133, ELEMH( 4))
      EQUIVALENCE (U1134, ELEMH( 5))  ,(U1144, ELEMH( 6))
      EQUIVALENCE (U1222, ELEMH( 7))  ,(U1233, ELEMH( 8))
      EQUIVALENCE (U1234, ELEMH( 9))  ,(U1244, ELEMH(10))
C
      EQUIVALENCE (U2111, ELEMH(11))  ,(U2112, ELEMH(12))
      EQUIVALENCE (U2122, ELEMH(13))  ,(U2133, ELEMH(14))
      EQUIVALENCE (U2134, ELEMH(15))  ,(U2144, ELEMH(16))
      EQUIVALENCE (U2222, ELEMH(17))  ,(U2233, ELEMH(18))
      EQUIVALENCE (U2234, ELEMH(19))  ,(U2244, ELEMH(20))
C
      EQUIVALENCE (U3333, ELEMV( 1))  ,(U3334, ELEMV( 2))
      EQUIVALENCE (U3344, ELEMV( 3))  ,(U3113, ELEMV( 4))
      EQUIVALENCE (U3123, ELEMV( 5))  ,(U3223, ELEMV( 6))
      EQUIVALENCE (U3444, ELEMV( 7))  ,(U3114, ELEMV( 8))
      EQUIVALENCE (U3124, ELEMV( 9))  ,(U3224, ELEMV(10))
C
      EQUIVALENCE (U4333, ELEMV(11))  ,(U4334, ELEMV(12))
      EQUIVALENCE (U4344, ELEMV(13))  ,(U4113, ELEMV(14))
      EQUIVALENCE (U4123, ELEMV(15))  ,(U4223, ELEMV(16))
      EQUIVALENCE (U4444, ELEMV(17))  ,(U4114, ELEMV(18))
      EQUIVALENCE (U4124, ELEMV(19))  ,(U4224, ELEMV(20))
C
C     COMPUTE SOME FACTORS
C
      K2    = ABS  (KH2)
      K     = SQRT (K2)
      K3    = K * K2
      KI    = 1. / K
      KL    = K * L
      S1    = SIN  (KL)
      S2    = SIN  (2. * KL)
      S3    = SIN  (3. * KL)
      C1    = COS  (KL)
      C2    = COS  (2. * KL)
      C3    = COS  (3. * KL)
      SH1   = SINH (KL)
      SH2   = SINH (2. * KL)
      SH3   = SINH (3. * KL)
      CH1   = COSH (KL)
      CH2   = COSH (2. * KL)
      CH3   = COSH (3. * KL)
      KLS1  = KL  * S1
      KLC1  = KL  * C1
      S1SH2 = S1  * SH2
      S1CH2 = S1  * CH2
      C1SH2 = C1  * SH2
      C1CH2 = C1  * CH2
      KLSH1 = KL  * SH1
      KLCH1 = KL  * CH1
      SH1S2 = SH1 * S2
      SH1C2 = SH1 * C2
      CH1S2 = CH1 * S2
      CH1C2 = CH1 * C2
      M1    = 3. / 64.
      M2    = 1. / 64.
      M3    = 1. / 32.
      M4    = 1. / 16.
      B2    = BETA0 * BETA0
C
C     FOCUSING PLANE
C
      U1111 = M2 * K2 * B2 * (C1 - C3 - 4. * KLS1)
      U1112 = M2 * K * B2 * (5. * S1 - 3. * S3 + 4. * KLC1)
      U1122 = -0.5 * KLS1 + M1 * B2 * (C3 - C1 + 4. * KLS1)
      U1133 = M3 * K2 * B2 * (C1 - C1CH2 - S1SH2 + 4. * KLS1)
      U1134 = M4 * K * B2 * (3. * S1 - C1SH2 - S1CH2)
      U1144 = -0.5 * KLS1 + M3 * B2 * (C1 - C1CH2 - S1SH2 + 4. * KLS1)
      U1222 = 0.5 * KI * (KLC1 - S1) 
     x        + M2 * KI * B2 * (S3 + 9. * S1 - 12. * KLC1)
      U1233 = M3 * K * B2 * (-S1CH2 + C1SH2 + 3. * S1 - 4. * KLC1)
      U1234 = M4 * B2 * (C1CH2 - S1SH2 - C1)
      U1244 = 0.5 * KI * (KLC1 - S1) 
     X        + M3 * KI * B2 * (C1SH2 - S1CH2 + 3. * S1 - 4. * KLC1)
C
      U2111 = M2 * K3 * B2 * (3. * S3 - 5. * S1 - 4. * KLC1)
      U2112 = M2 * K2 * B2 * (9. * C1 - 9. * C3 - 4. * KLS1)
      U2122 = -0.5 * K * (S1 + KLC1) 
     X        + M1 * K * B2 * (-3. * S3 + 5. * S1 + 4. * KLC1)
      U2133 = M3 * K3 * B2 * (3. * S1 - S1CH2 - 3. * C1SH2 + 4. * KLC1)
      U2134 = M4 * K2 * B2 * (3. * C1 - 3. * C1CH2 - S1SH2)
      U2144 = -0.5 * K * (S1 + KLC1) 
     X        + M3 * K * B2 * (3. * S1 - S1CH2 - 3. * C1SH2 + 4. * KLC1)
      U2222 = -0.5 * KLS1 + M1 * B2 * (C3 - C1 + 4. * KLS1)
      U2233 = M3 * B2 * (C1CH2 - C1 - 3. * S1SH2 + 4. * KLS1)
      U2234 = M4 * K * B2 * (C1SH2 - 3. * S1CH2 + S1)
      U2244 = -0.5 * KLS1
     X        + M3 * B2 * (C1CH2 - C1 - 3. * S1SH2 + 4. * KLS1)
C
C     DEFUCUSING PLANE
C
      U3333 = M2 * K2 * B2 * (-CH1 + CH3 - 4. * KLSH1)
      U3334 = M2 * K * B2 * (-5. * SH1 + 3. * SH3 - 4. * KLCH1)
      U3344 = 0.5 * KLSH1 + M1 * B2 * ( CH3 - CH1 - 4. * KLSH1)
      U3113 = M3 * K2 * B2 * (CH1C2 - SH1S2 - CH1 + 4. * KLSH1)
      U3123 = M4 * K * B2 * (CH1S2 + SH1C2 - 3. * SH1)
      U3223 = 0.5 * KLSH1 + M3 * B2 * (-CH1C2 + SH1S2 + CH1 - 4. *KLSH1)
      U3444 = 0.5 * KI * (KLCH1 - SH1)
     X      + M2 * KI * B2 * ( SH3 + 9. * SH1 -12. * KLCH1)
      U3114 = M3 * K * B2 * (SH1C2 - CH1S2 - 3. * SH1 + 4. * KLCH1)
      U3124 = M4 * B2 * (CH1C2 + SH1S2 - CH1)
      U3224 = 0.5 * KI * (KLCH1 - SH1)
     X      + M3 * KI * B2 * (CH1S2 - SH1C2 + 3. * SH1 - 4. * KLCH1)
C
      U4333 = M2 * K3 * B2 * (3. * SH3 - 5. * SH1 - 4. * KLCH1)
      U4334 = M2 * K2 * B2 * (-9. * CH1 + 9. * CH3 - 4. * KLSH1)
      U4344 = 0.5 * K * (SH1 + KLCH1)
     X      + M1 * K * B2 * (3. * SH3 - 5. * SH1 - 4. * KLCH1)
      U4113 = M3 * K3 * B2 * (3. * SH1 - SH1C2 - 3. * CH1S2 + 4. *KLCH1)
      U4123 = M4 * K2 * B2 * (-3. * CH1 + 3. * CH1C2 - SH1S2)
      U4223 = 0.5 * K * (SH1 + KLCH1)
     X      + M3 * K * B2 * (SH1C2 + 3. * CH1S2 -3. * SH1 - 4. * KLCH1)
      U4444 = 0.5 * KLSH1 + M1 * B2 * (CH3 - CH1 - 4. * KLSH1)
      U4114 = M3 * K2 * B2 * (-CH1C2 + CH1 - 3. * SH1S2 + 4. * KLSH1)
      U4124 = M4 * K * B2 * (-CH1S2 + 3. * SH1C2 - SH1)
      U4224 = 0.5 * KLSH1
     X      + M3 * B2 * (CH1C2 - CH1 + 3. * SH1S2 - 4. * KLSH1)
C
      IF (KH2 .GT. 0.0) THEN
       DO 100 J = 1, 20
        XMAT(J) = ELEMH(J)
        YMAT(J) = ELEMV(J)
  100  CONTINUE
      ELSE
       DO 200 J = 1, 20
        YMAT(J) = ELEMH(J)
        XMAT(J) = ELEMV(J)
  200  CONTINUE
      ENDIF
      RETURN
      END

      SUBROUTINE HEDING
C
C     HEDING PRINTS OUT HEADING FOR RUN
C
      COMMON /BLOC2/  UNIT(12)
      COMMON /BLOC2A/ NAME(12), NOM(12), NOM1(4), DSTOR(20)
      CHARACTER*4     NAME, NOM, NOM1, DSTOR
      COMMON /BLOC3/ NIN, NOUT
      COMMON /BLOC4/ RAYMAX(6), PBEAM, P0, NORAYS
      COMMON /BLOC6/ NHISTS, NHIST, LIMNO
      COMMON /BLOC7/ MTYPE(100), NENTRY(100), NCOOR(100), INTVLS(100),
     A                BEGIN(100), END(100), STEP(100), ZHIST(100)
      COMMON /BLOC7A/ LTAG(100)
      CHARACTER*4     LTAG
      COMMON /BLOC12/ VALUE(100), XMOM(100), XMOM2(100), NFLAG(100),
     A                SET(100), KFLAG(100), IFLAG(3,0:9), ZFLAG(9),
     A                WZ(100), UFLAG(100), INVFL, ZC
      LOGICAL SET, IFLAG, UFLAG, INVFL
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC16/ ISTOP(3,9998)
      REAL ISTOP
      COMMON /BLO16A/ KPART(3)
      CHARACTER*4     KPART
      COMMON /BLOC18/ LOSS, NBLK(20), KFLG(20),
     A                XSTRT(20), XEND(20), LTHX(20), XBIN(20), NUNX(20),
     A                YSTRT(20), YEND(20), LTHY(20), YBIN(20), NUNY(20)
      COMMON /BLOC41/ LW, FLUSH, INDIC, NTYPE, LENGTH,
     A                NWORD, NVARY, DATUM(30), VARY(30)
      INTEGER VARY
      LOGICAL FLUSH
      COMMON /BLO41A/ IMAGE(80), LABLE
      CHARACTER       IMAGE*1, LABLE*4
C
      WRITE (NOUT,9007) NORAYS
 9007 FORMAT(/,'1The following requested histograms refer to ',
     A I8,' rays passing through the above beam line:')
      WRITE (NOUT,9008)
 9008 FORMAT(1X,94('*'))
      WRITE (NOUT, 9006) IMAGE
 9006 FORMAT(/' ****   ',80A1,'   ****')
      KH = 0
      DO 400 K = 1, NHISTS
      NAVEL = MTYPE(K)
      GO TO (100,200,300), NAVEL
C
C     ONE DIMENSIONAL HISTOGRAM
C
  100 KH = KH + 1
      N = NCOOR(K)
      Z = ZHIST(K)/UNIT(8)
      KFL = KFLAG(K) + 1
      NFL = NFLAG(K)
      IF(UFLAG(K)) NFL = - NFL
      WRITE (NOUT, 9400) KH, LTAG(K)
 9400 FORMAT(/' Histogram No',I3,20X,A4)
      CALL HISCAP (1, N, KFL, Z, NFL)
      GO TO 400
C
C     X COORDINATE FOR TWO DIMENSIONAL HISTOGRAM
C
  200 NA = NCOOR(K)
      ZA = ZHIST(K)/UNIT(8)
      KFLA = KFLAG(K) + 1
      NFLA = NFLAG(K)
      IF(UFLAG(K)) NFLA = - NFLA
      GO TO 400
C
C     Y COORDINATE FOR TWO DIMENSIONAL HISTOGRAM
C
  300 KH = KH + 1
      ND = NCOOR(K)
      ZD = ZHIST(K) /UNIT(8)
      KFLD = KFLAG(K) + 1
      NFLD = NFLAG(K)
      IF(UFLAG(K)) NFLD = - NFLD
      WRITE (NOUT, 9400) KH, LTAG(K)
      CALL HISCAP (2, NA, KFLA, ZA, NFLA)
      CALL HISCAP (3, ND, KFLD, ZD, NFLD)
  400 CONTINUE
C
C     HISTOGRAMS OF PARTICLES STOPPED
C
      IF(LOSS .EQ. 0) GO TO 710
      DO 700 K = 1, LOSS
      KH = KH + 1
      KFL = KFLG(K) + 1
      WRITE (NOUT, 9500) KH, KPART(KFL)
 9500 FORMAT(/' Histogram No',I3,' of ',A4,' lost')
      N = NUNX(K)
      NA = NUNY(K)
      IF(NA .NE. 0) GO TO 600
      CALL HISCAP (4, N, 0, 0.0, 0)
      GO TO 700
  600 CALL HISCAP (5, N, 0, 0.0, 0)
      CALL HISCAP (6, NA, 0, 0.0, 0)
  700 CONTINUE
  710 IF(.NOT. DKFLAG .OR. ZMAX .EQ. 0.0) RETURN
      ZMAXX = ZMAX / UNIT(8)
      FAC = 1.0 / (1.0 - EXP(-ZMAX / (FLD*PBEAM)))
      WRITE (NOUT, 9700) ZMAXX, NAME(8), FAC
 9700 FORMAT(/,84('*')/' * all parent particles are forced to decay',
     A       ' within ',F10.3,1X,A4,' from the target. *'/
     B       ' * The number of decays will be enhanced by a factor of ',
     C       F8.3,' (average value)    *'/1X,84('*'))
      RETURN
      END
      SUBROUTINE HISCAP (IOPT, NUN, KFL, ZH, NFL)
C
C     PRINT HISTOGRAM CAPTIONS
C
      COMMON /BLOC2/  UNIT(12)
      COMMON /BLOC2A/ NAME(12), NOM(12), NOM1(4), DSTOR(20)
      CHARACTER*4     NAME, NOM, NOM1, DSTOR
      COMMON /BLOC3/ NIN, NOUT
      COMMON /BLOC12/ VALUE(100), XMOM(100), XMOM2(100), NFLAG(100),
     A                SET(100), KFLAG(100), IFLAG(3,0:9), ZFLAG(9),
     A                WZ(100), UFLAG(100), INVFL, ZC
      LOGICAL SET, IFLAG, UFLAG, INVFL
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC16/ ISTOP(3,9998)
      REAL ISTOP
      COMMON /BLO16A/ KPART(3)
      CHARACTER*4     KPART
C
      CHARACTER*4 LABEL(4,3), FOR, PART(2), BLANK, N1, N2, IN
      DATA LABEL
     A     / 'dist','ribu','tion',' of ',
     B       'hori','zont','al a','xis ',
     C       'vert','ical',' axi','s   '/
      DATA FOR, BLANK / 'for ','    '/
C
      IF (NUN .LE. 12) THEN
       N1 = NOM(NUN)
       IN = ' in '
       N2 = NAME(NUN)
      ELSE IF (NUN .EQ. 13) THEN
       N1 = '    '
       IN = 'beta'
       N2 = '    '
      ELSE IF (NUN .EQ. 14) THEN
       N1 = '    '
       IN = 'gamm'
       N2 = 'a   '
      ELSE IF (NUN .EQ. 15) THEN
       N1 = ' lon'
       IN = 'gt. '
       N2 = 'pol.'
      ELSE
       J = NUN - 20
       N1 = NOM1(J)
       IN = ' in '
       N2 = NAME(J)
        IF (J .GT. 2) N2 = NAME(7)
      ENDIF
      IF (.NOT. DKFLAG) THEN
       PART(1) = BLANK
       PART(2) = BLANK
      ELSE
       PART(1) = FOR
       PART(2) = KPART(KFL)
      ENDIF
       IF (IOPT .GT. 3) GO TO 50
      J = IOPT
       IF (NFL .GT. 0) GO TO 40
       IF (NFL .LT. 0) GO TO 45
      WRITE (NOUT,110) (LABEL(I,J), I=1,4), N1, IN, N2, PART, ZH,
     A                  NAME(8)
      RETURN
   40 ZFL = ZFLAG(NFL) / UNIT(8)
      WRITE (NOUT,120) (LABEL(I,J), I=1,4), N1, IN, N2, PART, ZH,
     A                  NAME(8), ZFL, NAME(8)
      RETURN
   45 ZFL = ZFLAG(ABS(NFL)) / UNIT(8)
      WRITE (NOUT,130) (LABEL(I,J), I=1,4), N1, IN, N2, PART, ZH,
     A                  NAME(8), ZFL, NAME(8)
      RETURN
   50 J = IOPT - 3
      WRITE (NOUT,110) (LABEL(I,J), I=1,4), N1, IN, N2
      RETURN
C
  110 FORMAT(1X,7A4,5X,2A4,5X,F12.3,1X,A4,' from the target')
  120 FORMAT(1X,7A4,5X,2A4,5X,F12.3,1X,A4,' from the target',
     A', flag at ',F12.3,1X,A4)
  130 FORMAT(1X,7A4,5X,2A4,5X,F12.3,1X,A4,' from the target',
     A', antiflag at ',F12.3,1X,A4)
      END
      SUBROUTINE HISTLO(LFLAG,WABS)
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC8/  MTABLE(50000)
      REAL            MTABLE
      COMMON /BLOC18/ LOSS, NBLK(20), KFLG(20),
     A                XSTRT(20), XEND(20), LTHX(20), XBIN(20), NUNX(20),
     A                YSTRT(20), YEND(20), LTHY(20), YBIN(20), NUNY(20)
      COMMON /BLOC50/ NOSUP
      COMMON /BLO50A/ LABSUP(20)
      CHARACTER*4     LABSUP
C
      DO 5 J=1, NOSUP
      IF(LABSUP(J) .EQ. LABEL(NEL)) GO TO 20
    5 CONTINUE
      DO 10 K = 1, LOSS
      IF(LFLAG .NE. KFLG(K)) GO TO 10
      M = NBLK(K)
      XMIN = XSTRT(K)
      XMAX = XEND(K)
      XSTP = XBIN(K)
      NX = LTHX(K)
      NUX = NUNX(K)
      X = HSTVAL(NUX,LFLAG)
      NUY = NUNY(K)
      IF(NUY .NE. 0) GO TO 6
      CALL HISTO (X, MTABLE(M), NX, XMIN, XMAX, XSTP, WABS)
      GO TO 10
    6 YMIN = YSTRT(K)
      YMAX = YEND(K)
      YSTP = YBIN(K)
      NY = LTHY(K)
      Y = HSTVAL(NUY,LFLAG)
      CALL ENTMAT (X,Y,MTABLE(M),XMIN,XMAX,NX,XSTP,YMIN,YMAX,NY,YSTP
     A,WABS)
   10 CONTINUE
   20 RETURN
      END
      SUBROUTINE HISTO (X,NHST,M,A,B,DX,W)
C
C     SUBROUTINE FOR ENTERING X INTO HISTOGRAM ARRAY NHST
C
      REAL NHST(2000)
C
      NHST(M+3) = NHST(M+3) + W
C
C     OVERFLOW OF HISTOGRAM
C
      IF (X - B) 104, 102, 102
  102 NHST(M+1) = NHST(M+1) + W
      RETURN
  104 IF (X - A) 106, 108, 108
  106 NHST(M+2) = NHST(M+2) + W
      RETURN
C
C     FILL IN HISTOGRAM
C
  108 L = (X - A)/DX + 1.00001
      NHST(L) = NHST(L) + W
      RETURN
      END
      SUBROUTINE HSTUN (NCO, FACT, LEGAL)
C     FIND CONVERSION UNIT FOR VAUE TO BE HISTOGRAMMED
      COMMON /BLOC2/  UNIT(12)
      COMMON /BLOC2A/ NAME(12), NOM(12), NOM1(4), DSTOR(20)
      CHARACTER*4     NAME, NOM, NOM1, DSTOR
      COMMON /BLOC3/ NIN, NOUT
      LOGICAL LEGAL
C
      LEGAL = .TRUE.
      IF(NCO .GT. 0 .AND. NCO .LE. 6) GO TO 20
      IF(NCO .EQ. 8) GO TO 30
      IF(NCO .EQ. 11) GO TO 30
      IF(NCO .EQ. 12) GO TO 30
      IF(NCO .EQ. 13 .OR. NCO .EQ. 14 .OR. NCO .EQ. 15) GO TO 35
      IF(NCO .GT. 20 .AND. NCO .LE. 24) GO TO 40
C
   10 LEGAL = .FALSE.
      WRITE (NOUT, 100)
      RETURN
C
   20 IF(NCO .EQ. 5) GO TO 10
   30 FACT = UNIT(NCO)
      RETURN
C
   35 FACT = 1.
      RETURN
C
   40 J = NCO - 20
      IF(J .GT. 2) GO TO 50
      FACT = UNIT(J)
      RETURN
C
   50 FACT = UNIT(7)
      RETURN
C
  100 FORMAT(' The coordinate specification on the histogram card '
     A      ,'above has no meaning to Turtle. Histogram ignored.')
      END
      REAL FUNCTION HSTVAL (NCO,LFLAG)
C     FIND VALUE TO BE HISTOGRAMMED
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC46/ SM, GAMMA0, BETA0, CHARGE
      COMMON /BLOC52/ W, POLX(0:2), POLY(0:2), POLZ(0:2), POLCAL
      LOGICAL POLCAL
C
      IF(NCO .LE. 6) GO TO 10
      IF(NCO .EQ. 8) GO TO 20
      IF(NCO .EQ. 11) GO TO 30
      IF(NCO .EQ. 12) GO TO 35
      IF(NCO .EQ. 13) GO TO 36
      IF(NCO .EQ. 14) GO TO 37
      IF(NCO .EQ. 15) GO TO 38
      IF(NCO .GT. 20) GO TO 40
      RETURN
C
   10 HSTVAL = RAY(NCO)
      RETURN
C
   20 HSTVAL = Z
      RETURN
C
   30 HSTVAL = P
      RETURN
C
C     KINETIC ENERGY
C
   35 GAMMA = SQRT(1. + (P / SM) **2)
      HSTVAL = P**2 / ((1. + GAMMA) * SM)
      RETURN
C
C     BETA
C
   36 BGSQ = ( P / SM ) ** 2
      HSTVAL = SQRT( BGSQ / ( 1. + BGSQ ) )
      RETURN
C
C     GAMMA
C
   37 HSTVAL = SQRT(1. + (P / SM) **2)
      RETURN
C
C     LONGITUDINAL POLARISATION
C
   38 HSTVAL = POLZ(LFLAG)
      RETURN
C
   40 IF(NCO .GT. 22) GO TO 50
      J = NCO - 20
      HSTVAL = SQRT (RAY(J)**2 + RAY(J+2)**2)
      RETURN
C
   50 J = NCO - 22
      VALUE = 0.0
      IF(RAY(J+2) .NE. 0.0 .OR. RAY(J) .NE. 0.0)
     A     HSTVAL = ATAN2 (RAY(J+2), RAY(J))
      RETURN
      END
      SUBROUTINE INITZR
C
      COMMON /BLOC5/ SEC, CAP(3), MPA, THIRD
      LOGICAL         SEC, CAP, MPA, THIRD
      COMMON /BLOC9/ L, H, N, BDB
      REAL            L, N
      COMMON /BLOC10/ APB(2), LAYL, LAYX, RAB1, RAB2, FACE
      REAL            LAYL, LAYX
      COMMON /BLOC12/ VALUE(100), XMOM(100), XMOM2(100), NFLAG(100),
     A                SET(100), KFLAG(100), IFLAG(3,0:9), ZFLAG(9),
     A                WZ(100), UFLAG(100), INVFL, ZC
      LOGICAL SET, IFLAG, UFLAG, INVFL
C
      DO 10 J = 1, 9
   10 ZFLAG(J) = - 1.0
      SEC = .FALSE.
      THIRD = .FALSE.
      CAP(1) = .FALSE.
      CAP(2) = .FALSE.
      CAP(3) = .FALSE.
      MPA = .FALSE.
      BDB = 0.0
      APB(1) = 0.0
      APB(2) = 0.0
      LAYL = 0.5
      LAYX = 0.0
      RAB1 = 0.0
      RAB2 = 0.0
      RETURN
      END
      SUBROUTINE JUMP(IAP)
C
C     TYPE CODE 29, INCLUDED BY U. ROHRER (SIN) APRIL 1986
C     CONDITIONAL JUMP OVER CARDS (TO SPEED UP COLLIMATOR COMPUTATIONS).
C     CODE EXPANDED TO TARGETS BY U. ROHRER (PSI) MAY 2004 
C
C     DATA(I+1)  DISTANCE BETWEEN 2 SLITS. MUST BE LENGTH OF COLLIMATOR
C     DATA(I+2)  X-DIM OF FIRST APERTURE
C     DATA(I+3)  Y-DIM OF FIRST APERTURE
C     DATA(I+4)  X-DIM OF SECOND APERTURE
C     DATA(I+5)  Y-DIM OF SECOND APERTURE
C     IDATA(I+6) NUMBER OF CARDS TO JUMP OVER INCASE PARTICLE DOES NOT HIT
C                BOTH APERTURES.
C     IDATA(I+7) NUMBER OP APERTURES TO JUMP OVER INCASE PARTICLE DOES NOT HIT
C                BOTH APERTURES.
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC19/ CONE, ISTOR(100), SLIT1(100), SLIT2(100), NSLIT,
     A                ORIG, ISLT, IFF, IFG, A, B, RECTA
      LOGICAL CONE, ORIG, RECTA
      COMMON /BLOC44/ LINV, SINV, SINV2, MULTSC
      LOGICAL LINV, SINV, SINV2, MULTSC
C
C     CHECK ENTRANCE LIMITS
C
      A  = DATA(I+2)
      B  = DATA(I+3)
C
C     COLLIMATOR (16. 161. ;) DEFAULT
C
      IF (.NOT. LINV) THEN 
       IF (A .LE. 0.0) THEN
        IF (ABS(RAY(3)) .GT. B) GO TO 100
       ELSE IF (B .EQ. 0.0) THEN
        IF (ABS(RAY(1)) .GT. A) GO TO 100
       ELSE
        IF (RECTA) THEN
         IF (ABS(RAY(3)).GT.B .OR. ABS(RAY(1)).GT.A) GO TO 100
        ELSE
         IF ((RAY(1)/A)**2 + (RAY(3)/B)**2 .GT. 1.0) GO TO 100
        ENDIF
       ENDIF
C
C     TARGET (16. 160. ;)
C
      ELSE
       IF (A .LE. 0.0) THEN
        IF (ABS(RAY(3)) .LT. B) GO TO 100
       ELSE IF (B .EQ. 0.0) THEN
        IF (ABS(RAY(1)) .LT. A) GO TO 100
       ELSE
        IF (RECTA) THEN
         IF (ABS(RAY(3)).LT.B .OR. ABS(RAY(1)).LT.A) GO TO 100
        ELSE
         IF ((RAY(1)/A)**2 + (RAY(3)/B)**2 .LT. 1.0) GO TO 100
        ENDIF
       ENDIF
      ENDIF
C
C     TRANFER TO EXIT
C
      ZL   = DATA(I+1)
      RAY1 = RAY(1) + ZL * RAY(2)
      RAY3 = RAY(3) + ZL * RAY(4)
C
C     CHECK EXIT LIMITS
C
      A  = DATA(I+4)
      B  = DATA(I+5)
C
C     COLLIMATOR (16. 161. ;) DEFAULT
C
      IF (.NOT. LINV) THEN 
       IF (A .LE. 0.0) THEN
        IF (ABS(RAY3) .GT. B) GO TO 100
       ELSE IF (B .EQ. 0.0) THEN
        IF (ABS(RAY1) .GT. A) GO TO 100
       ELSE
        IF (RECTA) THEN
         IF (ABS(RAY3).GT.B .OR. ABS(RAY1).GT.A) GO TO 100
        ELSE
         IF ((RAY1/A)**2 + (RAY3/B)**2 .GT. 1.0) GO TO 100
        ENDIF
       ENDIF
C
C     TARGET (16. 160. ;)
C
      ELSE
       IF (A .LE. 0.0) THEN
        IF (ABS(RAY3) .LT. B) GO TO 100
       ELSE IF (B .EQ. 0.0) THEN
        IF (ABS(RAY1) .LT. A) GO TO 100
       ELSE
        IF (RECTA) THEN
         IF (ABS(RAY3).LT.B .OR. ABS(RAY1).LT.A) GO TO 100
        ELSE
         IF ((RAY1/A)**2 + (RAY3/B)**2 .LT. 1.0) GO TO 100
        ENDIF
       ENDIF
      ENDIF
C
C     JUMP OVER THIS AND THE NEXT NJ CARDS AND OVER NA APERTURES
C
      NJ      = IDATA(I+6)
      NA      = IDATA(I+7)
      IAP     = IAP + NA
      NEL     = NEL + NJ + 1
      I       = I + 8
      Z       = Z + ZL
      RAY(1)  = RAY1
      RAY(3)  = RAY3
      DO 10 J = 1, NJ
       NTYPE  = IDATA(I)
       I      = I + NU(NTYPE)
10    CONTINUE
      RETURN
C
100   I = I + 8
      NEL = NEL + 1
      RETURN
      END
      SUBROUTINE LOADX (XSS,NUM)
C
      CHARACTER*1 XSS(100), X, BLANK
      DATA X, BLANK / 'X', ' '  /
C
      NA = MIN(NUM,100)
      DO 110 J = 1, NA
  110 XSS(J) = X
      IF (NA - 100) 112, 120, 120
  112 NA = NA + 1
      DO 114 J = NA, 100
  114 XSS(J) = BLANK
  120 CONTINUE
      RETURN
      END
      SUBROUTINE MULT(LFLAG,IAP,STOPED)
C
C     THIS SUBROUTINE WAS EXTRACTED FROM REVMOC. IT COMPUTES THE
C     ADDITIONS TO  X', Y' AND P DUE TO MULTIPLE SCATTERING, NUCL.
C     ABSORPTION AND NUCLEAR ELASTIC SCATTERING IN 'THIN' LAYERS
C     OF MATTER (SEE LISTING OF U.B.C.'S REVMOC).
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC3/ NIN, NOUT
      COMMON /BLOC4/ RAYMAX(6), PBEAM, P0, NORAYS
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC16/ ISTOP(3,9998)
      REAL ISTOP
      COMMON /BLO16A/ KPART(3)
      CHARACTER*4     KPART
      COMMON /BLOC18/ LOSS, NBLK(20), KFLG(20),
     A                XSTRT(20), XEND(20), LTHX(20), XBIN(20), NUNX(20),
     A                YSTRT(20), YEND(20), LTHY(20), YBIN(20), NUNY(20)
      COMMON /BLOC46/ SM, GAMMA0, BETA0, CHARGE
      COMMON /BLOC47/ IRAN
      COMMON /BLOC49/ F(40),F0(40),F1(40),F2(40),FM1A(40),BL(260)
      COMMON /BLOC52/ W, POLX(0:2), POLY(0:2), POLZ(0:2), POLCAL
      LOGICAL POLCAL
      COMMON /BLOC55/ DEDX(3), VEKIN(3,5), VDEDX(3,5)
      LOGICAL DEDX
      LOGICAL STOPED
C
C     THE VALUES FOR BM,WM,TLAM,AL,ASN,DELT AND ENLOSS MAY BE EXTRACTED
C     FROM A REVMOC RUN WITH AN ABSORBER OF THE SAME MATERIAL WITH
C     THE SAME THICKNESS D1 :
C     BM     MEANS   B            ON REVMOC OUTPUT
C     WM       "     S             "    "      "
C     TLAM     "     TOT INT LEN   "    "      "
C     AL       "     ABS PROB      "    "      "
C     ASN      "     RMS ANGLE     "    "      "
C     DELT     "     WIDTH         "    "      "   ( LANDAU DIST,)
C     ENLOSS   "     ENERGY LOSS   "    "      "       "      "
      WM =     DATA(I+1)
      BM =     DATA(I+2)
      TLAM =   DATA(I+3)
      AL =     DATA(I+4)
      ASN =    DATA(I+5)
      DELT =   DATA(I+6)
      ENLOSS = DATA(I+7)
      IF (IDATA(I+9) .EQ. 3) GO TO 2
C
C     SEARCHING FOR NEXT DRIFT ELEMENT
C
      J = I
      NTYPE = 1
    1 J = J + NU(NTYPE)
      IF (J .GT. I1) THEN
       WRITE(NOUT,1000)
 1000  FORMAT(' Multiple scattering card has to be followed by a drift
     A card giving the length of the collimator element.')
       CALL MENU(1)
      END IF
      NTYPE = IDATA(J)
      IF (NTYPE .NE. 3) GO TO 1
      D1 = DATA(J+1)
      GO TO 5
C
    2 D1      = DATA(I+10)
    5 BETGAM  = P / SM
      GAMMA   = SQRT(1. + BETGAM**2)
      BETA    = BETGAM / GAMMA

C      Y2      = PBEAM / P
      Y2      = P0 / P

C      BG00    = PBEAM / SM
      BG00    = P0 / SM
      GAMMA00 = SQRT(1. + BG00**2)
      BETA00  = BG00 / GAMMA00

      Y1      = Y2 * BETA00 / BETA
C
C     TABULATE TABLES FOR MULTIPLE SCATTERING DISTRIBUIONS.
C
      IF (BM .EQ. BMOLD) GO TO 440
      FM1A(1) = 0.5
      DO 430 J = 2, 40
       FM1A(J) = F0(J) + F1(J) / BM + F2(J) / BM**2
  430 CONTINUE
      BMOLD = BM
  440 CONTINUE
C
C     CALCULATE THE CHANGES TO THE ANGLES X' AND Y' DUE TO
C     NUCLEAR ELASTIC SCATTERING AND CHANGE WEIGT OF PARTICE
C     DUE TO NUCLEAR ABSORBTION.
C
      IF (TLAM .LE. 0.0) GO TO 80
      CALL RANDOM(RND)
      DIS = -TLAM * LOG(1. - RND)
      IF (DIS .GE. D1) GO TO 80
      IF (AL .GT. 0.0) THEN
       WAL = W * AL
       ISTOP(LFLAG+1,IAP) = ISTOP(LFLAG+1,IAP) + WAL
       IF (LOSS .NE. 0) CALL HISTLO(LFLAG,WAL)
       W= W - WAL
      END IF
      CALL RANDOM(RND)
      TH = ASN * Y2 * SQRT(-2. * LOG(1. - RND))
      CALL RANDOM(RND)
      ARG = 6.283185 * RND
      RAY(2) = RAY(2) + TH * COS(ARG)
      RAY(4) = RAY(4) + TH * SIN(ARG)
   80 CONTINUE
C
C     CALCULATE THE CHANGES TO THE ANGLES X' AND Y' DUE TO
C     MULTIPLE ELASTIC SCATTERING (MOLIERE).
C     1 / (BETA * P) - SCALING
C
      CALL RANDOM(X)
      DO 30 J = 2, 40
       IF (FM1A(J) .GE. X) GO TO 40
   30 CONTINUE
      J = 40
   40 TH = F(J-1) + (F(J)-F(J-1)) * (X-FM1A(J-1)) / (FM1A(J)-FM1A(J-1))
      TH = TH * Y1 * WM
      IF (ABS(TH) .GT. 1.5708) TH = 1.5708
      CALL RANDOM(RND)
      ARG = 6.283185 * RND
      RAY(2) = RAY(2) + TH * COS(ARG)
      RAY(4) = RAY(4) + TH * SIN(ARG)
C
C     CALCULATE THE CHANGE TO THE MOMENTUM
C     DO EITHER LINEAR INTERPOLATION IF DE/DX-DATA ARE PRESENT
C     OR DO I / P - SCALING IF DATA ARE NOT PRESENT
C
      DE = 0.0
      IF (DELT .NE. 0.0) THEN
        CALL RANDOM(RND)
        DE = DELT / 5.8 * DINLAN(RND)
      ENDIF
      DE= DE + ENLOSS
      IF (DE .EQ. 0.0) RETURN
      E = P**2 / ((1. + GAMMA) * SM)
      K = LFLAG + 1
      IF (DEDX(K)) THEN
       VLOGE = LOG10(E)
       DO 100 J = 2, 5
        IF (VLOGE .GE. VEKIN(K,J)) GO TO 120
  100  CONTINUE
       J = 5
  120  SLOPE = (VDEDX(K,J-1) - VDEDX(K,J)) / (VEKIN(K,J-1) - VEKIN(K,J))
       VDE = VDEDX(K,J) + SLOPE * (VLOGE - VEKIN(K,J))
       DE = DE * 10.**VDE
      ELSE
       DE = DE * Y2
      ENDIF
      E = E - DE
      IF (E .LE. 0.0) THEN
       E = 0.0
       STOPED = .TRUE.
      ENDIF
      P = SQRT(E * (2. * SM + E))
C      RAY(6) = P/PBEAM - 1.
      RAY(6) = P/P0 - 1.
C
C
      RETURN
      END
      SUBROUTINE MULTI
C
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC14/ MMAX, GTOP, DB(20), COSM(20), SINM(20)
C
      DBX = 0.0
      DBY = 0.0
      DBC = 0.0
      DBS = 1.0
      X = RAY(1)
      Y = RAY(3)
      DO 10 NM = 1, MMAX
      IF(DB(NM) .EQ. 0.0) GO TO 5
      DBX = DBX + DB(NM) * (DBC * COSM(NM) - DBS * SINM(NM))
      DBY = DBY + DB(NM) * (DBC * SINM(NM) + DBS * COSM(NM))
    5 DBT = DBC * X + DBS * Y
      DBS = DBS * X - DBC * Y
   10 DBC = DBT
      RAY(2) = RAY(2) - GTOP * DBY
      RAY(4) = RAY(4) + GTOP * DBX
      RETURN
      END
      INTEGER FUNCTION NU(TYPE)
      INTEGER             TYPE
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC5/ SEC, CAP(3), MPA, THIRD
      LOGICAL         SEC, CAP, MPA, THIRD
      INTEGER NO1(30), NO2(4), TYP1
C
      DATA NO1
     X /9,11,2,6,4,5,7,0,2,0,5,0,2,8,0,5,2,3,3,3,4,0,0,0,0,4,4,9,8,12/
      DATA NO2 /1,1,1,2/
C
      IF (SEC .AND. TYPE .EQ. 4) GO TO 200
      IF(TYPE .EQ. 14 .AND. IDATA(I+8) .EQ. 0) GO TO 300
      IF (TYPE .GE. 50) GO TO 100
      IABST = IABS(TYPE)
      NU = NO1(IABST)
      RETURN
  100 TYP1 = TYPE - 49
      NU = NO2(TYP1)
      RETURN
  200 NU = 41
      RETURN
  300 NU = 30
      RETURN
      END
      SUBROUTINE OCTO
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC5/ SEC, CAP(3), MPA, THIRD
      LOGICAL         SEC, CAP, MPA, THIRD
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC15/ LL, KH2, KV2, KH, KV, KHL, KVL, RAY2(6),
     A                RH(4), RV(4), LILENS, SOLSEG
      LOGICAL LILENS, SOLSEG
      REAL LL, KH2, KV2, KH, KV, KHL, KVL
C
      RAY2(1) = RAY(1) + LL * RAY(2)
      RAY2(2) = RAY(2)
      RAY2(3) = RAY(3) + LL * RAY(4)
      RAY2(4) = RAY(4)
      IF (.NOT. THIRD) GO TO 100
C
C     THIRD ORDER CONTRIBUTIONS
C
      W     = DATA(I+2) / P
      WL    = W   * LL
      WL2   = WL  * LL
      WL3   = WL2 * LL
      WL4   = WL3 * LL
      WL5   = WL4 * LL
      E1    = -0.5  * WL2
      E2    = -0.5  * WL3
      E3    = -0.25 * WL4
      E4    =  1.5  * WL2
      E5    =         WL3
      E6    =  0.25 * WL4
      E7    = -0.05 * WL5
      E8    =  0.50 * WL3
      E9    =  0.5  * WL4
      E10   =  0.15 * WL5
      E11   = -1.0  * WL
      E12   = -1.5  * WL2
      E13   = -1.0  * WL3
      E14   =  3.0  * WL
      E15   =  3.0  * WL2
      E16   =         WL3
      E17   = -0.25 * WL4
      E18   =  1.5  * WL2
      E19   =  2.0  * WL3
      E20   =  0.75 * WL4
      B1    = RAY(1)**3
      B2    = RAY(1)**2 * RAY(2)
      B3    = RAY(1) * RAY(2)**2
      B4    = RAY(1) * RAY(3)**2
      B5    = RAY(1) * RAY(3) * RAY(4)
      B6    = RAY(1) * RAY(4)**2
      B7    = RAY(2)**3
      B8    = RAY(2) * RAY(3)**2
      B9    = RAY(2) * RAY(3) * RAY(4)
      B10   = RAY(2) * RAY(4)**2
      B11   = RAY(3)**3
      B12   = RAY(3)**2 * RAY(4)
      B13   = RAY(3) * RAY(4)**2
      B14   = RAY(3) * RAY(1)**2
      B15   = RAY(3) * RAY(1) * RAY(2)
      B16   = RAY(3) * RAY(2)**2
      B17   = RAY(4)**3
      B18   = RAY(4) * RAY(1)**2
      B19   = RAY(4) * RAY(1) * RAY(2)
      B20   = RAY(4) * RAY(2)**2
      SUM1  = E1 *B1  + E2 *B2  + E3 *B3  + E4 *B4  + E5 *B5
     X      + E6 *B6  + E7 *B7  + E8 *B8  + E9 *B9  + E10*B10
      SUM2  = E11*B1  + E12*B2  + E13*B3  + E14*B4  + E15*B5
     X      + E16*B6  + E17*B7  + E18*B8  + E19*B9  + E20*B10
      SUM3  = E1 *B11 + E2 *B12 + E3 *B13 + E4 *B14 + E5 *B15
     X      + E6 *B16 + E7 *B17 + E8 *B18 + E9 *B19 + E10*B20
      SUM4  = E11*B11 + E12*B12 + E13*B13 + E14*B14 + E15*B15
     X      + E16*B16 + E17*B17 + E18*B18 + E19*B19 + E20*B20
      RAY2(1) = RAY2(1) + SUM1
      RAY2(2) = RAY2(2) + SUM2
      RAY2(3) = RAY2(3) + SUM3
      RAY2(4) = RAY2(4) + SUM4
  100 CALL RSETR (RAY, RAY2)
      RETURN
      END
      LOGICAL FUNCTION OSTOP(LFLAG)
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC5/ SEC, CAP(3), MPA, THIRD
      LOGICAL         SEC, CAP, MPA, THIRD
      COMMON /BLOC11/ QAP(3), ELLIPS, HYPER
      LOGICAL         ELLIPS, HYPER
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
C
      IF(.NOT. CAP(LFLAG+1)) GO TO 30
      IF(ELLIPS) GO TO 10
      IF(RAY(1) ** 2 + RAY(3) ** 2 .GT. DATA(I+3)) GO TO 40
      GO TO 30
   10 IF((RAY(1)/QAP(1)) ** 2 + (RAY(3)/QAP(2)) ** 2 .GT. 1.0) GO TO 40
   30 OSTOP = .FALSE.
      RETURN
   40 OSTOP = .TRUE.
      RETURN
      END
      SUBROUTINE OHIST
C
C     HISTOGRAM OUTPUT ROUTINE
C
      COMMON /BLOC2/  UNIT(12)
      COMMON /BLOC2A/ NAME(12), NOM(12), NOM1(4), DSTOR(20)
      CHARACTER*4     NAME, NOM, NOM1, DSTOR
      COMMON /BLOC3/ NIN, NOUT
      COMMON /BLOC6/ NHISTS, NHIST, LIMNO
      COMMON /BLOC7/ MTYPE(100), NENTRY(100), NCOOR(100), INTVLS(100),
     A                BEGIN(100), END(100), STEP(100), ZHIST(100)
      COMMON /BLOC7A/ LTAG(100)
      CHARACTER*4     LTAG
      COMMON /BLOC8/ MTABLE(50000)
      REAL           MTABLE
      COMMON /BLOC12/ VALUE(100), XMOM(100), XMOM2(100), NFLAG(100),
     A                SET(100), KFLAG(100), IFLAG(3,0:9), ZFLAG(9),
     A                WZ(100), UFLAG(100), INVFL, ZC
      LOGICAL SET, IFLAG, UFLAG, INVFL
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC16/ ISTOP(3,9998)
      REAL ISTOP
      COMMON /BLO16A/ KPART(3)
      CHARACTER*4     KPART
      COMMON /BLOC18/ LOSS, NBLK(20), KFLG(20),
     A                XSTRT(20), XEND(20), LTHX(20), XBIN(20), NUNX(20),
     A                YSTRT(20), YEND(20), LTHY(20), YBIN(20), NUNY(20)
      LOGICAL LEGAL
C
      NH = 0
      DO 500 K = 1, NHISTS
      M = NENTRY(K)
      N = INTVLS(K)
      NUNIT = NCOOR(K)
      CALL HSTUN (NUNIT, FACT, LEGAL)
      XBEG = BEGIN(K) / FACT
      DX = STEP(K) / FACT
      ZC = ZHIST(K)/UNIT(8)
      KFL = KFLAG(K) + 1
      NFL = NFLAG(K)
      IF(UFLAG(K)) NFL = - NFL
      NAVEL = MTYPE(K)
      GO TO (100,200,300), NAVEL
C
C     ONE DIMENSIONAL HISTOGRAM
C
  100 NH = NH + 1
      WRITE (NOUT, 9500) NH, LTAG(K)
 9500 FORMAT(/,'1Histogram No',I3,20X,A4)
      CALL HISCAP (1, NUNIT, KFL, ZC, NFL)
      CALL TRHIST (MTABLE(M), N, XBEG, DX)
c
c      SUM = MTABLE(M+N+2) - MTABLE(M+N+1) - MTABLE(M+N)
c      IF(SUM .EQ. 0.0) GO TO 110
c      XM = XMOM(K) / (SUM * FACT)
c      ARGUM = XMOM2(K) / (SUM * FACT ** 2) - XM ** 2
c      IF(ARGUM.LT.0.0) ARGUM = 0.0
c      XM2 = SQRT( ARGUM )
c
      CALL MEAN(MTABLE(M), XBEG, N, DX, SUM, XM, XM2, IER)
      WRITE (NOUT, 9100) XM, XM2
 9100 FORMAT(11X,'center =',F8.3,3X,'RMS half width =',F8.3)
  110 WRITE (NOUT, 9510) NH, LTAG(K)
 9510 FORMAT(/' Histogram No',I3,20X,A4)
      CALL HISCAP (1, NUNIT, KFL, ZC, NFL)
      GO TO 500
C
C     X COORDINATE OF TWO DIMENSIONAL HISTOGRAM
C
  200 NA = N
      NUNA = NUNIT
      ZA = ZC
      AMIN = XBEG
      DA = DX
      KFLA = KFL
      NFLA = NFL
      GO TO 500
C
C     Y COORDINATE OF TWO DIMENSIONAL HISTOGRAM
C
  300 NH = NH + 1
      WRITE (NOUT, 9500) NH, LTAG(K)
      CALL HISCAP (2, NUNA, KFLA, ZA, NFLA)
      CALL HISCAP (3, NUNIT, KFL, ZC, NFL)
      CALL OUTMAT (MTABLE(M), AMIN,NA,DA, XBEG,N,DX)
      CALL ELLIPS (MTABLE(M), AMIN,NA,DA, XBEG,N,DX)
      WRITE (NOUT, 9510) NH, LTAG(K)
      CALL HISCAP (2, NUNA, KFLA, ZA, NFLA)
      CALL HISCAP (3, NUNIT, KFL, ZC, NFL)
  500 CONTINUE
C
C     HISTOGRAMS OF PARTICLES LOST
C
      IF(LOSS .EQ. 0) RETURN
      DO 700 K = 1, LOSS
      NH = NH + 1
      KFL = KFLG(K) + 1
      WRITE (NOUT, 9520) NH, KPART(KFL)
 9520 FORMAT(/,'1Histogram No',I3,' of ',A4,' lost')
      M = NBLK(K)
      N = LTHX(K)
      NUNIT = NUNX(K)
      CALL HSTUN (NUNIT, FACT, LEGAL)
      XBEG = XSTRT(K) / FACT
      DX = XBIN(K) / FACT
      NUND = NUNY(K)
      IF(NUND .NE. 0) GO TO 600
C
C     Z DISTRIBUTION
C
      CALL HISCAP (4, NUNIT, 0, 0.0, 0)
      CALL TRHIST (MTABLE(M), N, XBEG, DX)
      WRITE (NOUT, 9530) NH, KPART(KFL)
 9530 FORMAT(/' Histogram No',I3,' of ',A4,' lost')
      CALL HISCAP (4, NUNIT, 0, 0.0, 0)
      GO TO 700
C
C     Z VERSUS ANOTHER COORDINATE
C
  600 ND   = LTHY (K)
      CALL HSTUN (NUND, FACT, LEGAL)
      DMIN = YSTRT(K) / FACT
      DD = YBIN(K) / FACT
      CALL HISCAP (5, NUNIT, 0, 0.0, 0)
      CALL HISCAP (6, NUND, 0, 0.0, 0)
      CALL OUTMAT (MTABLE(M),XBEG,N,DX,DMIN,ND,DD)
      WRITE (NOUT, 9530) NH, KPART(KFL)
      CALL HISCAP (5, NUNIT, 0, 0.0, 0)
      CALL HISCAP (6, NUND, 0, 0.0, 0)
  700 CONTINUE
      RETURN
      END
      SUBROUTINE OKOLL(IAP,LFLAG,*)
C
C     THIS SUBROUTINE CHECKS OUTER COLLIMATOR DIMENSIONS
C     ONLY RECTANGULAR, CIRCULAR AND ELLIPTICAL CROSS SECTIONS
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC22/ ODIMX, ODIMY, OUTREC, OUTDIM
      LOGICAL OUTREC, OUTDIM
C
C     CHECK IF PARTICLE OUTSIDE
C
      XR = RAY(1)
      YR = RAY(3)
      IF (OUTREC) THEN
       IF (ABS(XR).GT.ODIMX .OR. ABS(YR).GT.ODIMY) THEN
        I = I + 14
        NEL = NEL + 2
        IF (IDATA(I) .NE. 3)
     1  STOP 'Use of 16. 176. card sequence not correct'
        RETURN 1
       ENDIF
      ELSE
       IF ((XR/ODIMX)**2 + (YR/ODIMY)**2 .GT. 1.0) THEN
        I = I + 14
        NEL = NEL + 2
        IF (IDATA(I) .NE. 3)
     1  STOP 'Use of 16. 176. card sequence not correct'
        RETURN 1
       ENDIF
      ENDIF
      RETURN
      END
      SUBROUTINE OUTMAT (IPLOT, AMIN,NA,DA, DMIN,ND,DD)
      REAL               IPLOT(2000)
C
C     OUTMAT PRINT ROUTINE FOR TWO DIMENSIONAL HISTOGRAMS
C
      COMMON /BLOC3/ NIN, NOUT
      CHARACTER*132 LINE
      CHARACTER*1 BCDW, DIGIT,IBLANK,IDASH,IEND,IAST
      CHARACTER*1 IAROW(110)
      CHARACTER*1 AROW(110), TOT(6)
      REAL        ALABEL(15)
      EQUIVALENCE (AROW,IAROW)
      DATA TOT                       / 't', 'o', 't', 'a', 'l', 's' /
      DATA IBLANK, IDASH, IEND, IAST / ' ' , '-', 'I', '*' /
C
      MTT = (NA + 1)*(ND + 1) + 5
      CALL NEWSUM2(IPLOT(1), NA, ND)
      IF(IPLOT(MTT)) 2,2,4
C
C     UNFILLED HISTOGRAM
C
    2 WRITE (NOUT, 9001)
      RETURN
 9001 FORMAT(5(//),/' Histogram is unfilled.',5(//))
C
C     X COORDINATES
C
    4 NLA = NA / 10 + 1
      LINE = ' '
      ALABEL(1) = AMIN
      DO 15 N = 2, NLA
   15 ALABEL(N) = ALABEL(N - 1) + 10.0*DA
      NALL = NA + 4
      DO 17 N = 1, NALL
   17 IAROW(N) = IBLANK
      DO 18 N = 1, 6
   18 AROW(NALL+N) = TOT(N)
      NALP = NALL + 6
      WRITE (LINE,9003) (IAROW(N), N = 1, NALP)
 9003 FORMAT (22X,110A1)
      DO 19 K = 1, NLA
       KK = 16+(K-1)*10
       WRITE (LINE(KK:KK+9),9002) ALABEL(K)
 9002  FORMAT (F10.3)
   19 CONTINUE
      WRITE (NOUT,9303) LINE
 9303 FORMAT (//A132)
C
C     UPPER X AXIS
C
      ICT = 1
      NAM = NA + 1
      DO 24 I = 1, NAM
      IAROW(I) = IDASH
      IF (ICT .EQ. 1 .OR. ICT .EQ. 5) IAROW(I) = IAST
      ICT = ICT + 1
      IF (ICT .EQ. 6) ICT = 1
   24 CONTINUE
      IAROW(NA+2) = IEND
      NAM = NA + 3
      NAP = NA + 10
      DO 26 I = NAM, NAP
   26 IAROW(I) = IDASH
      WRITE (NOUT,9024) (IAROW(M), M = 1, NAP)
 9024 FORMAT(21X,'I*',110A1)
C
C     BODY OF HISTOGRAM
C
      NAP = NA + 9
      DHIGH=DMIN+ND*DD
      DLOW=DHIGH-DD
      DO 60 N = 1, ND
      MM=(ND-N)*(NA+1)
      DO 30 K = 1, NAP
   30 IAROW(K) = IBLANK
      DO 48 K = 1, NA
      MM = MM + 1
      XX = IPLOT(MM)
      AROW(K) = BCDW(XX)
   48 CONTINUE
      IAROW(NA+1) = IBLANK
      IAROW(NA+2) = IEND
      MM = MM + 1
      NN = NINT(IPLOT(MM))
      DO 50 K = 1, 6
   50 AROW(NA+K+3) = DIGIT(NN,K)
      WRITE (NOUT,9004) DHIGH, DLOW, (IAROW(K), K = 1, NAP)
 9004 FORMAT (' ',F8.3,' to',F8.3,' I ',110A1)
      DHIGH=DLOW
      DLOW=DHIGH-DD
   60 CONTINUE
C
C     LOWER X AXIS
C
      ICT = 1
      NAM = NA + 1
      DO 74 I = 1, NAM
      IAROW(I) = IDASH
      IF (ICT .EQ. 1 .OR. ICT .EQ. 5) IAROW(I) = IAST
      ICT = ICT + 1
      IF (ICT .EQ. 6) ICT = 1
   74 CONTINUE
      IAROW(NA+2) = IEND
      NAM = NA + 3
      NAP = NA + 10
      DO 76 I = NAM, NAP
   76 IAROW(I) = IDASH
      WRITE (NOUT,9024) (IAROW(M), M = 1, NAP)
C
C     SUMS OF COLUMNS
C
      NAM = NA + 2
      MM=ND*(NA+1)
      DO 85 K = 1, NAP
   85 IAROW(K) = IBLANK
      IAROW(NAM) = IEND
      DO 90 IR = 1, 6
      DO 86   K = 1, NA
      MM = MM + 1
      NN = NINT(IPLOT(MM))
      AROW(K) = DIGIT(NN,IR)
   86 CONTINUE
      MM = MM + 1
      IF (IR .EQ. 6) GO TO 87
      WRITE (NOUT,9007) (IAROW(K), K = 1, NAP)
      MM = MM - NA - 1
      GO TO 90
   87 NN = NINT(IPLOT(MM))
      DO 88 K = 1, 6
   88 AROW(NA+K+3) = DIGIT(NN,K)
      WRITE (NOUT,9006) (IAROW(K), K = 1, NAP)
 9006 FORMAT (13X,'totals  I ',110A1)
 9007 FORMAT (21X,'I ',110A1)
   90 CONTINUE
C
C     SUMMARY
C
      WRITE (NOUT,9104) NINT(IPLOT(MTT)),(NINT(IPLOT(MM+I)),I=1,4)
 9104 FORMAT (/,10X,'total number of entries = ',I10,' including',
     1' underflow and overflow as follows'//,32X,'underflow',7X,
     2'overflow',/,21X,'across',2(5X,I10),/,21X,'down  ',2(5X,I10)/)
 120  RETURN
      END
      SUBROUTINE PKOLL(IAP,LFLAG,*,*)
C
C     THIS SUBROUTINE TREATS COLLIMATORS CUT BY COOLING PIPES
C     ONLY FOR PARENT PARTICLES
C     ONLY CIRCULAR AND ELLIPTICAL CROSS SECTION
C     MULTIPLE SCATTERING MUST BE SWITCHED ON
C     SLIT CARD MUST BE FOLLOWED BY 2 TYPE CODE 1 CARDS:
C     1ST CONTAINS DATA FOR SOLID WALL MATERIAL
C     2ND CONTAINS DATA FOR COOLING REGION
C     THE 2 TYPE CODE 1 CARDS MUST BE FOLLOWED BY A DRIFT CARD (LENGTH OF ELE)
C     COMPILED BY U. ROHRER (SIN), MAY 1986
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC3/ NIN, NOUT
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC19/ CONE, ISTOR(100), SLIT1(100), SLIT2(100), NSLIT,
     A                ORIG, ISLT, IFF, IFG, A, B, RECTA
      LOGICAL CONE, ORIG, RECTA
      COMMON /BLOC21/ PIPES, DIST, PTHIK, PRAD, PPER, TTHIK
      LOGICAL         PIPES
      COMMON /BLOC44/ LINV, SINV, SINV2, MULTSC
      LOGICAL LINV, SINV, SINV2, MULTSC
C
      LOGICAL         FIRST, STOPED
      DATA            FIRST /.TRUE./
C
C     PERFORM SOME CHECKS
C
      IF (FIRST) THEN
       IF (LINV .OR. RECTA .OR.
     X     IDATA(I+1).NE.1 .OR. IDATA(I+3).NE.3) THEN
        WRITE(NOUT,*) 'Collimator cut by cooling pipes only
     X allowed with circular or elliptical cross section.'
        CALL MENU(1)
       ENDIF
C
       IF (.NOT.MULTSC) THEN
        WRITE(NOUT,*) 'Collimator cut by cooling pipes only allowed
     X with multiple scattering turned on.'
        CALL MENU(1)
       ENDIF
C
       IF (IDATA(I+5).NE.1 .AND. IDATA(I+5+9).NE.1 .AND.
     X     IDATA(I+5+8).NE.0 .AND. IDATA(I+5+9+8).NE.0) THEN
        WRITE(NOUT,*) 'Slit card must be followed by 2 type code
     X 1 cards, containig information for cut-collimator.'
        CALL MENU(1)
       ENDIF
C
C      DATA ON SECOND TYPE CODE 1 CARD CONTAIN MS-DATA FOR MATERIAL IN
C      COOLING REGION. THIS CARD MUST BE FOLLOWED BY DRIFT.
C
       IF (IDATA(I+5+9+9) .NE. 3) THEN
        WRITE(NOUT,*) '2 Type-code 1 cards must be followed by drift'
        CALL MENU(1)
       ENDIF
C
       IF (LFLAG .NE. 0) THEN
        WRITE(NOUT,*) 'Cut-Collimator only allowed for parents.'
        CALL MENU(1)
       ENDIF
       FIRST = .FALSE.
      ENDIF
C
C     CHECK IF PARTICLE DOES NOT HIT COLLIMATOR
C
      XR = RAY(1)
      YR = RAY(3)
      A  = DATA(I+2)
      B  = DATA(I+4)
      IF ((XR/A)**2 + (YR/B)**2 .LT. 1.0) THEN
       I = I + 23
       NEL = NEL + 3
       RETURN 1
      ENDIF
C
C     CHECK IF PARTICLE DOES NOT HIT COOLING REGION
C
      IF (ABS(YR).LT.DIST .OR. ABS(YR).GT.DIST+PTHIK) THEN
       I = I + 5
       NEL = NEL + 1
       NTYPE = 1
       STOPED = .FALSE.
       CALL MULT(0,IAP,STOPED)
       IF (STOPED) RETURN 2
       I = I + 18
       NEL = NEL + 2
       RETURN 1
      ELSE
C
C     PARTICLE HITS COOLING REGION
C
       XPOS = MOD(ABS(XR),PPER) - PPER / 2.
       YPOS = ABS(YR) - DIST - PTHIK / 2.
       RPOS = SQRT(XPOS**2 + YPOS**2)
C
C      PARTICEL HITS INNER CROSS SECTION OF COOLING PIPES
C
       IF (RPOS .LT. PRAD - TTHIK) THEN
        I   = I + 23
        NEL = NEL + 3
        RETURN 1
C
C      PARTICEL HITS WALL MATERIAL OF COOLING PIPE (TAKE 2ND TYPE CODE 1 CARD)
C
       ELSE IF (RPOS .LT. PRAD) THEN
        I       = I + 14
        NEL     = NEL + 2
        NTYPE   = 1
        STOPED = .FALSE.
        CALL MULT(0,IAP,STOPED)
        IF (STOPED) RETURN 2
        I          = I + 9
        NEL        = NEL + 1
        RETURN 1
C
C      PARTICLE HITS STILL COLLIMATOR MATERIAL (1ST TYPE CODE 1 CARD)
C
       ELSE IF (YPOS .LT. PRAD / 2.) THEN
        I = I + 5
        NEL = NEL + 1
        NTYPE = 1
        STOPED = .FALSE.
        CALL MULT(0,IAP,STOPED)
        IF (STOPED) RETURN 2
        I = I + 18
        NEL = NEL + 2
        RETURN 1
C
C      PARTICLE HITS AIR SPACE
C
       ELSE
        I   = I + 23
        NEL = NEL + 3
        RETURN 1
       ENDIF
      ENDIF
      END
      SUBROUTINE PRINT1 (LABEL, NWORD, DATA, VARY)
C     PRINT DATA FOR ONE ELEMENT
      COMMON /BLOC2/  UNIT(12)
      COMMON /BLOC2A/ NAME(12), NOM(12), NOM1(4), DSTOR(20)
      CHARACTER*4     NAME, NOM, NOM1, DSTOR
      COMMON /BLOC3/ NIN, NOUT
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
C
      CHARACTER*1 CHAR(12)
      CHARACTER*4 LABEL
      INTEGER VARY(30), NV(21)
      REAL    DATA(30)
      DATA NV / 6,1,1,3,2,0,0,6,0,1,0,0,0,6,0,2,0,2,2,1,0 /
C
      NTYPE = DATA(1)
      KTYPE = IABS(NTYPE)
      IF(KTYPE .EQ. 15) GO TO 50
      DO 10 J = 1, 12
   10 CHAR(J) = BLANK
      IF(NTYPE .LE. 0) GO TO 40
      KV = 1
      IF(NTYPE .LE. 21) KV = NV(NTYPE)
      IF(KV .EQ. 0) GO TO 40
      LV = 0
      DO 30 JV = 1, KV
      K = IABS(VARY(JV+1))
      IF(VARY(JV+1) .GE. 0) GO TO 20
      LV = LV + 1
      CHAR(LV) = MINUS
   20 LV = LV + 1
   30 CHAR(LV) = TABLE(K+1)
   40 IF(NWORD .LE. 1) GO TO 60
      IF(NWORD .EQ. 9) GO TO 45
      WRITE (NOUT, 940) NTYPE, CHAR, LABEL,
     A                  (BLANK, DATA(J), J = 2, NWORD), SEMI(1)
      RETURN
   45 WRITE (NOUT, 945) NTYPE, CHAR, LABEL,
     A                  (BLANK, DATA(J), J = 2, 9), SEMI(1)
      RETURN
   50 III = DATA(3)
      WRITE (NOUT, 950) NTYPE, LABEL, DATA(2), DSTOR(III), DATA(4)
      RETURN
   60 WRITE (NOUT, 960) NTYPE, CHAR, LABEL
      RETURN
C
  940 FORMAT(' ',I4,'.',12A1,' /',A4,'/ ',A1,8(F12.6,A1)/
     A       (27X,8(F12.6,A1)))
  945 FORMAT(' ',I4,'.',12A1,' /',A4,'/ ',A1,8(F12.6,A1))
  950 FORMAT(' ',I4,'.',13X,'/',A4,'/ ',F13.6,'    /',A4,'/   ',
     A       F13.6,' =')
  960 FORMAT(' ',I4,'.',12A1,' /',A4,'/ ;')
      END
      LOGICAL FUNCTION QSTOP(LFLAG)
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC5/ SEC, CAP(3), MPA, THIRD
      LOGICAL         SEC, CAP, MPA, THIRD
      COMMON /BLOC11/ QAP(3), ELLIPS, HYPER
      LOGICAL         ELLIPS, HYPER
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
C
      IF(.NOT. CAP(LFLAG+1)) GO TO 30
      IF(ELLIPS) GO TO 10
      IF(HYPER) GO TO 20
      IF(RAY(1) ** 2 + RAY(3) ** 2 .GT. DATA(I+3)) GO TO 40
      GO TO 30
   10 IF((RAY(1)/QAP(1)) ** 2 + (RAY(3)/QAP(2)) ** 2 .GT. 1.0) GO TO 40
      IF(.NOT. HYPER) GO TO 30
   20 IF(ABS(RAY(1) * RAY(3)) .GT. QAP(3)) GO TO 40
   30 QSTOP = .FALSE.
      RETURN
   40 QSTOP = .TRUE.
      RETURN
      END

      SUBROUTINE EPRISM(KSTOP)
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC15/ LL, KH2, KV2, KH, KV, KHL, KVL, RAY2(6),
     A                RH(4), RV(4), LILENS, SOLSEG
      LOGICAL LILENS, SOLSEG
      REAL LL, KH2, KV2, KH, KV, KHL, KVL
      COMMON /BLOC46/ SM, GAMMA0, BETA0, CHARGE

      KSTOP = 0
      KH  = DATA(I+2)
      KV  = DATA(I+3)
      H   = DATA(I+4)
      KHL = KH * LL
      KVL = KV * LL

      R11 = COS(KHL)
      R22 = R11
      R12 = SIN(KHL) / KH
      R21 = -SIN(KHL) * KH
      R16 = H * (1.0 - R11) / KH**2
      R26 = H * R12

      R33 = COS(KVL)
      R44 = R33
      R34 = SIN(KVL) / KV
      R43 = -SIN(KVL) * KV

      RAY2(1) = R11 * RAY(1) + R12 * RAY(2) + R16 * RAY(6)
      RAY2(2) = R21 * RAY(1) + R22 * RAY(2) + R26 * RAY(6)
      RAY2(3) = R33 * RAY(3) + R34 * RAY(4)
      RAY2(4) = R43 * RAY(3) + R44 * RAY(4)
      RAY(1)  = RAY2(1)
      RAY(2)  = RAY2(2)
      RAY(3)  = RAY2(3)
      RAY(4)  = RAY2(4)
      RETURN
      END

      SUBROUTINE QUAD
C
C     IF LILENS = .TRUE. THEN QUAD IS TRANSFORMED INTO A 'LITHIUM LENS'
C     FOR DETAILS SEE NUCLEAR INSTRUMENTS AND METHODS 190 (1981) P9-14
C     AND IEEE TRANSACTIONS ON NUCLEAR SCIENCE NS-30, NO. 4 P3660-3662
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC2/  UNIT(12)
      COMMON /BLOC2A/ NAME(12), NOM(12), NOM1(4), DSTOR(20)
      CHARACTER*4     NAME, NOM, NOM1, DSTOR
      COMMON /BLOC5/ SEC, CAP(3), MPA, THIRD
      LOGICAL         SEC, CAP, MPA, THIRD
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC15/ LL, KH2, KV2, KH, KV, KHL, KVL, RAY2(6),
     A                RH(4), RV(4), LILENS, SOLSEG
      LOGICAL LILENS, SOLSEG
      REAL LL, KH2, KV2, KH, KV, KHL, KVL
      COMMON /BLOC15A/ EQUAD, EBEND, BSCAL, BSCAL2, NSCAL, ISWITCH
      LOGICAL EQUAD, EBEND
      COMMON /BLOC46/ SM, GAMMA0, BETA0, CHARGE
      COMMON /BLOC60/ NCT
      COMMON /BLOC61/ DBQ, DBQQ, OLDG, DPP0, P0SV
      COMMON /BLOC62/ IUNIT3RD, NUMLIM, ZZ
C
      REAL X(20), Y(20)
C
      IF (EQUAD) THEN
       BG = P / SM
       GAMMA = SQRT( 1. + BG ** 2 )
       E = P**2 / ((1. + GAMMA) * SM)
       RIE = E * (1. + GAMMA) / GAMMA
       IF (DBQ .EQ. 0.0) THEN
        KH2 = DATA(I+2) / RIE
       ELSE
        IF (DATA(I+2) .NE. OLDG) THEN
         UNITSP = 0.0001  ! kV/cm --> GV/m
         CALL RANDOM(RND)
         IF (DBQ .GT. 0.0)
     X    DBQQ = DBQ * UNITSP * CHARGE * COS(3.14159 * RND)
         IF (DBQ .LT. 0.0)
     X    DBQQ = DBQ * UNITSP * CHARGE * (2.0 * RND - 1.0)
         OLDG = DATA(I+2)
        ENDIF
        APER = SQRT(DATA(I+3))
        KH2  = (DATA(I+2) * APER + DBQQ) / (RIE * APER)
       ENDIF
      ELSE
       IF (DBQ .EQ. 0.0) THEN
        KH2 = DATA(I+2) / P
       ELSE
        IF (DATA(I+2) .NE. OLDG) THEN
         CALL RANDOM(RND)
         IF (DBQ .GT. 0.0)
     X    DBQQ = DBQ * UNIT(9) * CHARGE / 33.356 * COS(3.14159 * RND)
         IF (DBQ .LT. 0.0)
     X    DBQQ = DBQ * UNIT(9) * CHARGE / 33.356 * (2.0 * RND - 1.0)
         OLDG = DATA(I+2)
        ENDIF
        APER = SQRT(DATA(I+3))
        KH2  = (DATA(I+2) * APER + DBQQ) / (P * APER)
       ENDIF
      ENDIF
      KV2 = KH2
      IF (.NOT.LILENS) KV2 = - KH2
      CALL FOCSG (KH2, LL, KH, KHL, RH)
      CALL FOCSG (KV2, LL, KV, KVL, RV)
      RAY2(1) = RH(1) * RAY(1) + RH(2) * RAY(2)
      RAY2(2) = RH(3) * RAY(1) + RH(4) * RAY(2)
      RAY2(3) = RV(1) * RAY(3) + RV(2) * RAY(4)
      RAY2(4) = RV(3) * RAY(3) + RV(4) * RAY(4)
C
C     THIRD ORDER CONTRIBUTIONS (NOT VALID FOR LITHIUM LENS)
C
      IF (.NOT. THIRD) GO TO 100
C
      IF (IUNIT3RD .NE. 0 .AND. NCT .LT. NUMLIM) THEN
       WRITE(IUNIT3RD,*) ' '
       WRITE(IUNIT3RD,1234) LABEL(NEL), NCT, ZZ 
 1234  FORMAT('*QUAD* ',A4,' with ray ',I2,' at z=',F8.3,' m')
       WRITE(IUNIT3RD,1235) RAY2(1)/UNIT(1),NAME(1),
     X                      RAY2(2)/UNIT(2),NAME(2), 
     X                      RAY2(3)/UNIT(3),NAME(3),
     X                      RAY2(4)/UNIT(4),NAME(4)
 1235  FORMAT(   'x    =',F8.3,1X,A2,
     X         ', x''   =',F8.3,1X,A2,
     X         ', y    =',F8.3,1X,A2,
     X         ', y''   =',F8.3,1X,A2)
      ENDIF
C
      IF (EQUAD) THEN
       CALL FOCSG3E(KH2,LL,BETA0,X,Y)
      ELSE
       CALL FOCSG3(KH2,LL,RH,RV,X,Y)
      ENDIF
      B1  = RAY(1)**3
      B2  = RAY(1)**2 * RAY(2)
      B3  = RAY(1) * RAY(2)**2
      B4  = RAY(1) * RAY(3)**2
      B5  = RAY(1) * RAY(3) * RAY(4)
      B6  = RAY(1) * RAY(4)**2
      B7  = RAY(2)**3
      B8  = RAY(2) * RAY(3)**2
      B9  = RAY(2) * RAY(3) * RAY(4)
      B10 = RAY(2) * RAY(4)**2
      B11 = RAY(3)**3
      B12 = RAY(3)**2 * RAY(4)
      B13 = RAY(3) * RAY(4)**2
      B14 = RAY(3) * RAY(1)**2
      B15 = RAY(3) * RAY(1) * RAY(2)
      B16 = RAY(3) * RAY(2)**2
      B17 = RAY(4)**3
      B18 = RAY(4) * RAY(1)**2
      B19 = RAY(4) * RAY(1) * RAY(2)
      B20 = RAY(4) * RAY(2)**2
      SUM1= X(1) *B1  + X(2) *B2  + X(3) *B3  + X(4) *B4  + X(5) *B5
     X    + X(6) *B6  + X(7) *B7  + X(8) *B8  + X(9) *B9  + X(10)*B10
      SUM2= X(11)*B1  + X(12)*B2  + X(13)*B3  + X(14)*B4  + X(15)*B5
     X    + X(16)*B6  + X(17)*B7  + X(18)*B8  + X(19)*B9  + X(20)*B10
      SUM3= Y(1) *B11 + Y(2) *B12 + Y(3) *B13 + Y(4) *B14 + Y(5) *B15
     X    + Y(6) *B16 + Y(7) *B17 + Y(8) *B18 + Y(9) *B19 + Y(10)*B20
      SUM4= Y(11)*B11 + Y(12)*B12 + Y(13)*B13 + Y(14)*B14 + Y(15)*B15
     X    + Y(16)*B16 + Y(17)*B17 + Y(18)*B18 + Y(19)*B19 + Y(20)*B20
      RAY2(1) = RAY2(1) + SUM1
      RAY2(2) = RAY2(2) + SUM2
      RAY2(3) = RAY2(3) + SUM3
      RAY2(4) = RAY2(4) + SUM4
C
      IF (IUNIT3RD .NE. 0 .AND. NCT .LT. NUMLIM) THEN
       WRITE(IUNIT3RD,1236) X(1) * B1 / UNIT(1), X(11) * B1 / UNIT(2),
     X                      Y(1) * B11/ UNIT(3), Y(11) * B11/ UNIT(4)
 1236  FORMAT(     'U1111=',F8.3,'   , U2111=',F8.3,
     X        '   , U3333=',F8.3,'   , U4333=',F8.3)
       WRITE(IUNIT3RD,1237) X(2) * B2 / UNIT(1), X(12) * B2 / UNIT(2),
     X                      Y(2) * B12/ UNIT(3), Y(12) * B12/ UNIT(4)
 1237  FORMAT(     'U1112=',F8.3,'   , U2112=',F8.3,
     X        '   , U3334=',F8.3,'   , U4334=',F8.3)
       WRITE(IUNIT3RD,1238) X(3) * B3 / UNIT(1), X(13) * B3 / UNIT(2),
     X                      Y(3) * B13/ UNIT(3), Y(13) * B13/ UNIT(4)
 1238  FORMAT(     'U1122=',F8.3,'   , U2122=',F8.3,
     X        '   , U3344=',F8.3,'   , U4344=',F8.3)
       WRITE(IUNIT3RD,1239) X(4) * B4 / UNIT(1), X(14) * B4 / UNIT(2),
     X                      Y(4) * B14/ UNIT(3), Y(14) * B14/ UNIT(4)
 1239  FORMAT(     'U1133=',F8.3,'   , U2133=',F8.3,
     X        '   , U3113=',F8.3,'   , U4113=',F8.3)
       WRITE(IUNIT3RD,1240) X(5) * B5 / UNIT(1), X(15) * B5 / UNIT(2),
     X                      Y(5) * B15/ UNIT(3), Y(15) * B15/ UNIT(4)
 1240  FORMAT(     'U1134=',F8.3,'   , U2134=',F8.3,
     X        '   , U3123=',F8.3,'   , U4123=',F8.3)
       WRITE(IUNIT3RD,1241) X(6) * B6 / UNIT(1), X(16) * B6 / UNIT(2),
     X                      Y(6) * B16/ UNIT(3), Y(16) * B16/ UNIT(4)
 1241  FORMAT(     'U1144=',F8.3,'   , U2144=',F8.3,
     X        '   , U3223=',F8.3,'   , U4223=',F8.3)
       WRITE(IUNIT3RD,1242) X(7) * B7 / UNIT(1), X(17) * B7 / UNIT(2),
     X                      Y(7) * B17/ UNIT(3), Y(17) * B17/ UNIT(4)
 1242  FORMAT(     'U1222=',F8.3,'   , U2222=',F8.3,
     X        '   , U3444=',F8.3,'   , U4444=',F8.3)
       WRITE(IUNIT3RD,1243) X(8) * B8 / UNIT(1), X(18) * B8 / UNIT(2),
     X                      Y(8) * B18/ UNIT(3), Y(18) * B18/ UNIT(4)
 1243  FORMAT(     'U1233=',F8.3,'   , U2233=',F8.3,
     X        '   , U3114=',F8.3,'   , U4114=',F8.3)
       WRITE(IUNIT3RD,1244) X(9) * B9 / UNIT(1), X(19) * B9 / UNIT(2),
     X                      Y(9) * B19/ UNIT(3), Y(19) * B19/ UNIT(4)
 1244  FORMAT(     'U1234=',F8.3,'   , U2234=',F8.3,
     X        '   , U3124=',F8.3,'   , U4124=',F8.3)
       WRITE(IUNIT3RD,1245) X(10)* B10/ UNIT(1), X(20) * B10/ UNIT(2),
     X                      Y(10)* B20/ UNIT(3), Y(20) * B20/ UNIT(4)
 1245  FORMAT(     'U1244=',F8.3,'   , U2244=',F8.3,
     X        '   , U3224=',F8.3,'   , U4224=',F8.3)
       WRITE(IUNIT3RD,1235) RAY2(1)/UNIT(1),NAME(1),
     X                      RAY2(2)/UNIT(2),NAME(2), 
     X                      RAY2(3)/UNIT(3),NAME(3),
     X                      RAY2(4)/UNIT(4),NAME(4)
      ENDIF
C
  100 CALL RSETR (RAY, RAY2)
      RETURN
      END

      SUBROUTINE RAYRUN
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC2/  UNIT(12)
      COMMON /BLOC2A/ NAME(12), NOM(12), NOM1(4), DSTOR(20)
      CHARACTER*4     NAME, NOM, NOM1, DSTOR
      COMMON /BLOC3/ NIN, NOUT
      COMMON /BLOC4/ RAYMAX(6), PBEAM, P0, NORAYS
      COMMON /BLOC5/ SEC, CAP(3), MPA, THIRD
      LOGICAL         SEC, CAP, MPA, THIRD
      COMMON /BLOC6/ NHISTS, NHIST, LIMNO
      COMMON /BLOC7/ MTYPE(100), NENTRY(100), NCOOR(100), INTVLS(100),
     A                BEGIN(100), END(100), STEP(100), ZHIST(100)
      COMMON /BLOC7A/ LTAG(100)
      CHARACTER*4     LTAG
      COMMON /BLOC8/ MTABLE(50000)
      REAL           MTABLE
      COMMON /BLOC10/ APB(2), LAYL, LAYX, RAB1, RAB2, FACE
      REAL            LAYL, LAYX
      COMMON /BLOC11/ QAP(3), ELLIPS, HYPER
      LOGICAL         ELLIPS, HYPER
      COMMON /BLOC12/ VALUE(100), XMOM(100), XMOM2(100), NFLAG(100),
     A                SET(100), KFLAG(100), IFLAG(3,0:9), ZFLAG(9),
     A                WZ(100), UFLAG(100), INVFL, ZC
      LOGICAL SET, IFLAG, UFLAG, INVFL
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC14/ MMAX, GTOP, DB(20), COSM(20), SINM(20)
      COMMON /BLOC15/ LL, KH2, KV2, KH, KV, KHL, KVL, RAY2(6),
     A                RH(4), RV(4), LILENS, SOLSEG
      LOGICAL LILENS, SOLSEG
      REAL LL, KH2, KV2, KH, KV, KHL, KVL
      COMMON /BLOC15A/ EQUAD, EBEND, BSCAL, BSCAL2, NSCAL, ISWITCH
      LOGICAL EQUAD, EBEND
      COMMON /BLOC16/ ISTOP(3,9998)
      REAL ISTOP
      COMMON /BLO16A/ KPART(3)
      CHARACTER*4     KPART
      COMMON /BLOC17/ IP, IC(4), IS(4), INEL(4)
      COMMON /BLOC18/ LOSS, NBLK(20), KFLG(20),
     A                XSTRT(20), XEND(20), LTHX(20), XBIN(20), NUNX(20),
     A                YSTRT(20), YEND(20), LTHY(20), YBIN(20), NUNY(20)
      COMMON /BLOC19/ CONE, ISTOR(100), SLIT1(100), SLIT2(100), NSLIT,
     A                ORIG, ISLT, IFF, IFG, A, B, RECTA
      LOGICAL CONE, ORIG, RECTA
      COMMON /BLOC20/ BALLS, BDIAM, WTHIK
      LOGICAL         BALLS
      COMMON /BLOC21/ PIPES, DIST, PTHIK, PRAD, PPER, TTHIK
      LOGICAL         PIPES
      COMMON /BLOC22/ ODIMX, ODIMY, OUTREC, OUTDIM
      LOGICAL OUTREC, OUTDIM
      COMMON /BLOC44/ LINV, SINV, SINV2, MULTSC
      LOGICAL LINV, SINV, SINV2, MULTSC
      COMMON /BLOC46/ SM, GAMMA0, BETA0, CHARGE
      COMMON /BLOC48/ XI1, XI2, XI3, XI4
      COMMON /BLOC50/ NOSUP
      COMMON /BLO50A/ LABSUP(20)
      CHARACTER*4     LABSUP
      COMMON /BLOC52/ W, POLX(0:2), POLY(0:2), POLZ(0:2), POLCAL
      LOGICAL POLCAL
      COMMON /BLOC53/ ENERGY
      LOGICAL ENERGY
      COMMON /BLOC55/ DEDX(3), VEKIN(3,5), VDEDX(3,5)
      LOGICAL DEDX
      COMMON /BLOC60/ NCT
      COMMON /BLOC61/ DBQ, DBQQ, OLDG, DPP0, P0SV
      COMMON /BLOC62/ IUNIT3RD, NUMLIM, ZZ
C
      LOGICAL ELLS, HYPS, BSTOP, QSTOP, SESTOP, SOSTOP, OSTOP
      LOGICAL SOSTOP2
      LOGICAL LOSTS, RECTAS, LINVS, SINVS, SINV2S, MULTS
      LOGICAL STOPED, LOST
      INTEGER ICS(4), ISS(4)
      REAL LS
      REAL E(13)
      CHARACTER*12 DONE
      DATA DONE /'done 100%   '/
      LOGICAL FIRST
      DATA FIRST /.TRUE./
C
      NCT = 0
      IER = 0
      DEDX(1) = .FALSE.
      DEDX(2) = .FALSE.
      DEDX(3) = .FALSE.
      DBQ = 0.0
      DPP0 = 0.0
      BSCAL  = 1.0
      BSCAL2 = 1.0
      DONE(12:12) = CHAR(0)
C
C     SELECT RAY AT RANDOM
C
  100 NCT = NCT + 1
C
      IF (MOD(NCT,100) .EQ. 1) THEN
       IF (NORAYS .LE. 0) GO TO 699
       IPERC = 100. * FLOAT(NCT-1) / FLOAT(NORAYS)
       WRITE(DONE(6:8),777) IPERC
  777  FORMAT(I3)
       CALL GTEXT(2,2,DONE)
       IF (IPERC .GE. 100) GO TO 699
       OPEN(UNIT=67,FILE='STOPTURT',STATUS='OLD',ERR=778)
       CLOSE(UNIT=67)
       NORAYS = NCT - 1
       GO TO 699
  778  CONTINUE
      ENDIF
C
      P0 = PBEAM
      IF (MASS .NE. 0.) SM = MASS
      IF (SM .NE. 0.) THEN
       BG0 =  P0 / SM
       GAMMA0 = SQRT( 1. + BG0 ** 2 )
       BETA0 = BG0 / GAMMA0
      ENDIF
      CALL EMIT(IER)
      IF(IER.NE.0) RETURN
      Z = 0.0
      ZZ = 0.0
      LFLAG = 0
      IF(DKFLAG) CALL DECAYZ (ZD)
      TIME = 0
      IAP = 0
      ISLT = 0
      NEL=1
      NHIST = 0
      IP = 0
      LOST = .FALSE.
      ELLIPS = .FALSE.
      HYPER = .FALSE.
      RECTA = .FALSE.
      LINV = .FALSE.
      SINV = .FALSE.
      SINV2 = .FALSE.
      MULTSC = .FALSE.
      LILENS = .FALSE.
      EQUAD  = .FALSE.
      EBEND  = .FALSE.
      SOLSEG = .FALSE.
      BALLS = .FALSE.
      PIPES = .FALSE.
      OUTREC = .FALSE.
      IF (CONE .AND. .NOT.ORIG) CALL RESLIT
      APB(1) = 0.0
      APB(2) = 0.0
      MMAX = 0
      INEXT = - 10
      IF(.NOT. MPA) GO TO 130
      DO 120 IM = 1, 20
  120 DB(IM) = 0.0
  130 I = 1
      DO 140 KFL = 1, 3
      DO 140 IFL = 1, 9
  140 IFLAG(KFL,IFL) = .FALSE.
      DO 150 NH = 1, NHISTS
  150 SET(NH) = .FALSE.
C
C     TRACK THROUGH ONE ELEMENT
C
  200 NTYPE = IDATA(I)
      IF(NTYPE .EQ. 53) GO TO 530
      IF(NTYPE .GE. 50) GO TO 500
      GO TO (210, 220, 230, 240, 250, 260, 270, 600, 290, 600, 310,
     A       600, 330, 340, 600, 360, 370, 380, 390, 400, 410, 600,
     A       600, 600, 600, 430, 420, 450, 550, 540), NTYPE
C
C     RMS ADDITION TO BEAM OR MULTIPLE SCATTERING
C
  210 IF (IDATA(I+8) .NE. LFLAG) GO TO 600
  211 IF (.NOT. MULTSC) CALL RMSADD
      STOPED = .FALSE.
      IF (MULTSC) THEN
        IF (IAP .GT. 9998) THEN
         WRITE(NOUT,7777) NTYPE, NEL
 7777    FORMAT(//
     X ' MUSCAT: More than 9998 slits. TYPE=',I2,', NEL=',I4//)
         CALL MENU(1)
        END IF
       CALL MULT(LFLAG,IAP,STOPED)
      ENDIF
      IF(STOPED) THEN
       IAPP = MAX(IAP,1)
       ISTOP(LFLAG+1,IAPP) = ISTOP(LFLAG+1,IAPP) + W
       IF(LOSS .NE. 0) CALL HISTLO(LFLAG,W)
       LOST = .TRUE.
        IF (DKFLAG .AND. LFLAG.EQ.0) THEN
         GO TO 700
        ELSE
         GO TO 610
        ENDIF
      ELSE
       I = I + 9
       NEL = NEL + 1
       IF (I .LE. I1) GO TO 200
       GO TO 610
      ENDIF
C
C     FRINGE FIELD FOR BENDS
C
  220 IF (LFLAG .EQ. 2) GO TO 600
      IF (DATA(I+2) .EQ. 1000.) GO TO 226
      IF (DPP0 .NE. 0.0 .AND. DATA(I+10) .EQ. 1.0) THEN ! ENTRANCE FRINGE FIELD
       P0SV = P0
       CALL RANDOM(RND)
       IF (DPP0 .GT. 0.0)
     X  P0 = P0 * (1.0 + DPP0 * COS(3.14159 * RND))
       IF (DPP0 .LT. 0.0)
     X  P0 = P0 * (1.0 + DPP0 * (2.0 * RND - 1.0))
      ENDIF
      H = DATA(I+1) / P
      TANB = DATA(I+2)
      TANCOR = TANB - H * DATA(I+5)
      RAY2(1) = RAY(1)
      RAY2(2) = RAY(2) + H * RAY(1) * TANB
      RAY2(3) = RAY(3)
      RAY2(4) = RAY(4) - H * RAY(3) * TANCOR
      IF(.NOT. SEC) GO TO 225
      SECB = DATA(I+3)
      SEX = DATA(I+4)
      RAY2(1) = RAY(1) + 0.5 * H * ((SECB*RAY(3))**2 - (TANB*RAY(1))**2)
      RAY2(2) = RAY2(2) + H * (TANB**2 * (RAY(1)*RAY(2) - RAY(3)*RAY(4))
     B     + (H * DATA(I+6) + SEX) * RAY(1) ** 2
     C     + (H * DATA(I+7) - SEX) * RAY(3) ** 2)
      RAY2(3) = RAY(3) + H * TANB * TANCOR * RAY(1) * RAY(3)
      RAY2(4) = RAY2(4) - H * (TANCOR * TANB * RAY(1) * RAY(4)
     B    + (H * DATA(I+8) + 2.0 * SEX) * RAY(1) * RAY(3)
     C    + SECB ** 2 * RAY(2) * RAY(3))
      ES  = DATA(I+10)
      IF (THIRD .AND. ES.NE.1000.) THEN
       H     = H * ES
       TANB  = TANB * ES
       RAB   = DATA(I+9)
       CALL FOCBND(TANB,SECB,RAB,H,ES,E)
       XXX   = RAY(1)**3
       XYY   = RAY(1) * RAY(3)**2
       XXXP  = RAY(1)**2 * RAY(2)
       XYYP  = RAY(1) * RAY(3) * RAY(4)
       XPYY  = RAY(2) * RAY(3)**2
       XXPXP = RAY(1) * RAY(2)**2
       XYPYP = RAY(1) * RAY(4)**2
       XPYYP = RAY(2) * RAY(3) * RAY(4)
       SUM1  = E(1)*XXX + E(2)*XXXP + E(3)*XYY + E(4)*XYYP + E(5)*XPYY
       SUM2  = E(6)*XXX + E(7)*XXXP + E(8)*XXPXP + E(9)*XYY
     X       + E(10)*XYYP + E(11)*XYPYP + E(12)*XPYY + E(13)*XPYYP
       RAY2(1) = RAY2(1) + SUM1
       RAY2(2) = RAY2(2) + SUM2
      ENDIF
  225 CALL RSETR (RAY, RAY2)
      IF (DPP0 .NE. 0.0 .AND. DATA(I+10) .EQ. -1.0) THEN  ! EXIT FRINGE FIELD
       P0 = P0SV
      ENDIF
      GO TO 600
C
C     FRINGE FIELD FOR QUADS
C
  226 CONTINUE
      IF (EQUAD) THEN
       BG = P / SM
       GAMMA = SQRT( 1. + BG ** 2 )
       ENE = P**2 / ((1. + GAMMA) * SM)
       RIE = ENE * (1. + GAMMA) / GAMMA
       C = DATA(I+4) / RIE
      ELSE
       C = DATA(I+4) / P
      ENDIF
      R11 = 1. - C
      R22 = 1. + C
      IF (EQUAD) THEN
       R12 = DATA(I+5) / RIE
       R21 = DATA(I+6) / RIE**2
      ELSE
       R12 = DATA(I+5) / P
       R21 = DATA(I+6) / P**2
      ENDIF
      RAY2(1) = R11 * RAY(1) + R12 * RAY(2)
      RAY2(2) = R21 * RAY(1) + R22 * RAY(2)
      RAY2(3) = R22 * RAY(3) - R12 * RAY(4)
      RAY2(4) = R21 * RAY(3) + R11 * RAY(4)
      IF (THIRD) THEN
       IF (IUNIT3RD .NE. 0 .AND. NCT .LT. NUMLIM) THEN
        WRITE(IUNIT3RD,*) ' '
        WRITE(IUNIT3RD,1234) LABEL(NEL), NCT, ZZ
 1234   FORMAT('*QUAD FRINGE* ',A4,' with ray ',I2,' at z=',F8.3,' m')
        WRITE(IUNIT3RD,1235) RAY2(1)/UNIT(1),NAME(1),
     X                       RAY2(2)/UNIT(2),NAME(2), 
     X                       RAY2(3)/UNIT(3),NAME(3),
     X                       RAY2(4)/UNIT(4),NAME(4) 
 1235  FORMAT(   'x    =',F8.3,1X,A2,
     X         ', x''   =',F8.3,1X,A2,
     X         ', y    =',F8.3,1X,A2,
     X         ', y''   =',F8.3,1X,A2)
       ENDIF
       IF (EQUAD) THEN
        T1    = DATA(I+7) / P**2
        T2    = DATA(I+8) / P
        U1111 = 2./3. * T2
        U1133 = 0.
        U2111 = 7./2. * T1
        U2133 =-3./2. * T1
        U2112 = 0.
        U2134 = 0.
        U2233 = -2. * T2
        U3333 = -2./3. * T2
        U3311 = 0.
        U4333 = 7./2. * T1
        U4311 =-3./2. * T1 
        U4334 = 0.
        U4312 = 0.
        U4411 = 2. * T2
       ELSE
        T1    = DATA(I+7) / P**2
        T2    = DATA(I+8) / P
        U1111 = T2 / 3.
        U1133 = T2
        U2111 = T1
        U2133 = 3. * T1
        U2112 = -T2 
        U2134 = 2. * T2
        U2233 = -T2
        U3333 = -T2 / 3.
        U3311 = -T2
        U4333 = T1
        U4311 = 3. * T1
        U4334 = T2 
        U4312 = -2. * T2
        U4411 = T2
       ENDIF
C
       XXX   = RAY(1)**3
       XYY   = RAY(1) * RAY(3)**2
       XXXP  = RAY(1)**2 * RAY(2)
       XYYP  = RAY(1) * RAY(3) * RAY(4)
       XPYY  = RAY(2) * RAY(3)**2
C
       YYY   = RAY(3)**3
       YXX   = RAY(3) * RAY(1)**2
       YYYP  = RAY(3)**2 * RAY(4)
       XYXP  = RAY(1) * RAY(3) * RAY(2)
       YPXX  = RAY(4) * RAY(1)**2
C
       SUM1  = U1133 * XYY + U1111 * XXX
       SUM2  = U2111 * XXX  + U2133 * XYY  + U2112 * XXXP
     X       + U2233 * XPYY + U2134 * XYYP
       SUM3  = U3311 * YXX + U3333 * YYY
       SUM4  = U4333 * YYY  + U4311 * YXX  + U4334 * YYYP
     X       + U4411 * YPXX + U4312 * XYXP
C
       RAY2(1) = RAY2(1) + SUM1
       RAY2(2) = RAY2(2) + SUM2
       RAY2(3) = RAY2(3) + SUM3
       RAY2(4) = RAY2(4) + SUM4
C
       IF (IUNIT3RD .NE. 0 .AND. NCT .LT. NUMLIM) THEN
       WRITE(IUNIT3RD,1236) XXX * U1111 /UNIT(1), XXX * U2111 /UNIT(2),
     X                      YYY * U3333 /UNIT(3), YYY * U4333 /UNIT(4)
 1236  FORMAT(     'U1111=',F8.3,'   , U2111=',F8.3,
     X        '   , U3333=',F8.3,'   , U4333=',F8.3)
       WRITE(IUNIT3RD,1237) XYY * U1133 /UNIT(1), XYY * U2133 /UNIT(2),
     X                      YXX * U3311 /UNIT(3), YXX * U4311 /UNIT(4)
 1237  FORMAT(     'U1133=',F8.3,'   , U2133=',F8.3,
     X        '   , U3311=',F8.3,'   , U4311=',F8.3)
       WRITE(IUNIT3RD,1238) XXXP * U2112 /UNIT(2),
     X                      YYYP * U4334 /UNIT(4)
 1238  FORMAT(     14X,'   , U2112=',F8.3,
     X             19X,'   , U4334=',F8.3)
       WRITE(IUNIT3RD,1239) XYYP * U2134 /UNIT(2),
     X                      XYXP * U4312 /UNIT(4)
 1239  FORMAT(     14X,'   , U2134=',F8.3,
     X             19X,'   , U4312=',F8.3)
       WRITE(IUNIT3RD,1240) XPYY * U2233 /UNIT(2),
     X                      YPXX * U4411 /UNIT(4)
 1240  FORMAT(     14X,'   , U2233=',F8.3,
     X             19X,'   , U4411=',F8.3)
        WRITE(IUNIT3RD,1235) RAY2(1)/UNIT(1),NAME(1),
     X                       RAY2(2)/UNIT(2),NAME(2), 
     X                       RAY2(3)/UNIT(3),NAME(3),
     X                       RAY2(4)/UNIT(4),NAME(4)
       ENDIF
      ENDIF
      CALL RSETR (RAY, RAY2)
      I = I + 11
      NEL = NEL + 1
      IF (I .LE. I1) GO TO 200
      GO TO 610
C
C     DRIFT SPACE
C
  230 LL = DATA(I+1)
      IF(.NOT. DKFLAG) GO TO 235
      TIME = TIME + LL * SM / (.3 * P)
      IF(LFLAG .NE. 0 .OR. TIME .LT. ZD) GO TO 235
      LL = LL - .3 * P * (TIME - ZD) / SM
      RAY(1) = RAY(1) + LL * RAY(2)
      RAY(3) = RAY(3) + LL * RAY(4)
      GO TO 700
  235 RAY(1) = RAY(1) + LL * RAY(2)
      RAY(3) = RAY(3) + LL * RAY(4)
      Z = Z + LL
      ZZ = Z
      I = I + 2
      NEL = NEL + 1
      IF (I .LE. I1) GO TO 200
      GO TO 610
C
C     BENDING MAGNET OR ELECTROSTATIC PRISM
C
  240 IAP = IAP + 1
      IF(BSTOP(LFLAG)) GO TO 650
      LL = DATA(I+1)
      IF(.NOT. DKFLAG) GO TO 244
      IF(LFLAG - 1) 241, 244, 246
  241 TIME = TIME + LL * SM / (.3 * P)
      IF(TIME .LT. ZD) GO TO 244
      LL = LL - .3 * P * (TIME - ZD) / SM
      IF (EBEND) THEN
       CALL EPRISM (KSTOP)
      ELSE
       IF (DATA(I+2) .EQ. 0.0) THEN
        CALL BEND2(KSTOP)
       ELSE
        CALL BEND (KSTOP)
       ENDIF
      ENDIF
      IF(KSTOP) 650, 700, 650
  243 IF (ABS(RAY(2)).GT.0.5 .OR. ABS(RAY(4)).GT.0.5) GO TO 650
  244 CONTINUE
      IF (EBEND) THEN
       CALL EPRISM (KSTOP)
      ELSE
       IF (DATA(I+2) .EQ. 0.0) THEN
        CALL BEND2(KSTOP)
       ELSE
        CALL BEND (KSTOP)
       ENDIF
      ENDIF
      IF(KSTOP) 650, 249, 650
  245 IF (ABS(RAY(2)).GT.0.5 .OR. ABS(RAY(4)).GT.0.5) GO TO 650
  246 IF (.NOT. EBEND) THEN
       IF(DATA(I+4) .EQ. 0.0) GO TO 247
       THETA = LL * DATA(I+2)
       TANTH = TAN(THETA)
       THE2 = (RAY(2) + TANTH) / (1.0 - RAY(2) * TANTH)
       F = SQRT ((1.0 + THE2 ** 2) / (1.0 + RAY(2) ** 2))
       RAY(1) = F * (RAY(1) + DATA(I+4)) - DATA(I+4)
       RAY(2) = THE2
       RAY(3) = RAY(3) + (DATA(I+4) + RAY(1)) * SIN(THETA) * RAY(4)
       RAY(4) = F * RAY(4)
       GO TO 249
  247  RAY(1) = RAY(1) + LL * RAY(2)
       RAY(3) = RAY(3) + LL * RAY(4)
      ENDIF
  249 IF(BSTOP(LFLAG)) GO TO 650
      GO TO 590
C
C     QUADRUPOLE
C
  250 IAP = IAP + 1
      IF (QSTOP(LFLAG)) GO TO 650
      LL = DATA(I+1)
      ZZ = Z + LL
      IF (LFLAG .EQ. 2) GO TO 255
      IF (MMAX .NE. 0) THEN
      GTOP = 0.5 * DATA(I+1) * DATA(I+2) / P
      CALL MULTI
      END IF
      IF (.NOT.DKFLAG) GO TO 254
      TIME = TIME + LL * SM / (.3 * P)
      IF(LFLAG .NE. 0 .OR. TIME .LT. ZD) GO TO 254
      LL = LL - .3 * P * (TIME - ZD) / SM
      CALL QUAD
      GO TO 700
  253 IF (ABS(RAY(2)).GT.0.5 .OR. ABS(RAY(4)).GT.0.5) GO TO 650
  254 CALL QUAD
      IF (MMAX .NE. 0) CALL MULTI
      GO TO 259
  255 RAY(1) = RAY(1) + LL * RAY(2)
      RAY(3) = RAY(3) + LL * RAY(4)
  259 IF (QSTOP(LFLAG)) GO TO 650
      Z = Z + LL
      ZZ = Z 
      I = I + 4
      NEL = NEL + 1
      IF (I .LE. I1) GO TO 200
      GO TO 610
C
C     SLIT
C
  260 IAP = IAP + 1
      ISLT = I
      IF (BALLS) CALL BKOLL(IAP,LFLAG,*200,*650)
      IF (PIPES) CALL PKOLL(IAP,LFLAG,*200,*650)
      IF (OUTREC) CALL OKOLL(IAP,LFLAG,*200)
      IFP = IDATA(I+1) / 100
      IFF = IDATA(I+1) - 100 * IFP
      IF(IFP .NE. LFLAG) GO TO 267
      IF (IFF .LE. 6) THEN
       XR = RAY(IFF)
      ELSE
       XR = HSTVAL(IFF,LFLAG)
      ENDIF
      A = DATA(I+2)
      IFG = IDATA(I+3)
      IF(IFG .NE. 0) GO TO 265
C
      IF(LINV) GO TO 261
      IF(ABS(XR) .LT. A) GO TO 267
      GO TO 266
  261 IF(ABS(XR) .GT. A) GO TO 267
      GO TO 266
C
  265 IF (IFG .LE. 6) THEN
       YR = RAY(IFG)
      ELSE
       YR = HSTVAL(IFG,LFLAG)
      ENDIF
      B = DATA(I+4)
      IF(LINV) GO TO 262
C
      IF(RECTA) GO TO 264
      IF (IFG.EQ.1 .AND. IFF.EQ.1) THEN
       YR = RAY(3)
       IF((XR/A)**2 + (YR/A)**2 .LT. 1.0) GO TO 267
       IF((XR/B)**2 + (YR/B)**2 .GT. 1.0) GO TO 267
       GO TO 266
      ENDIF
      IF((XR/A)**2 + (YR/B)**2 .LT. 1.0) GO TO 267
      GO TO 266
  264 IF(ABS(XR) .LT. A .AND. ABS(YR) .LT. B) GO TO 267
      GO TO 266
C
  262 IF(RECTA) GO TO 263
      IF (IFG.EQ.1 .AND. IFF.EQ.1) THEN
       YR = RAY(3)
       IF((XR/A)**2 + (YR/A)**2 .LT. 1.0) GO TO 266
       IF((XR/B)**2 + (YR/B)**2 .GT. 1.0) GO TO 266
       GO TO 267
      ENDIF
      IF((XR/A)**2 + (YR/B)**2 .GT. 1.0) GO TO 267
      GO TO 266
  263 IF(ABS(XR) .GT. A .OR. ABS(YR) .GT. B) GO TO 267
C
  266 I = I + 5
      NEL=NEL+1
      NTYPE = IDATA(I)
      IF(NTYPE .EQ. 1 .AND. IDATA(I+8) .EQ. LFLAG) GO TO 211
      NEL=NEL-1
      GO TO 650
C
  267 I = I + 5
      NEL=NEL+1
      IF(I .GT. I1) GO TO 610
      NTYPE = IDATA(I)
      IF(NTYPE .EQ. 1 .AND. IDATA(I+8) .EQ. LFLAG) THEN
       I = I + 9
       NEL = NEL + 1
       IF (I .LE. I1) GO TO 200
       GO TO 610
      ENDIF
      GO TO 200
C
C     SHIFT
C
  270 SAVE1=RAY(1)
      SAVE2=RAY(2)
      SAVE3=RAY(3)
      SAVE4=RAY(4)
      RAY(1) = RAY(1) + DATA(I+1)
      RAY(2) = RAY(2) + DATA(I+2)
      RAY(3) = RAY(3) + DATA(I+3)
      RAY(4) = RAY(4) + DATA(I+4)
      RAY(5) = RAY(5) + DATA(I+5)
      RAY(6) = RAY(6) + DATA(I+6)
      P = P + DATA(I+6) * P0
      IF(.NOT.SINV) GO TO 272
      RAY(2)=SAVE2+SIGN(DATA(I+2),SAVE1)
      RAY(4)=SAVE4+SIGN(DATA(I+4),SAVE3)
      GO TO 600
  272 IF(.NOT.SINV2) GO TO 600
      IF(SAVE1.LT.0.0) RAY(2)=RAY(2)-DATA(I+2)
      IF(SAVE3.LT.0.0) RAY(4)=RAY(4)-DATA(I+4)
      GO TO 600
C
C     REPEAT
C
  290 CALL REPETI
      I = I + 2
      NEL = NEL + 1
      IF (I .LE. I1) GO TO 200
      GO TO 610
C
C     ELECTROSTATIC ACCELERATOR
C
  310 IAP = IAP + 1
      IF (SOSTOP(LFLAG)) GO TO 650
      LL = DATA(I+1)
      IF (FIRST) THEN
        IF (LL .NE. 0.0) THEN
         WRITE(NOUT,3100)
 3100    FORMAT(' TYPE CODE 11: FIRST LENGTH HAS TO BE 0.0,',
     X          ' 2ND ENTRY = DEVICE VOLTAGE.')
         CALL MENU(1)
         RETURN
        ENDIF
        FIRST = .FALSE.
      ENDIF
      POT1 = DATA(I+2)
      IF ( (LL.EQ.0.0) .AND. (POT1.EQ.0.0)) THEN
        POT0 = 0.0
        POT1 = 0.0
        XPOLD = 1.0
        GAMMA0 = SQRT(1. + (P0 / SM) **2)
        E0 = P0**2 / ((1. + GAMMA0) * SM)
        E1 = E0
      ELSE
        E1 = (POT1-POT0) * CHARGE + E0
      ENDIF
C
C     LOOK AT NEXT 2 CARDS (1 INTERVENING 50 OR 52 CARD ALLOWED)
C
      I11 = I + NU(11)
      I1150 = I11 + NU(50)
      IF (IDATA(I11).EQ.11) THEN
       II = I11           ! NEXT CARD IS ACCEL
       POT2 = DATA(II+2)      
       XP = DATA(II+1)
      ELSE IF ((IDATA(I11).EQ.50) .AND. (IDATA(I1150).EQ.11)) THEN
       II = I1150         ! NEXT 2 CARDS ARE HISTO AND THEN ACCEL
       POT2 = DATA(II+2)      
       XP = DATA(II+1)
      ELSE IF ((IDATA(I11).NE.11) .AND. (IDATA(I+2*NU(11)).NE.11)) THEN
       POT2 = POT1        ! NEXT 2 CARDS ARE NOT ACCEL --> END OF ACCEL
       XP = 1.0
       FIRST = .TRUE.
      ELSE
       CONTINUE
      ENDIF
C
C     IF KINETIC ENERGY <= 0, THEN PARTICLE STOPPED
C
      E2 = (POT2-POT1) * CHARGE + E0
      IF (E2 .LE. 0.0) GO TO 650
C
C     FINV IS NOW RELATIVISTIC (1/F=-DELTAEFIELD/2*P*V)
C
      P1V1 = (E1*(2.*SM+E1)) / (SM+E1)
      FINV = -((POT2 - POT1) / XP - (POT1 - POT0) / XPOLD) / (2.*P1V1)
      P0OLD = P0
      P0 = SQRT(E1*(2.*SM+E1))
      BG0 = P0 / SM
      GAMMA0 = SQRT( 1. + BG0 ** 2 )
      BETA0 = BG0 / GAMMA0
      PDP = P0OLD / P0
C
C     PDP2 IS THE INTEGRAL OF 1/MOMENTUM ,LINEARLY RISING KINETIC ENERGY
C
      RATIO = (E1+SM+P0) / (E0+SM+P0OLD)
      IF(ABS(RATIO-1.).LT.0.0001 .OR. POT0.EQ.POT1) THEN
        PDP2 = 1.0
      ELSE
        PDP2 = P0OLD / (E1-E0) * ALOG(RATIO)
      ENDIF
C
      POT0 = POT1
      POT1 = POT2
      E0 = E1
      XPOLD = XP
C
      R11 = 1.0
      R12 = LL * PDP2
      R21 = FINV
      R22 = PDP+FINV*LL*PDP2
C
      R33 = R11
      R34 = R12
      R43 = R21
      R44 = R22
C
      R55 = 1.0
      R56 = R12 / GAMMA0**2
      R65 = 0.0
      R66 = PDP
C
      RAY2(1) = R11 * RAY(1) + R12 * RAY(2)
      RAY2(2) = R21 * RAY(1) + R22 * RAY(2)
C
      RAY2(3) = R33 * RAY(3) + R34 * RAY(4)
      RAY2(4) = R43 * RAY(3) + R44 * RAY(4)
C
      RAY2(5) = R55 * RAY(5) + R56 * RAY(6)
      RAY2(6) = R65 * RAY(5) + R66 * RAY(6)
C
      RAY(1) = RAY2(1)
      RAY(2) = RAY2(2)
      RAY(3) = RAY2(3)
      RAY(4) = RAY2(4)
      RAY(5) = RAY2(5)
      RAY(6) = RAY2(6)
C
      P = P0 * (1.0 + RAY(6))
      GO TO 590
C
C     INPUT OUTPUT OPTIONS
C
  330 KODE = DATA(I+1) + .001
      KFL  = KODE / 100
      INDEX = KODE - 100 * KFL
      IF(INDEX .EQ. 10) CAP(KFL+1) = .TRUE.
      IF(INDEX .EQ. 11) CAP(KFL+1) = .FALSE.
      GO TO 600
C
C     ARBITRARY MATRIX
C
  340 NROW = IDATA(I+7)
      IF(I .NE. INEXT) CALL RSETR2(RAY2, RAY)
      RAY2(NROW) = 0.0
      DO 342 IR = 1, 6
  342 RAY2(NROW) = RAY2(NROW) + RAY(IR) * DATA(I+IR)
      IF(.NOT. SEC .OR. IDATA(I+8) .NE. 0) GO TO 344
      IPL = I + 8
      DO 343 IB = 1, 6
      DO 343 JC = IB, 6
      IPL = IPL + 1
  343 RAY2(NROW) = RAY2(NROW) + RAY(IB) * RAY(JC) * DATA(IPL)
  344 INEXT = I + NU(14)
      IF(IDATA(INEXT) .NE. 14) CALL RSETR2 (RAY, RAY2)
      GO TO 600
C
C     MULTIPOLE ABERRATIONS AND BENDING MAGNET PARAMETERS
C
  360 NM = IDATA(I+1)
      IF(NM .GT. 0) GO TO 362
      IF(LFLAG .EQ. 2) GO TO 600
      NM = - NM
      DB(NM) = DATA(I+2)
      COSM(NM) = DATA(I+3)
      SINM(NM) = DATA(I+4)
      MAXX = MAX0(NM,MMAX)
      MMAX = 0
      DO 361 IM = 1, MAXX
      IF(DB(IM) .NE. 0.0) MMAX = IM
  361 CONTINUE
      GO TO 600
  362 CALL SPSHLR(NM,LFLAG)
      I = I + 5
      NEL = NEL + 1
      IF (I .LE. I1) GO TO 200
      GO TO 610
C
C     FIRST, SECOND OR THIRD ORDER
C
  370 CONTINUE
      NN    = DATA(I+1)
      SEC   = .TRUE.
      THIRD = .FALSE.
      IF (NN .GE. 3) THEN
       THIRD = .TRUE.
      ELSE IF (NN .EQ. 1.) THEN
       SEC   = .FALSE.
       THIRD = .FALSE.
      ENDIF
      GO TO 600
C
C     SEXTUPOLE
C
  380 IAP = IAP + 1
      IF(SESTOP(LFLAG)) GO TO 650
      LL = DATA(I+1)
      IF(LFLAG .EQ. 2) GO TO 385
      IF(.NOT. DKFLAG .OR. LFLAG .NE. 0) GO TO 384
  381 TIME = TIME + LL * SM / (.3 * P)
      IF(TIME .LT. ZD) GO TO 384
      LL = LL - .3 * P * (TIME - ZD) / SM
      CALL SEXT
      GO TO 700
  383 IF (ABS(RAY(2)).GT.0.5 .OR. ABS(RAY(4)).GT.0.5) GO TO 650
  384 CALL SEXT
      GO TO 389
  385 RAY(1) = RAY(1) + LL * RAY(2)
      RAY(3) = RAY(3) + LL * RAY(4)
  389 IF(SESTOP(LFLAG)) GO TO 650
      GO TO 590
C
C     SOLENOID
C
  390 IAP = IAP + 1
      IF (SOSTOP(LFLAG)) GO TO 650
      LL = DATA(I+1)
      IF (LL .EQ. 0.)    GO TO 394
      IF (LFLAG .EQ. 2)  GO TO 395
      IF (.NOT. DKFLAG .OR. LFLAG .NE. 0) GO TO 394
  391 TIME = TIME + LL * SM / (.3 * P)
      IF (TIME .LT. ZD)  GO TO 394
      LL = LL - .3 * P * (TIME - ZD) / SM
      CALL SOLO
      GO TO 700
  393 IF (ABS(RAY(2)).GT.0.5 .OR. ABS(RAY(4)).GT.0.5) GO TO 650
  394 CALL SOLO
      GO TO 399
  395 RAY(1) = RAY(1) + LL * RAY(2)
      RAY(3) = RAY(3) + LL * RAY(4)
  399 IF (SOSTOP(LFLAG)) GO TO 650
      GO TO 590
C
C     BEAM ROTATION
C
  400 CS = DATA(I+1)
      SN = DATA(I+2)
      RAY2(1) = RAY(1) * CS + RAY(3) * SN
      RAY2(3) = - RAY(1) * SN + RAY(3) * CS
      RAY2(2) = RAY(2) * CS + RAY(4) * SN
      RAY2(4) = - RAY(2) * SN + RAY(4) * CS
      CALL RSETR (RAY, RAY2)
      GO TO 600
C
C     WIEN FILTER
C
  410 IAP = IAP + 1
      IF(BSTOP(LFLAG)) GO TO 650
      LL=DATA(I+1)
      IF(LFLAG .EQ. 2) GO TO 415
      IF(.NOT. DKFLAG .OR. LFLAG .NE. 0) GO TO 414
  411 TIME = TIME + LL * SM / (.3 * P)
      IF(TIME .LT. ZD) GO TO 414
      LL = LL - .3 * P * (TIME - ZD) / SM
      CALL WIEN
      GO TO 700
  413 IF (ABS(RAY(2)).GT.0.5 .OR. ABS(RAY(4)).GT.0.5) GO TO 650
  414 CALL WIEN
      GO TO 419
  415 RAY(1) = RAY(1) + LL * RAY(2)
      RAY(3) = RAY(3) + LL * RAY(4)
  419 IF(BSTOP(LFLAG)) GO TO 650
      GO TO 590
C
C     B-E CROSSFIELD
C
  420 IAP = IAP + 1
      IF(BSTOP(LFLAG)) GO TO 650
      LL=DATA(I+1)
      IF(LFLAG .EQ. 2) GO TO 425
      IF(.NOT. DKFLAG .OR. LFLAG .NE. 0) GO TO 424
  421 TIME = TIME + LL * SM / (.3 * P)
      IF(TIME .LT. ZD) GO TO 424
      LL = LL - .3 * P * (TIME - ZD) / SM
      CALL EFIELD
      GO TO 700
  423 IF (ABS(RAY(2)).GT.0.5 .OR. ABS(RAY(4)).GT.0.5) GO TO 650
  424 CALL EFIELD
      GO TO 429
  425 RAY(1) = RAY(1) + LL * RAY(2)
      RAY(3) = RAY(3) + LL * RAY(4)
  429 IF(BSTOP(LFLAG)) GO TO 650
      GO TO 590
C
C     SOLENOID (RUNGE-KUTTA)
C
  450 IAP = IAP + 1
      IF (DATA(I+1) .LT. 0.) GO TO 600
      IF (SOSTOP2(LFLAG)) GO TO 650
      LL = DATA(I+1)
      IF (LL .EQ. 0.)    GO TO 454
      IF (LFLAG .EQ. 2)  GO TO 455
      IF (.NOT. DKFLAG .OR. LFLAG .NE. 0) GO TO 454
  451 TIME = TIME + LL * SM / (.3 * P)
      IF (TIME .LT. ZD)  GO TO 454
      LL = LL - .3 * P * (TIME - ZD) / SM
      CALL SOLORUKA
      GO TO 700
  453 IF (ABS(RAY(2)).GT.0.5 .OR. ABS(RAY(4)).GT.0.5) GO TO 650
  454 CALL SOLORUKA
      GO TO 459
  455 RAY(1) = RAY(1) + LL * RAY(2)
      RAY(3) = RAY(3) + LL * RAY(4)
  459 IF (SOSTOP2(LFLAG)) GO TO 650
      GO TO 590
C
C     OCTUPOLE
C
  430 IAP = IAP + 1
      IF (OSTOP(LFLAG)) GO TO 650
      LL = DATA(I+1)
      IF (LFLAG .EQ. 2) GO TO 435
      IF (.NOT.DKFLAG) GO TO 434
      TIME = TIME + LL * SM / (.3 * P)
      IF(LFLAG .NE. 0 .OR. TIME .LT. ZD) GO TO 434
      LL = LL - .3 * P * (TIME - ZD) / SM
      CALL OCTO
      GO TO 700
  433 IF (ABS(RAY(2)).GT.0.5 .OR. ABS(RAY(4)).GT.0.5) GO TO 650
  434 CALL OCTO
      GO TO 439
  435 RAY(1) = RAY(1) + LL * RAY(2)
      RAY(3) = RAY(3) + LL * RAY(4)
  439 IF (OSTOP(LFLAG)) GO TO 650
      Z = Z + LL
      ZZ = Z
      I = I + NU(NTYPE)
      NEL = NEL + 1
      IF (I .LE. I1) GO TO 200
      GO TO 610
C
C     SAVE VALUES FOR HISTOGRAM
C
  500 NHIST = NHIST + 1
      IF(LFLAG .NE. KFLAG(NHIST)) GO TO 600
      NCO = NCOOR(NHIST)
      VALUE(NHIST) = HSTVAL(NCO,LFLAG)
      WZ(NHIST) = W
      SET(NHIST) = .TRUE.
      GO TO 600
C
C     SET HISTOGRAM FLAG
C
  530 IFL = IDATA(I+1)
      IFLAG(LFLAG+1,IFL) = .TRUE.
      GO TO 600
C
C     DE/DX - DATA INPUT
C
  540 CALL DEDXD2
      GO TO 600
C
C     JUMP OVER COLLIMATOR ELEMNETS
C
  550 CALL JUMP(IAP)
      GO TO 200
C
C     NEXT ELEMENT
C
  590 Z = Z + DATA(I+1)
      ZZ = Z
  600 I = I + NU(NTYPE)
      NEL=NEL+1
      IF(I .LE. I1) GO TO 200
C
C     END OF SYSTEM REACHED. IF WANTED SWITCH TO NEUTRAL DAUGHTER
C
  610 IF(LFLAG .NE. 1 .OR. .NOT. DKFLAG) GO TO 690
      DO 620 J = 1, 6
  620 RAY(J) = RAYN(J)
      NHIST = NHS
      I = ISAVE
      NTYPE = IDATA(I)
      IP = IPS
      DO 625 J = 1, 4
      IC(J) = ICS(J)
  625 IS(J) = ISS(J)
      Z = ZS
      LL = LS
      P = PN
      SM = MASSN
      P0 = P0S
      LFLAG = 2
      W = WS
      IAP = IAPS
      ELLIPS = ELLS
      HYPER = HYPS
      LOST = LOSTS
      RECTA = RECTAS
      LINV = LINVS
      SINV = SINVS
      SINV2 = SINV2S
      MULTSC = MULTS
      NEL = NELS
      APB(1) = APBS1
      APB(2) = APBS2
      IF (P .LE. 0.0) GO TO 650
      IF (ABS(RAY(2)).GT.1.57 .OR. ABS(RAY(4)).GT.1.57) GO TO 650
      GO TO (600, 600, 235, 245, 255, 600, 600, 600, 600, 600, 600,
     A       600, 600, 600, 600, 600, 600, 385, 395, 600, 415, 600,
     B       600, 600, 600, 435, 425, 455, 600, 600), NTYPE
C
C     PARTICLE STOPPED BY APERTURE
C
  650 IF (IAP .LE. 9998) GO TO 651
      WRITE(NOUT,7779) NTYPE, NEL
 7779 FORMAT(//
     X' APERTURE: More than 9998 slits. TYPE=',I2,', NEL=',I4//)
      CALL MENU(1)
  651 IAPP = MAX(IAP,1)
      ISTOP(LFLAG+1,IAPP) = ISTOP(LFLAG+1,IAPP) + W
      IF(LOSS .NE. 0) CALL HISTLO(LFLAG,W)
      LOST = .TRUE.
      GO TO 610
C
C     ENTER RAY INTO HISTOGRAMS, CHECK REMAINIG CPU TIME
C
  690 CALL EHIST(LOST)
C
      IF (NCT .LE. NORAYS) GO TO 100
  699 RETURN
C
C     DECAY
C
  700 CALL DECAY
      DO 710 J = 1, 6
  710 RAY(J) = RAYC(J)
      NHS = NHIST
      ISAVE = I
      IPS = IP
      DO 715 J = 1, 4
      ICS(J) = IC(J)
  715 ISS(J) = IS(J)
      ZS = Z
      LL = DATA(I+1) - LL
      LS = LL
      P = PC
      SM = MASSC
      P0S = P0
      LFLAG = 1
      WS = W
      IAPS = IAP
      ELLS = ELLIPS
      HYPS = HYPER
      LOSTS = LOST
      RECTAS = RECTA
      LINVS = LINV
      SINVS = SINV
      SINV2S = SINV2
      MULTS = MULTSC
      NELS = NEL
      APBS1 = APB(1)
      APBS2 = APB(2)
      IF (P .LE. 0.0) GO TO 650
      IF (ABS(RAY(2)).GT.1.57 .OR. ABS(RAY(4)).GT.1.57) GO TO 650
      GO TO (600, 600, 235, 243, 253, 600, 600, 600, 600, 600, 600,
     A       600, 600, 600, 600, 600, 600, 383, 393, 600, 413, 600,
     B       600, 600, 600, 433, 423, 453, 600, 600), NTYPE
      return     ! if missing: runtime error with F77L3-EM/32 V4.0

      END
      SUBROUTINE RDELEM
C     READ IN DATA FOR ONE ELEMENT
      COMMON /BLOC3/ NIN, NOUT
      COMMON /BLOC41/ LW, FLUSH, INDIC, NTYPE, LENGTH,
     A                NWORD, NVARY, DATUM(30), VARY(30)
      INTEGER VARY
      LOGICAL FLUSH
      COMMON /BLO41A/ IMAGE(80), LABLE
      CHARACTER       IMAGE*1, LABLE*4
      COMMON /BLOC2/  UNIT(12)
      COMMON /BLOC2A/ NAME(12), NOM(12), NOM1(4), DSTOR(20)
      CHARACTER*4     NAME, NOM, NOM1, DSTOR
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
      COMMON /BLOC43/ NCD, MC, EMPTY
      LOGICAL EMPTY
      COMMON /BLO43A/ CARD(120), ITEM
      CHARACTER*1     CARD, ITEM
C
      INTEGER     NO1(21)
      CHARACTER*4 UTABLE(14)
      REAL        CTABLE(14)
      LOGICAL     SNTNL, SEPAR
      CHARACTER*1 IARROW, IWORD(4)
      DATA SNTNL  / .FALSE. /
      DATA NO1    / 8,2,2,4,4,3,7,8,2,5,3,16,2,8,4,3,2,4,3,2,4 /
      DATA UTABLE / 'CM  ', 'M   ', 'IN  ', 'FT  ', 'MM  ', 'R   ',
     A              'MR  ', 'PC  ', 'P/10', 'N   ', 'MEV ', 'GEV ',
     B              'KG  ', 'G   ' /
      DATA CTABLE / 1.0, 100.0, 2.54, 30.48, 0.1, 1000.0, 1.0, 1.0,
     A              0.1, 100.0, 0.001, 1.0, 1.0, 0.001 /
      DATA IARROW / '^' /
      DATA NUC /0/
C
C     SET DEFAULT VALUES
C
   10 DO 20 J = 1, 30
      DATUM(J) = 0.0
   20 VARY (J) = 0
      NWORD = 0
      NVARY = 1
      LABLE = BLANK//BLANK//BLANK//BLANK
C
C     HAS SENTINEL BEEN READ AT PREVIOUS CALL
C
      IF(.NOT. SNTNL) GO TO 30
      SNTNL = .FALSE.
      RETURN
   30 SEPAR = .TRUE.
      CALL RDSKIP
      GO TO 110
C
C     SEPARATORS
C
  100 SEPAR = ITEM .EQ. BLANK
      CALL RDNEXT (- 1)
  110 DO 115 J = 1, 5
      IF(ITEM .EQ. SEMI(J)) GO TO 500
  115 CONTINUE
      DO 120 J = 1, 6
      IF(ITEM .EQ. QUOTE(J)) GO TO 350
  120 CONTINUE
      IF(ITEM .EQ. TABLE(29)) GO TO 450
      IF(SEPAR) GO TO 150
  130 WRITE (NOUT, 9130) CARD, (BLANK, J = 1, MC), IARROW
      CALL MENU(1)
  150 IF(NWORD) 300, 200, 300
C
C     TYPE CODE
C
  200 CALL RDFIX (NTYPE, IFLAG)
      IF(IFLAG .NE. 0) GO TO 130
      NWORD = 1
      DATUM(1) = NTYPE
      NTYPE = IABS(NTYPE)
      IF(ITEM .NE. PERIOD) GO TO 100
C
C     VARY CODES
C
  210 CALL RDNEXT (0)
      IFLAG = 0
      IF(ITEM .EQ. MINUS) GO TO 220
      ISIG = 1
      IF(ITEM .EQ. PLUS(1) .OR. ITEM .EQ. PLUS(2)) GO TO 230
      GO TO 240
  220 ISIG = - 1
  230 CALL RDNEXT (0)
      IFLAG = 1
  240 DO 250 J = 1, 36
      IF(ITEM .EQ. TABLE(J)) GO TO 260
  250 CONTINUE
      IF(IFLAG) 130, 100, 130
  260 IF(NVARY .GE. 30) GO TO 210
      NVARY = NVARY + 1
      VARY(NVARY) = ISIGN(J - 1, ISIG)
      GO TO 210
C
C     DATA VALUE
C
  300 CALL RDFLT (VALUE, IFLAG)
      IF(IFLAG .NE. 0) GO TO 130
      NWORD = NWORD + 1
      IF(NWORD .LE. 30) DATUM(NWORD) = VALUE
      GO TO 100
C
C     LABEL
C
  350 CALL RDSTRG (IWORD, 4, L)
      IF(L .GT. 4) WRITE (NOUT, 9350)
      SEPAR = .TRUE.
      IF(NWORD .EQ. 2 .AND. NTYPE .EQ. 15) GO TO 360
      IF(LABLE .NE. BLANK) WRITE (NOUT, 9360) LABLE
      DO 355 K = 1, L
       LABLE(K:K) = IWORD(K)
  355 CONTINUE
      GO TO 110
  360 NUC = NUC + 1
      DSTOR(NUC) = BLANK//BLANK//BLANK//BLANK
      DO 370 K = 1, L
       DSTOR(NUC)(K:K) = IWORD(K)
  370 CONTINUE
      DATUM(3) = NUC
      NWORD = 3
      GO TO 110
C
C     SENTINEL
C
  450 EMPTY = .TRUE.
      IF(NWORD .EQ. 0) RETURN
      SNTNL = .TRUE.
      GO TO 502
C
C     CHECK VALIDITY OF ELEMENT JUST READ
C
  500 IF(NWORD .EQ. 0) GO TO 130
      CALL RDNEXT (1)
  502 IF(NTYPE .EQ. 0) GO TO 510
      IF(NTYPE .LE. 21) GO TO 530
      IF(NTYPE .EQ. 26) GO TO 540
      IF(NTYPE .EQ. 27) GO TO 540
      IF(NTYPE .EQ. 28) GO TO 540
      IF(NTYPE .EQ. 29) GO TO 540
      IF(NTYPE .EQ. 30) GO TO 540
      IF(NTYPE .LT. 50) GO TO 510
      IF(NTYPE .LE. 53) GO TO 540
      IF(NTYPE .EQ. 60) GO TO 540
  510 WRITE (NOUT, 9510)
      FLUSH = .TRUE.
      GO TO 700
  530 LENGTH = NO1(NTYPE)
      IF(NTYPE .NE. 16) GO TO 535
      IF(DATUM(2) .GE. 0.0 .AND. DATUM(2) .LT. 99.5) GO TO 535
      LENGTH = 4
      IF(DATUM(2) .GE. 199.5) LENGTH = 2
  535 IF(NWORD - LENGTH) 600, 700, 550
  540 LENGTH = 5
      IF(NTYPE .EQ. 53) LENGTH = 1
      IF(NTYPE .EQ. 26) LENGTH = 4
      IF(NTYPE .EQ. 27) LENGTH = 4
      IF(NTYPE .EQ. 28) LENGTH = 9
      IF(NTYPE .EQ. 29) LENGTH = 8
      IF(NTYPE .EQ. 30) LENGTH = 12
      GO TO 535
C
C     DATA OVERFLOW
C
  550 IF(NTYPE .NE. 6) GO TO 555
      IF(DATUM(4) .NE. 0.0) LENGTH = 5
      IF(NWORD - LENGTH) 600, 700, 560
  555 IF(NTYPE .EQ.  1) LENGTH = 9
      IF(NTYPE .EQ. 14) LENGTH = 30
      IF(NWORD - LENGTH) 600, 700, 560
  560 WRITE (NOUT, 9560)
      GO TO 690
C
C     FILL IN INCOMPLETE 15 ELEMENT
C
  600 IF(INDIC .NE. 0) GO TO 700
      IF(NTYPE .NE. 15) GO TO 690
      IF(NWORD - 2) 620, 610, 630
  610 IF(DATUM(2) .NE. 0.0) GO TO 650
  620 DSTOR(NUC) = BLANK//BLANK//BLANK//BLANK
      GO TO 690
  630 DO 640 J = 1, 14
      IF(DSTOR(NUC) .EQ. UTABLE(J)) GO TO 660
  640 CONTINUE
  650 WRITE (NOUT, 9650)
      FLUSH = .TRUE.
      GO TO 700
  660 DATUM(4) = CTABLE(J)
      IF(DATUM(2) .GT. 6.0 .AND. J .LT. 6) DATUM(4) = 0.01 * DATUM(4)
  690 NWORD = LENGTH
C
C     PRINT OUT
C
  700 CALL PRINT1 (LABLE, NWORD, DATUM, VARY)
      IF(FLUSH) GO TO 10
      RETURN
C
 9130 FORMAT(' Scanning stops due to error at position shown below'/
     A       11X,80A1/10X,81A1)
 9350 FORMAT(' Next label truncated to 4 characters.')
 9360 FORMAT(' Label /,A4,/ on next element was overwritten.')
 9510 FORMAT(' Next element is illegal - run flushed.')
 9560 FORMAT(' Data list for next element is to long.')
 9650 FORMAT(' Error on following 15. element.')
      END
      SUBROUTINE RDFIX (IVALUE, IFLAG)
C     READ AN INTEGER
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
      COMMON /BLOC43/ NCD, MC, EMPTY
      LOGICAL EMPTY
      COMMON /BLO43A/ CARD(120), ITEM
      CHARACTER*1     CARD, ITEM
C
      IFLAG = - 1
      IVAL = 0
      IF(ITEM .EQ. MINUS) GO TO 10
      ISIG = 1
      IF(ITEM .EQ. PLUS(1) .OR. ITEM .EQ. PLUS(2)) GO TO 20
      GO TO 30
   10 ISIG = - 1
   20 CALL RDNEXT (0)
   30 DO 40 J = 1, 10
      IF(ITEM .EQ. TABLE(J)) GO TO 50
   40 CONTINUE
      IVALUE = ISIGN (IVAL, ISIG)
      RETURN
   50 IVAL = 10 * IVAL + J - 1
      IFLAG = 0
      GO TO 20
      END
      SUBROUTINE RDFLT (VALUE, IFLAG)
C     READ A FLOATING-POINT NUMBER
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
      COMMON /BLOC43/ NCD, MC, EMPTY
      LOGICAL EMPTY
      COMMON /BLO43A/ CARD(120), ITEM
      CHARACTER*1     CARD, ITEM
C
      IFLAG = - 1
      VAL = 0.0
      NPL = 0
      JPL = 0
      NEX = 0
      IF(ITEM .EQ. MINUS) GO TO 10
      SIG = 1.0
      IF(ITEM .EQ. PLUS(1) .OR. ITEM .EQ. PLUS(2)) GO TO 20
      GO TO 30
   10 SIG = - 1.0
   20 CALL RDNEXT (0)
   30 DO 40 J = 1, 10
      IF(ITEM .EQ. TABLE(J)) GO TO 50
   40 CONTINUE
      IF(ITEM .NE. PERIOD) GO TO 70
      IF(JPL .NE. 0) GO TO 60
      JPL = 1
      FF = 0.1
      GO TO 20
   50 IFLAG = 0
      IF(JPL .NE. 0) GO TO 55
      VAL = 10.0 * VAL + FLOAT(J - 1)
      GO TO 20
   55 VAL = VAL + FF * FLOAT(J - 1)
      FF = 0.1 * FF
      GO TO 20
   60 IFLAG = 1
      GO TO 90
   70 IF(ITEM .NE. TABLE(15)) GO TO 80
      CALL RDNEXT (0)
      CALL RDFIX (NEX, IFLAG)
      GO TO 90
   80 IF(ITEM .EQ. PLUS(1) .OR. ITEM .EQ. PLUS(2) .OR. ITEM .EQ. MINUS)
     A       CALL RDFIX (NEX, IFLAG)
   90 VALUE = SIGN (VAL, SIG)
      IF(NEX .NE. 0) VALUE = VALUE * 10.0 ** NEX
      RETURN
      END
      SUBROUTINE RDNEXT (ISKIP)
C     READ NEXT CHARACTER, OPTIONNALY SKIPPING BLANKS
      COMMON /BLOC3/ NIN, NOUT
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
      COMMON /BLOC43/ NCD, MC, EMPTY
      LOGICAL EMPTY
      COMMON /BLO43A/ CARD(120), ITEM
      CHARACTER*1     CARD, ITEM
C
      LOGICAL FIRST
      DATA FIRST /.TRUE./
C
      IF(ISKIP .LT. 0) GO TO 40
      IF(ISKIP .GE. 2) GO TO 20
      IF(EMPTY)        GO TO 20
   10 IF(MC .LT. 120)  GO TO 30
      IF(ISKIP .NE. 0) GO TO 20
      EMPTY = .TRUE.
      ITEM = BLANK
      RETURN
   20 MC = 0
      EMPTY = .FALSE.
      IF (FIRST) THEN
       OPEN(UNIT=NIN,FILE='FOR001.DAT',STATUS='OLD',ERR=60)
       FIRST = .FALSE.
      ENDIF
      READ (NIN, 100, END=70, ERR= 60) CARD
C
C     SPECIAL (overwrite CR and/or LF from Windows format)
C
      DO 25 IJK = 1, 120
       IF (CARD(IJK) .EQ. CHAR(13)) CARD(IJK) = BLANK
       IF (CARD(IJK) .EQ. CHAR(10)) CARD(IJK) = BLANK
   25 CONTINUE
C   
      NCD = NCD + 1
   30 MC = MC + 1
      ITEM = CARD(MC)
      IF(ISKIP .EQ. 0) RETURN
   40 IF(ITEM .EQ. BLANK) GO TO 10
      IF(ITEM .EQ. TABLE(29) .AND. ISKIP .EQ. 2) GO TO 50
      RETURN
   50 WRITE(NOUT,5000)
      CALL MENU(0)
   60 WRITE(NOUT,5001)
      CALL MENU(2)
   70 WRITE(NOUT,5002)
      CALL MENU(1)
C
  100 FORMAT(120A1)
 5000 FORMAT(/' Turtle finished.')
 5001 FORMAT(' Turtle Input_file not found.')
 5002 FORMAT(' Turtle Input_file EOF encountered.')
      END
      SUBROUTINE RDSKIP
C     SKIP COMMENTS
      COMMON /BLOC3/ NIN, NOUT
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
      COMMON /BLOC43/ NCD, MC, EMPTY
      LOGICAL EMPTY
      COMMON /BLO43A/ CARD(120), ITEM
      CHARACTER*1     CARD, ITEM
C
      CHARACTER*1     LINE(80)
C
   10 IF(ITEM .NE. PAR1(1) .AND. ITEM .NE. PAR1(2)) RETURN
      CALL RDSTRG (LINE, 80, L)
      IF(L .GT. 80) WRITE (NOUT, 100)
      WRITE (NOUT, 110) LINE
      GO TO 10
  100 FORMAT(' Next comment truncated to 80 characters.')
  110 FORMAT(' (',80A1,')')
      END
      SUBROUTINE RDSTRG (STRING, LMAX, L)
C     READ A CHARACTER STRING
      COMMON /BLOC42/ TABLE(36), PLUS(2), MINUS, BLANK, PERIOD,
     A                SEMI(5), QUOTE(6), PAR1(2), PAR2(2)
      CHARACTER*1     TABLE, PLUS, MINUS, BLANK, PERIOD, SEMI, QUOTE,
     A                PAR1, PAR2
      COMMON /BLOC43/ NCD, MC, EMPTY
      LOGICAL EMPTY
      COMMON /BLO43A/ CARD(120), ITEM
      CHARACTER*1     CARD, ITEM
C
      CHARACTER*1 STRING(*), CHAR(4), ISTOP
C
      DO 10 L = 1, LMAX
   10 STRING(L) = BLANK
      L = 0
      DO 12 J = 1, 2
       IF(ITEM .EQ. PAR1(J)) GO TO 20
   12 CONTINUE
      DO 14 J = 1, 6
       IF(ITEM .EQ. QUOTE(J)) GO TO 16
   14 CONTINUE
      RETURN
   16 ISTOP = QUOTE(J)
      GO TO 30
   20 ISTOP = PAR2(J)
   30 ISKIP = 1
   40 CALL RDNEXT (ISKIP)
      IF(ITEM .EQ. ISTOP) GO TO80
      ISKIP = 0
      IF(ITEM .EQ. BLANK .OR. LMAX .EQ. 4) ISKIP = 1
      L = L + 1
      STRING(L) = ITEM
      IF(ITEM .NE. ISTOP) GO TO 40
   80 CALL RDNEXT (1)
      RETURN
      END
      SUBROUTINE REPETI
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC17/ IP, IC(4), IS(4), INEL(4)
C
      IF (IDATA(I+1) .NE. 0) GO TO 1
      IC(IP)  =  IC(IP)  -  1
      IF(  IC(IP)  .EQ.  0   )    GO TO   2
      I  =  IS(IP)
      NEL = INEL(IP)
      RETURN
    2 IP  =  IP-1
      RETURN
    1 IP  =  IP+1
      IC(IP) = IDATA(I+1)
      IS(IP) = I
      INEL(IP) = NEL
      RETURN
      END
      SUBROUTINE RESLIT
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC19/ CONE, ISTOR(100), SLIT1(100), SLIT2(100), NSLIT,
     A                ORIG, ISLT, IFF, IFG, A, B, RECTA
      LOGICAL CONE, ORIG, RECTA
      DO 100 J=1,NSLIT
      I=ISTOR(J)
      DATA(I+2)=SLIT1(J)
      DATA(I+4)=SLIT2(J)
  100 CONTINUE
      ORIG = .TRUE.
      RETURN
      END
      SUBROUTINE RMSADD
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC4/ RAYMAX(6), PBEAM, P0, NORAYS
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC46/ SM, GAMMA0, BETA0, CHARGE
      COMMON /BLOC53/ ENERGY
      LOGICAL ENERGY
C
C     RMS CONTRIBUTIONS ARE GAUSSIAN
C
      CALL CORREL(0.0,X1,X3,0)
      CALL CORREL(0.0,X2,X4,0)
      CALL CORREL(0.0,X5,X6,0)
      RAY(1) = RAY(1) + DATA(I+1) * X1
      RAY(2) = RAY(2) + DATA(I+2) * X2
      RAY(3) = RAY(3) + DATA(I+3) * X3
      RAY(4) = RAY(4) + DATA(I+4) * X4
      IF (ENERGY) THEN
       GAMMA = SQRT(1. + (P / SM) **2)
       E = P**2 / ((1. + GAMMA) * SM)
       SCF = GAMMA / (GAMMA + 1.)
       P = P + SCF * ( X6 * P0 * DATA(I+6) + (P / E) * DATA(I+7) )
      ELSE
       P = P + X6 * P0 * DATA(I+6) + DATA(I+7)
      ENDIF
      RAY(6) = (P - P0) / P0
      RETURN
      END

      SUBROUTINE RSETR (A,B)
C
      DIMENSION A(6), B(6)
C
      A(1) = B(1)
      A(2) = B(2)
      A(3) = B(3)
      A(4) = B(4)
      RETURN
      END

      SUBROUTINE RSETR2 (A,B)
C
      DIMENSION A(6), B(6)
C
      A(1) = B(1)
      A(2) = B(2)
      A(3) = B(3)
      A(4) = B(4)
      A(5) = B(5)
      A(6) = B(6)
      RETURN
      END

      SUBROUTINE SAVSLT
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC3/ NIN, NOUT
      COMMON /BLOC19/ CONE, ISTOR(100), SLIT1(100), SLIT2(100), NSLIT,
     A                ORIG, ISLT, IFF, IFG, A, B, RECTA
      LOGICAL CONE, ORIG, RECTA
C
      I=1
      IC=0
      DO 100 J=1,NEL
      NTYPE=IDATA(I)
      IF(NTYPE.NE.6) GO TO 90
      IC=IC+1
      IF(IC.LE.100) GO TO 80
      WRITE(NOUT,1000)
 1000 FORMAT
     X(' More than 100 slit cards with cone card(s) are used.')
      CALL MENU(1)
   80 ISTOR(IC)=I
      SLIT1(IC)=DATA(I+2)
      SLIT2(IC)=DATA(I+4)
   90 I=I+NU(NTYPE)
  100 CONTINUE
      NSLIT=IC
      ORIG = .TRUE.
      RETURN
      END
      LOGICAL FUNCTION SESTOP(LFLAG)
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC5/ SEC, CAP(3), MPA, THIRD
      LOGICAL         SEC, CAP, MPA, THIRD
      COMMON /BLOC11/ QAP(3), ELLIPS, HYPER
      LOGICAL         ELLIPS, HYPER
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
C
      IF(.NOT. CAP(LFLAG+1)) GO TO 30
      IF(ELLIPS) GO TO 10
      IF(RAY(1) ** 2 + RAY(3) ** 2 .GT. DATA(I+3)) GO TO 40
      GO TO 30
   10 IF((RAY(1)/QAP(1)) ** 2 + (RAY(3)/QAP(2)) ** 2 .GT. 1.0) GO TO 40
   30 SESTOP = .FALSE.
      RETURN
   40 SESTOP = .TRUE.
      RETURN
      END
      SUBROUTINE SETUP
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC2/  UNIT(12)
      COMMON /BLOC2A/ NAME(12), NOM(12), NOM1(4), DSTOR(20)
      CHARACTER*4     NAME, NOM, NOM1, DSTOR
      COMMON /BLOC3/ NIN, NOUT
      COMMON /BLOC4/ RAYMAX(6), PBEAM, P0, NORAYS
      COMMON /BLOC5/ SEC, CAP(3), MPA, THIRD
      LOGICAL         SEC, CAP, MPA, THIRD
      COMMON /BLOC6/ NHISTS, NHIST, LIMNO
      COMMON /BLOC7/ MTYPE(100), NENTRY(100), NCOOR(100), INTVLS(100),
     A                BEGIN(100), END(100), STEP(100), ZHIST(100)
      COMMON /BLOC7A/ LTAG(100)
      CHARACTER*4     LTAG
      COMMON /BLOC8/ MTABLE(50000)
      REAL MTABLE
      COMMON /BLOC9/ L, H, N, BDB
      REAL            L, N
      COMMON /BLOC10/ APB(2), LAYL, LAYX, RAB1, RAB2, FACE
      REAL            LAYL, LAYX
      COMMON /BLOC11/ QAP(3), ELLIPS, HYPER
      LOGICAL         ELLIPS, HYPER
      COMMON /BLOC12/ VALUE(100), XMOM(100), XMOM2(100), NFLAG(100),
     A                SET(100), KFLAG(100), IFLAG(3,0:9), ZFLAG(9),
     A                WZ(100), UFLAG(100), INVFL, ZC
      LOGICAL SET, IFLAG, UFLAG, INVFL
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC15A/ EQUAD, EBEND, BSCAL, BSCAL2, NSCAL, ISWITCH
      LOGICAL EQUAD, EBEND
      COMMON /BLOC16/ ISTOP(3,9998)
      REAL ISTOP
      COMMON /BLO16A/ KPART(3)
      CHARACTER*4     KPART
      COMMON /BLOC18/ LOSS, NBLK(20), KFLG(20),
     A                XSTRT(20), XEND(20), LTHX(20), XBIN(20), NUNX(20),
     A                YSTRT(20), YEND(20), LTHY(20), YBIN(20), NUNY(20)
      COMMON /BLOC19/ CONE, ISTOR(100), SLIT1(100), SLIT2(100), NSLIT,
     A                ORIG, ISLT, IFF, IFG, A, B, RECTA
      LOGICAL CONE, ORIG, RECTA
      COMMON /BLOC23/ NCOUNT
      COMMON /BLOC41/ LW, FLUSH, INDIC, NTYPE, LENGTH,
     A                NWORD, NVARY, DATUM(30), VARY(30)
      INTEGER VARY
      LOGICAL FLUSH
      COMMON /BLO41A/ IMAGE(80), LABLE
      CHARACTER       IMAGE*1, LABLE*4
      COMMON /BLOC44/ LINV, SINV, SINV2, MULTSC
      LOGICAL LINV, SINV, SINV2, MULTSC
      COMMON /BLOC45/ CHIX, SNCHIX, CSCHX2, CHIY, SNCHIY,
     A                CSCHY2, GAUSS, VOL4
      LOGICAL GAUSS, VOL4
      COMMON /BLOC46/ SM, GAMMA0, BETA0, CHARGE
      COMMON /BLOC47/ IRAN
      COMMON /BLOC48/ XI1, XI2, XI3, XI4
      COMMON /BLOC50/ NOSUP
      COMMON /BLO50A/ LABSUP(20)
      CHARACTER*4     LABSUP
      COMMON /BLOC51/ IOCASE(5), IOUNIT(5), IONUM, UNIT1
      INTEGER UNIT1
      COMMON /BLOC52/ W, POLX(0:2), POLY(0:2), POLZ(0:2), POLCAL
      LOGICAL POLCAL
      COMMON /BLOC53/ ENERGY
      LOGICAL ENERGY
      COMMON /BLOC54/ BINOM, XM, YM, ZM, XNORM, YNORM, ZNORM
      LOGICAL BINOM
      COMMON /BLOC62/ IUNIT3RD, NUMLIM, ZZ
      INTEGER     TYPE
      LOGICAL     LEGAL, BEAMR, FIRST
      REAL        CTABLE(14), UORIG(12), ZL(4), WORK(30)
      CHARACTER*4 UTABLE(14), NORIG(12), IRAYS, LTAGS
      INTEGER     ICC(4)
      EQUIVALENCE (TYPEC, WORK, DATUM), (TYPE, NTYPE), (NFL, VARY(2))
      CHARACTER   FILNAM*10
C
      DATA CTABLE     / 1.,100.,2.54,30.48,.1,1000., 1.,1.,.1,
     1 100.,.001, 1. ,1., .001  /
      DATA UTABLE / 'CM  ', 'M   ', 'IN  ', 'FT  ', 'MM  ', 'R   ',
     X              'MR  ', 'PC  ', 'P/10', 'N   ', 'MEV ', 'GEV ',
     Y              'KG  ', 'G   ' /
      DATA NORIG / 'cm  ', 'mrad', 'cm  ', 'mrad', 'cm  ', '%   ',
     A             'deg ', 'm   ', 'kG  ', 'em  ', 'GeVc', 'GeV '/
      DATA UORIG / 0.01, 0.001, 0.01, 0.001, 0.01, 0.01, 0.01745329,
     A             1.0, 1.0, 1.0, 1.0, 1.0 /
      IRAYS = 'rays'
      LTAGS = '    '
      IFACE = -10
      INEXT = -10
      SM    = 0.0
      NOSUP = 0
      IRAN  = 0
      IOCASE(1)=-1
      IOCASE(2)=-1
      IOCASE(3)=-1
      IOCASE(4)=-1
      IOCASE(5)=-1
      NCOUNT  = 1
      CHARGE  = 1.0
      CHIX    = 0.0
      SNCHIX  = 0.0
      CSCHX2  = 1.0
      CHIY    = 0.0
      SNCHIY  = 0.0
      CSCHY2  = 1.0
      EQUAD   = .FALSE.
      EBEND   = .FALSE.
      ENERGY  = .FALSE.
      BEAMR   = .FALSE.
      MULTSC  = .FALSE.
      GAUSS   = .TRUE.
      BINOM   = .FALSE.
      VOL4    = .FALSE.
      CONE    = .FALSE.
      INVFL   = .FALSE.
      POLCAL  = .FALSE.
      FIRST   = .TRUE.
      DATA FILNAM /'FOR000.DAT'/
C
C     READ TITLE
C
   10 CALL RDNEXT (2)
      CALL RDSKIP
      CALL RDSTRG (IMAGE, 80, LW)
      WRITE (NOUT, 9000) IMAGE
      CALL RDSKIP
      CALL RDFIX (NORAYS, IFLG)
      CALL RDNEXT (- 1)
      WRITE (NOUT, 9005) NORAYS
      IF (NORAYS .LE. 0) THEN
       WRITE(NOUT,*) 'Input file not for TURTLE'
       CALL MENU(1)
      ENDIF
      INDIC = 0
 9000 FORMAT(' ',80A1)
 9005 FORMAT(' ',I7)
C
C     READ DATA
C
      DO 50 ISBK = 1, NND
   50 DATA(ISBK) = 0.0
      I = 1
      NHISTS = 0
      LIMNO = 0
      ZC = 0.0
      DKFLAG = .FALSE.
      LOSS = 0
      DO 55 J = 1, 3
   55 KPART(J) = IRAYS
      ZMAX = 0.0
      IP = 0
      NEL = 1
      FLUSH = .FALSE.
      DO 60 J = 1, 11
      NAME(J) = NORIG(J)
   60 UNIT(J) = UORIG(J)
  100 CALL RDELEM
      IF(NWORD .EQ. 0) GO TO 600
      IF(FLUSH) GO TO 100
      IF(I + NU(NTYPE) .LE. NND .AND. NEL .LE. NNL) GO TO 200
      WRITE(NOUT, 1000) NEL, I
 1000 FORMAT(' Data overflow, NEL =',I4,', I =',I6)
      FLUSH = .TRUE.
      GO TO 100
  200 LABEL(NEL) = LABLE
      IF(TYPEC .LT. 0.0) GO TO 100
      IF(TYPE .EQ. 60) GO TO 550
      IF(TYPE .EQ. 53) GO TO 480
      IF (TYPE .GE. 50) GO TO 450
      GO TO (210,220,230,240,250,260,270,280,290,300,310,320,330,340,
     A       350,360,370,380,390,400,410,100,100,100,100,430,420,425,
     A       570,560), TYPE
C
C     BEAM
C
  210 IF (NWORD .GE. 9) GO TO 212
      IF (BEAMR) THEN
      WRITE(NOUT,1002)
 1002 FORMAT(' 9th entry (id) on "add to beam" card is missing.')
      CALL MENU(1)
      END IF
      IF (ENERGY) THEN
       IF (SM.EQ.0.) THEN
        WRITE(NOUT,2100)
 2100   FORMAT(' Particle mass - in electron units - must be given via'
     A        ,' a 16. card for computing momentum.')
        CALL MENU(1)
       ENDIF
       EBEAM = WORK(8) * UNIT(12)
       PBEAM = SQRT(EBEAM * (2.0 * SM + EBEAM))
       GAMMA0 = SQRT(1. + (PBEAM / SM) ** 2)
      ELSE
       PBEAM = WORK(8) * UNIT(11)
      ENDIF
      P0 = PBEAM
C
      DO 211 IB = 1, 6
  211 RAYMAX(IB) = WORK(IB+1)*UNIT(IB)
      IF (ENERGY) RAYMAX(6) = RAYMAX(6) * GAMMA0 / (1. + GAMMA0)
      BEAMR = .TRUE.
C
      IF(RAYMAX(1).GT.0.0) GO TO 100
      UNIT1=ABS(WORK(2)-0.001)
      CALL UNIFIL(FILNAM,UNIT1)
      OPEN(UNIT=UNIT1,FILE=FILNAM,STATUS='OLD')
      GO TO 100
C
  212 IF(MULTSC) GO TO 215
C
C     RMS-ADDITION TO BEAM (GAUSSIAN)
C
      IDATA(I) = TYPE
      DO 213 IB = 1, 6
  213 DATA(I+IB) = WORK(IB+1)*UNIT(IB)
      IF (.NOT.ENERGY) DATA(I+7) = WORK(8)*UNIT(11)
      IF (  ENERGY   ) DATA(I+7) = WORK(8)*UNIT(12)
  214 IDATA(I+8) = WORK(9) / 100. + .001
      GO TO 500
C
C     MULTIPLE SCATTERING (MOLIERE-LANDAU)
C
  215 IDATA(I) = TYPE
      DATA(I+1) = WORK(2)*UNIT(2)
      DATA(I+2) = WORK(3)
      DATA(I+3) = WORK(4)*UNIT(1)
      DATA(I+4) = MIN(WORK(5),1.0)
      DATA(I+5) = WORK(6)*UNIT(2)
      DATA(I+6) = WORK(7)*UNIT(11)
      DATA(I+7) = WORK(8)*UNIT(11)
      IDATA(I+8)= WORK(9) / 100. + .001
      IF(SM.NE.0.0) GO TO 500
      WRITE(NOUT,2160)
 2160 FORMAT(' Particle mass - in electron units - must be given via a
     A 16. card before multiple scattering is used.')
      CALL MENU(1)
C
C     MAGNET POLE FACE ROTATION
C
  220 IDATA(I) = TYPE
      IF (WORK(2) .GE. 1000.) GO TO 225
      FACE = WORK(2) * UNIT(7)
      TANB = TAN(FACE)
      SECB = 1.0 / COS(FACE)
      TCOR = 2.0 * APB(2) * LAYL
      SB = SECB * (1.0 + 2.0 * TANB ** 2)
      IF (I .EQ. INEXT) GO TO 221
      IFACE = I
      GO TO 500
C
C     FRINGE FIELD AT MAGNET EXIT.
C
  221 DATA(I+1) = - H * P0
      DATA(I+2) = - TANB
      DATA(I+3) = SECB
      DATA(I+4) = N * H * TANB - 0.5 * RAB2 * SECB ** 3
      DATA(I+5) = TCOR * SB * (1.0 - H * LAYX * TCOR * TANB)
      DATA(I+6) = - 0.5 * TANB ** 3
      DATA(I+7) = DATA(I+6)
      DATA(I+8) = - TANB * SECB ** 2
      DATA(I+9) = RAB2
      DATA(I+10) = -1.
      IF (N .NE. 0.) DATA(I+10) = 1000.
      INEXT = - 10
      GO TO 500
C
C     FRINGE FIELD AT QUAD EXIT
C
  225 IF (I .NE. INEXT) THEN
       IFACE = I
      ELSE
       DATA(I+1) = 0.
       DATA(I+2) = 1000.
       DATA(I+3) = 0.
       DATA(I+4) = -1. * AUX1    * AUX2**2 * XI1
       DATA(I+5) = -2. * AUX1    * AUX2**3 * XI2
       DATA(I+6) = -1. * AUX1**2 * AUX2**3 * XI3
       DATA(I+7) = -1. * AUX1**2 * AUX2    * XI4 / 3.
       DATA(I+8) = -1. * AUX1 / 4.
       DATA(I+9) = 0.
       DATA(I+10) = 0.
       INEXT = - 10
      ENDIF
      GO TO 500
C
C     DRIFT SPACE
C
  230 IDATA(I) = TYPE
      L = WORK(2)*UNIT(8)
      DATA(I+1) = L
      GO TO 490
C
C     BENDING MAGNET
C
  240 IDATA(I) = TYPE
      IF (EBEND) GO TO 248
      L = WORK(2)*UNIT(8)
      H = WORK(3)*UNIT(9)*CHARGE/(33.356*P0)
      N = WORK(4)
      IF(I .NE. IFACE + NU(2)) GO TO 245
C
C     FRINGE FIELD AT MAGNET ENTRANCE.
C
      DATA(IFACE+1) = H * P0
      DATA(IFACE+2) = TANB
      DATA(IFACE+3) = SECB
      DATA(IFACE+4) = 0.5 * RAB1 * SECB ** 3 - N * H * TANB
      DATA(IFACE+5) = TCOR * SB * (1.0 - H * LAYX * TCOR * TANB)
      DATA(IFACE+6) = 0.0
      DATA(IFACE+7) = TANB * (0.5 + TANB ** 2)
      DATA(IFACE+8) = 0.0
      DATA(IFACE+9) = RAB1
      DATA(IFACE+10)= 1.0
      IF (N .NE. 0.) DATA(IFACE+10) = 1000.
  245 DATA(I+1) = L
      DATA(I+2) = H
      DATA(I+3) = N
      DATA(I+4) = 0.0
      DATA(I+5) = 0.0
      INEXT = I + NU(4)
      IF(DATA(I+2) .EQ. 0.0) GO TO 490
      DATA(I+4) = 1.0 / DATA(I+2)
      IF(SEC) DATA(I+5) = BDB * DATA(I+4) ** 2
      GO TO 490
C
C     ELECTROSTATIC PRISM
C
  248 CONTINUE
      L = WORK(2)*UNIT(8)
      AL = WORK(3)*UNIT(7)
      CC = WORK(4)
      H = AL / L
      IF (SM. EQ. 0.) THEN
        WRITE(NOUT,2100)
        CALL MENU(1)
        RETURN
      ENDIF
      BG0 = P0 / SM
      GAMMA0 = SQRT( 1. + BG0 ** 2 )
      BETA0 = BG0 / GAMMA0
      B2 = BETA0**2
      IF (CC .EQ. 0.0) THEN       ! CYLINDRICAL
       PP = SQRT(2.0 - B2)
       QQ = 0.0
      ELSE IF (CC .EQ. 1.0) THEN  ! SPHERICAL
       PP = SQRT(1.0 - B2)
       QQ = 1.0
      ELSE                        ! TOROIDAL
       PP = SQRT(2. - CC - B2)
       QQ = SQRT(CC)
      ENDIF
      XKH  = PP * H
      XKV  = QQ * H
      DATA(I+1) = L
      DATA(I+2) = XKH
      DATA(I+3) = XKV
      DATA(I+4) = H
      GO TO 490
C
C     QUADRUPOLE
C
  250 IDATA(I)  = TYPE
      L         = WORK(2)*UNIT(8)
      IF (EQUAD) THEN
       IF (SM. EQ. 0.) THEN
        WRITE(NOUT,2100)
        CALL MENU(1)
        RETURN
       ENDIF
       UNITSP = 0.0001  ! kV/cm --> GV/m
       AUX1 = WORK(3)*UNITSP*CHARGE/(WORK(4)*UNIT(1))
      ELSE
       AUX1 = WORK(3)*UNIT(9)*CHARGE/(WORK(4)*UNIT(1)*33.356)
      ENDIF
      AUX2  = WORK(4) * UNIT(1)
      IF(I .NE. IFACE + NU(2)) GO TO 255
C
C     FRINGE FIELD AT QUAD ENTRANCE
C
      DATA(IFACE+1) = 0.
      DATA(IFACE+2) = 1000.
      DATA(IFACE+3) = 0.
      DATA(IFACE+4) =       AUX1    * AUX2**2 * XI1
      DATA(IFACE+5) = -2. * AUX1    * AUX2**3 * XI2
      DATA(IFACE+6) = -1. * AUX1**2 * AUX2**3 * XI3
      DATA(IFACE+7) = -1. * AUX1**2 * AUX2    * XI4 / 3.
      DATA(IFACE+8) =       AUX1 / 4.
      DATA(IFACE+9) = 0.
      DATA(IFACE+10)= 0.
  255 DATA(I+1) = L
      DATA(I+2) = AUX1
      DATA(I+3) = AUX2**2
      INEXT = I + NU(5)
      GO TO 490
C
C     SLIT
C
  260 IDATA(I) = TYPE
      IFF = WORK(2) + .001
      IDATA(I+1) = IFF
      IUN = MOD(IFF,100)
      IF (IUN .LE. 0) GO TO 100
      DATA(I+2) = WORK(3) * UNIT(IUN)
      IFG = WORK(4) + .001
      IUN = MOD(IFG, 100)
      IF (IUN .LT. 0) GO TO 100
      IDATA(I+3) = IUN
      DATA(I+4) = 0.0
      IF(IUN .NE. 0) DATA(I+4) = WORK(5) * UNIT(IUN)
      GO TO 500
C
C     DISPLACEMENT OF RAY
C
  270 IDATA(I) = TYPE
      DO 271 IB = 1, 6
  271 DATA(IB+I) = WORK(IB+1)*UNIT(IB)
      GO TO 500
C
C     MISALIGNMENTS
C
  280 WRITE (NOUT,1001)
 1001 FORMAT(' This program will not do misalignments.')
      STOP
C
C      REPEAT
C
  290 IDATA(I) = TYPE
      IDATA(I+1) = WORK(2) + .001
      IF (IDATA(I+1) .EQ. 0) GO TO 291
      IP = IP + 1
      ICC(IP) = IDATA(I+1)
      ZL(IP) = ZC
      GO TO 500
  291 IF (IP .EQ. 0) THEN
       WRITE(NOUT,4321)
 4321  FORMAT(' Beginning and terminating cards of repeat sections are',
     X ' not balanced - last card is ignored.')
       GO TO 100
      ELSE
       ZC = ZC + FLOAT(ICC(IP) - 1)*(ZC - ZL(IP))
       IP = IP - 1
       GO TO 500
      ENDIF
C
C     CONSTRAINTS
C
  300 GO TO 100
C
C     ELECTROSTATIC ACCELERATOR
C
  310 IF (SM. EQ. 0.) THEN
        WRITE(NOUT,2100)
        CALL MENU(1)
        RETURN
      ENDIF
      L = WORK(2) * UNIT(8)
      IF (L .EQ. 0.0) THEN
       VOLTS = WORK(3) * UNIT(11)
       POT0 = 0.0
       L = 0.0
       IDATA(I) = TYPE
       DATA(I+1) = L
       DATA(I+2) = POT0
      ELSE IF (L .LT. 0.0) THEN   !  OPTION: IF L<0 THEN COMPUTE NEW P0
       POT0 = VOLTS * WORK(3)
       IDATA(I) = TYPE
       L = -L
       DATA(I+1) = L
       DATA(I+2) = POT0
       IF (SM .NE. 0.) THEN  ! GET NEW P0 AT END OF ACCELERATION
        BG0 = P0 / SM
        GAMMA0 = SQRT( 1. + BG0 ** 2 )
        BETA0 = BG0 / GAMMA0
        E0 = P0**2 / ((1. + GAMMA0) * SM)
        E1 = E0 + CHARGE * VOLTS * WORK(3)
        P0 = SQRT(E1*(2.*SM+E1))
       ENDIF
      ELSE
       POT0 = VOLTS * WORK(3)
       IDATA(I) = TYPE
       DATA(I+1) = L
       DATA(I+2) = POT0
      ENDIF
      GO TO 490
C
C     BEAM ROTATED ELLIPSE
C
  320 CHIX=ASIN(WORK(2))
      SNCHIX=WORK(2)
      CSCHX2=COS(CHIX)**2
      CHIY=ASIN(WORK(7))
      SNCHIY=WORK(7)
      CSCHY2=COS(CHIY)**2
      GO TO 100
C
C     INPUT OUTPUT OPTIONS
C
  330 IDATA(I) = TYPE
      DATA(I+1) = WORK(2)
      GO TO 500
C
C     ARBITRARY MATRIX
C
  340 IDATA(I) = TYPE
      NROW = WORK(8) + .001
      DO 341 IB = 1, 6
  341 DATA(I+IB) = WORK(IB+1)*UNIT(NROW)/UNIT(IB)
      IDATA(I+7) = NROW
      IF (SEC .AND. NWORD .GT. 8) GO TO 342
      IDATA(I+8) = 1
      GO TO 500
  342 IDATA(I+8) = 0
      IPL = 9
      DO 343 IB = 1, 6
      DO 343 IC = IB, 6
      IPL = IPL + 1
      IST = IPL + I - 1
  343 DATA(IST) = WORK(IPL)*UNIT(NROW)/(UNIT(IB)*UNIT(IC))
      GO TO 500
C
C     UNITS
C
  350 NUN = WORK(2) + .001
      IF(NUN .EQ. 0) GO TO 355
      III = WORK(3)
      NAME(NUN) = DSTOR(III)
      UNIT(NUN) = WORK(4) * UORIG(NUN)
      IF(NUN .GT. 2) GO TO 100
      UNIT(NUN+2) = UNIT(NUN)
      NAME(NUN+2) = NAME(NUN)
      GO TO 100
  355 DO 356 J = 1, 12
      NAME(J) = NORIG(J)
  356 UNIT(J) = UORIG(J)
      GO TO 100
C
C     MULTIPOLE ABERRATIONS IN QUADS AND BENDING MAGNET PARAMETERS
C
  360 IDATA(I) = TYPE
      NM = ABS(WORK(2)) + .001
      IF (WORK(2) .GT. 0.0) GO TO 361
      IF (NM .LE. 20) GO TO 3601
      WRITE (NOUT,1010)
 1010 FORMAT (' Index of multipole may not exceed 20.')
      STOP
 3601 MPA = .TRUE.
      IDATA(I+1) = - NM
      DATA(I+2) = WORK(3)/UNIT(1)**(NM-2)
      ANGLE = WORK(4)/57.29578
      DATA(I+3) = COS(ANGLE)
      DATA(I+4) = SIN(ANGLE)
      GO TO 500
  361 CALL SPSHLS(NM,*100,*500)
      WRITE(NOUT,1234)
 1234 FORMAT(' SPSHLS wrong way')
      STOP
C
C     SECOND AND THIRD ORDER
C
  370 SEC = .TRUE.
      IF (WORK(2) .GE. 3.0) THEN
       THIRD = .TRUE.
       WRITE(NOUT,*) '  ** 3rd order **'
      ELSE IF (WORK(2) .EQ. 1.0) THEN
       SEC = .FALSE.
       THIRD = .FALSE.
       WRITE(NOUT,*) '  ** 1st order **'
      ENDIF
      IF (SEC .AND. .NOT.THIRD) THEN
       WRITE(NOUT,*) '  ** 2nd order **'
      ENDIF
C
      IDATA(I) = TYPE
      DATA(I+1) = WORK(2)
      GO TO 500
C
C     SEXTUPOLE
C
  380 IDATA(I) = TYPE
      L = WORK(2)*UNIT(8)
      DATA(I+1) = L
      DATA(I+2) = WORK(3)*UNIT(9)*CHARGE/((WORK(4)*UNIT(1))**2*33.356)
      GO TO 490
C
C     SOLENOID
C
  390 IDATA(I) = TYPE
      L = WORK(2) * UNIT(8)
      DATA(I+1) = L
      DATA(I+2) = 0.5 * WORK(3) * UNIT(9) * CHARGE / 33.356
      GO TO 490
C
C     BEAM ROTATION
C
  400 IDATA(I) = TYPE
      ANGLE = WORK(2) * UNIT(7)
      DATA(I+1) = COS(ANGLE)
      DATA(I+2) = SIN(ANGLE)
      GO TO 500
C
C     WIEN FILTER
C
  410 IF (SM .EQ. 0.0) THEN
       WRITE(NOUT,4100)
 4100 FORMAT(' Particle mass - in electron units - must be given via a 16.
     A card before a 21. card is used.')
       CALL MENU(1)
      ENDIF
      IDATA(I) = TYPE
      L = WORK(2) * UNIT(8)
      H = WORK(3) * UNIT(9) * CHARGE / 33.356
      BETGM0 = P0 / SM
      GAMMA0 = SQRT( 1. + BETGM0 ** 2 )
      BETA0 = BETGM0 / GAMMA0
      ARG = H * L / (P0 * GAMMA0)
      EFIELD = 299.79 * BETA0 * WORK(3) * UNIT(9)
      IF ( ARG .LT. 0.1 .OR. DKFLAG .OR. WORK(4) .NE. 0.0 ) THEN
       BETA0W = BETA0
       IF (WORK(4) .NE. 0.0) THEN
        EFIELD = WORK(4)
        BETA0W = EFIELD / ( 299.79 * WORK(3) * UNIT(9) )
       ENDIF
       WRITE(NOUT,4101) EFIELD, ARG
 4101  FORMAT('   Wien-Filter = Particle-Separator, E =',F7.2,
     A        ' kV/cm, phi* =',F6.3)
      ELSE
       WRITE(NOUT,4102) EFIELD, ARG
 4102  FORMAT('   Wien-Filter = Spin-Rotator, E =',F7.2,
     A        ' kV/cm, phi* =',F6.3)
       BETA0W = 0.
      ENDIF
      DATA(I+1)=L
      DATA(I+2)=H
      DATA(I+3)=BETA0W
      GO TO 490
C
C     B-E CROSSFIELD
C
  420 IF (SM .EQ. 0.0) THEN
       WRITE(NOUT,4200)
 4200 FORMAT(' Particle mass - in electron units - must be given via a 16.
     A card before a 27. card is used.')
       CALL MENU(1)
      ENDIF
      IDATA(I)  = TYPE
      L = WORK(2) * UNIT(8)
      BETGM0 = P0 / SM
      GAMMA0 = SQRT( 1. + BETGM0 ** 2 )
      BETA0 = BETGM0 / GAMMA0
      IF (WORK(3) .NE. 0.0) THEN
       RHOE0 = 10000.*BETA0**2 * GAMMA0*SM / (UNIT(10)*WORK(3)*CHARGE)
      ELSE
       RHOE0 = 9999.99
      ENDIF
      IF (WORK(4) .NE. 0.0) THEN
        RHOB0 = 33.356 * P0 / (WORK(4) * UNIT(9) * CHARGE)
      ELSE
       RHOB0 = 9999.99
      ENDIF
      WRITE(NOUT,4201) RHOE0, RHOB0
 4201 FORMAT(
     *'  E-B Crossed field region, rhoE =',F7.2,' m, rhoB =',F7.2,' m')
      DATA(I+1) = L
      DATA(I+2) = RHOE0 / (BETA0**2 * GAMMA0)
      DATA(I+3) = RHOB0 / P0
      GO TO 490
C
C     SOLENOID (RUNGE-KUTTA)
C
  425 IDATA(I)  = TYPE
      L         = WORK(2) * UNIT(8)
      DATA(I+1) = L
      L = MAX(L,0.0)
C
      DATA(I+2) = WORK(3)*UNIT(9)
      DATA(I+3) = WORK(4)*UNIT(9) / UNIT(1)**2
      DATA(I+4) = WORK(5)*UNIT(9) / UNIT(1)**4
C
      DATA(I+5) = WORK(6)*UNIT(9) / UNIT(1)
      DATA(I+6) = WORK(7)*UNIT(9)
      DATA(I+7) = WORK(8) / UNIT(1)
C
      DATA(I+8) = WORK(9) * UNIT(1)
      IF (NFL.NE.0 .AND.WORK(2).LT.0.0) THEN
       NSCAL = NFL
       Write(NOUT,1239) NSCAL
 1239  FORMAT
     1 ('Type Code 28 Overlap: Take scaling factor',
     2 I2,' for remaining 28 codes.')
       IF (NFL.LT.0 .OR. NFL.GT.2) THEN
        WRITE(NOUT,*) 'Error type code 28 flag: 1 or 2 only.'
        CALL MENU(1) 
       ENDIF
      ENDIF
      GO TO 490
C
C     OCTUPOLE
C
  430 IDATA(I)  = TYPE
      L         = WORK(2)*UNIT(8)
      DATA(I+1) = L
      DATA(I+2) = WORK(3)*UNIT(9)*CHARGE / (33.356*(WORK(4)*UNIT(1))**3)
      DATA(I+3) = WORK(4)*UNIT(1)
      GO TO 490
C
C     SET UP HISTOGRAM
C
  450 IF (IP .GT. 0) THEN
       WRITE(NOUT,4322)
 4322  FORMAT(' No histograms permitted within a repeat section',
     X ' - histogram is ignored.')
       GO TO 100
      ENDIF
      KODE = WORK(2) + .001
      KFL = KODE / 100
      NUN = KODE - 100 * KFL
      CALL HSTUN (NUN, FACT, LEGAL)
      IF (.NOT. LEGAL) GO TO 100
      IF (NUN .EQ. 15) POLCAL = .TRUE.
      M = LIMNO + 1
      WORK(3) = WORK(3) * FACT
      WORK(4) = WORK(4) * FACT
      WORK(5) = WORK(5) * FACT
      CALL CHKBIN(WORK(3),WORK(4),WORK(5),INTVL)
      NINNY = TYPE - 49
      GO TO (452, 454, 456), NINNY
C
C     ONE DIMENSIONAL HISTOGRAM
C
  452 LIM = LIMNO + INTVL + 3
      IF(LIM .GT. 50000) GO TO 470
      LIMOLD = LIMNO
      LIMNO = LIM
      IF(NUN .NE. 8) GO TO 460
C
C     Z HISTOGRAM OF LOSSES
C
      LOSS = LOSS + 1
      IF (LOSS .GT. 20) THEN
       LOSS = 20
       LIMNO = LIMOLD
       GO TO 470
      ENDIF
      XSTRT(LOSS) = WORK(3)
      XEND (LOSS) = WORK(4)
      LTHX (LOSS) = INTVL
      XBIN (LOSS) = WORK(5)
      NUNX (LOSS) = 8
      NUNY (LOSS) = 0
      NBLK (LOSS) = M
      KFLG (LOSS) = KFL
      GO TO 100
C
C     SET X SCALE (HORIZONTAL)
C
  454 ASTRT = WORK(3)
      AEND  = WORK(4)
      NA    = MIN0 (INTVL, 100)
      DA    = (WORK(4) - WORK(3)) / FLOAT(NA)
      NUNA = NUN
      IF(NUN - 8) 460, 100, 460
C
C     Y SCALE (VERTICAL)
C
  456 LIM = LIMNO + (NA + 1) * (INTVL + 1) + 5
      IF(LIM .GT. 50000) GO TO 470
      LIMOLD = LIMNO
      LIMNO = LIM
      IF(NUN .NE. 8 .AND. NUNA .NE. 8) GO TO 460
C
C     TWO DIMENSIONAL LOSS HISTOGRAM
C
      LOSS = LOSS + 1
      IF (LOSS .GT. 20) THEN
       LOSS = 20
       LIMNO = LIMOLD
       GO TO 470
      ENDIF
      XSTRT(LOSS) = ASTRT
      XEND (LOSS) = AEND
      LTHX (LOSS) = NA
      XBIN (LOSS) = DA
      NUNX (LOSS) = NUNA
      YSTRT(LOSS) = WORK(3)
      YEND (LOSS) = WORK(4)
      LTHY (LOSS) = INTVL
      YBIN (LOSS) = WORK(5)
      NUNY (LOSS) = NUN
      NBLK (LOSS) = M
      KFLG (LOSS) = KFL
      GO TO 100
C
C     STORE HISTOGRAM DATA TO DATA ARRAY
C
  460 IDATA(I) = 50
      NHISTS = NHISTS + 1
C
      IF (NHISTS .GT. 100) THEN
       NHISTS = 100
       LIMNO = LIMOLD
       GO TO 470
      ENDIF
      IF (TYPE.EQ.52 .AND. ITYPEO.EQ.51 .AND.
     X    NFL.EQ.0   .AND. NFLOLD.NE.0) WRITE(NOUT,5432)
 5432 FORMAT(' Warning - 51 card has a flag but following',
     X' 52 card does not.')
C
      IF (TYPE.EQ.52 .AND. NHISTS.EQ.1) THEN
       WRITE (NOUT, 5433)
 5433  FORMAT(' First histogram entry ignored - cannot be 52 code.')
       NHISTS = 0
       GO TO 100
      ENDIF
C
      MTYPE (NHISTS) = NINNY
      NENTRY(NHISTS) = M
      NCOOR (NHISTS) = NUN
      BEGIN (NHISTS) = WORK(3)
      END   (NHISTS) = WORK(4)
      STEP  (NHISTS) = WORK(5)
      INTVLS(NHISTS) = INTVL
      ZHIST (NHISTS) = ZC
      NFLAG (NHISTS) = ABS(NFL)
      KFLAG (NHISTS) = KFL
      LTAG  (NHISTS) = LABLE
      IF(LABLE.EQ.'    ') LTAG(NHISTS)=LTAGS
      UFLAG (NHISTS) = INVFL
      IF (NFL.LT.0) UFLAG(NHISTS) = .TRUE.
      ITYPEO = TYPE
      NFLOLD = NFL
      GO TO 500
C
C     HISTOGRAM SPACE OVERFLOW
C
  470 WRITE (NOUT, 1470)
      GO TO 100
 1470 FORMAT(' The histogram specified above caused a storage overflow,'
     A      ,' it has been ignored.')
C
C     FLAG FOR HISTOGRAM ENTRY
C
  480 IDATA(I) = TYPE
      IDATA(I+1) = NFL
      ZFLAG(NFL) = ZC
      GO TO 500
  490 ZC = ZC + L
      LTAGS = LABLE
  500 I = I + NU(TYPE)
      NEL = NEL + 1
      GO TO 100
C
C     PREPARE FOR DECAY CALCULATION
C
  550 DKFLAG = .TRUE.
      SEC = .TRUE.
      CALL DECAYP
      GO TO 100
C
C     DE/DX - DATA INPUT
C
  560 IF (SM .EQ. 0.0) THEN
       WRITE(NOUT,2100)
       CALL MENU(1)
      ENDIF
      CALL DEDXD
      GO TO 500
C
C     JUMP OVER COLLIMATOR ELEMENTS
C
  570 IDATA(I)   = TYPE
      DATA(I+1)  = WORK(2) * UNIT(8)
      DATA(I+2)  = WORK(3) * UNIT(1)
      DATA(I+3)  = WORK(4) * UNIT(3)
      DATA(I+4)  = WORK(5) * UNIT(1)
      DATA(I+5)  = WORK(6) * UNIT(3)
      IDATA(I+6) = WORK(7) + .01
      IDATA(I+7) = WORK(8) + .01
      GO TO 500
C
C     END OF INPUT DATA
C
  600 IF(FLUSH) GO TO 10
      I1 = I - 1
      NEL = NEL - 1
      IF (CONE) CALL SAVSLT
C
      IF (CONE .AND. DKFLAG) THEN
       WRITE (NOUT, 1102)
 1102  FORMAT(' No conical collimators with decay.')
       CALL MENU(1)
      END IF
C
      IF (IP .GT. 0) THEN
       WRITE (NOUT, 4323)
 4323  FORMAT(' Terminating card(s) of repeat section(s) missing.')
       CALL MENU(1)
      ENDIF
C
      WRITE (NOUT, 1103)
 1103 FORMAT(' SENTINEL')
      RETURN
      END
      SUBROUTINE SEXT
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC5/ SEC, CAP(3), MPA, THIRD
      LOGICAL         SEC, CAP, MPA, THIRD
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC15/ LL, KH2, KV2, KH, KV, KHL, KVL, RAY2(6),
     A                RH(4), RV(4), LILENS, SOLSEG
      LOGICAL LILENS, SOLSEG
      REAL LL, KH2, KV2, KH, KV, KHL, KVL
C
      RAY2(1) = RAY(1) + LL * RAY(2)
      RAY2(2) = RAY(2)
      RAY2(3) = RAY(3) + LL * RAY(4)
      RAY2(4) = RAY(4)
      IF (.NOT. SEC) GO TO 10
C
C     SECOND ORDER CONTRIBUTIONS
C
      C = LL * DATA(I+2) / P
      U = RAY(1) ** 2 - RAY(3) ** 2
      UP = LL * (RAY(1) * RAY(2) - RAY(3) * RAY(4))
      UPP = LL ** 2 * (RAY(2) ** 2 - RAY(4) ** 2)
      RAY2(1) = RAY2(1) - C * (0.5 * U + UP / 3.0 + UPP / 12.0) * LL
      RAY2(2) = RAY2(2) - C * (U + UP + UPP / 3.0)
      U = RAY(1) * RAY(3)
      UP = LL * (RAY(1) * RAY(4) + RAY(2) * RAY(3))
      UPP = LL ** 2 * RAY(2) * RAY(4)
      RAY2(3) = RAY2(3) + C * (U + UP / 3.0 + UPP / 6.0) * LL
      RAY2(4) = RAY2(4) + C * (U + U + UP + UPP / 1.5)
      IF (.NOT. THIRD) GO TO 10
C
C     THIRD ORDER CONTRIBUTIONS
C
      W2    = 2. * DATA(I+2) / P
      W22   = W2**2
      W22L3 = W22   * LL**3
      W22L4 = W22L3 * LL
      W22L5 = W22L4 * LL
      W22L6 = W22L5 * LL
      W22L7 = W22L6 * LL
      E1    =       W22L4 / 48.
      E2    =       W22L5 / 48.
      E3    =       W22L6 / 144.
      E4    =       W22L4 / 48.
      E5    =       W22L5 / 40.
      E6    =       W22L6 / 240.
      E7    =       W22L7 / 1008.
      E8    = -1. * W22L5 / 240.
      E9    =       W22L6 / 360.
      E10   =       W22L7 / 1008.
      E11   =       W22L3 / 12.
      E12   =  5. * W22L4 / 48.
      E13   =       W22L5 / 24.
      E14   =       W22L3 / 12.
      E15   =       W22L4 / 8.
      E16   =       W22L5 / 40.
      E17   =       W22L6 / 144.
      E18   = -1. * W22L4 / 48.
      E19   =       W22L5 / 60.
      E20   =       W22L6 / 144.
      B1    = RAY(1)**3
      B2    = RAY(1)**2 * RAY(2)
      B3    = RAY(1) * RAY(2)**2
      B4    = RAY(1) * RAY(3)**2
      B5    = RAY(1) * RAY(3) * RAY(4)
      B6    = RAY(1) * RAY(4)**2
      B7    = RAY(2)**3
      B8    = RAY(2) * RAY(3)**2
      B9    = RAY(2) * RAY(3) * RAY(4)
      B10   = RAY(2) * RAY(4)**2
      B11   = RAY(3)**3
      B12   = RAY(3)**2 * RAY(4)
      B13   = RAY(3) * RAY(4)**2
      B14   = RAY(3) * RAY(1)**2
      B15   = RAY(3) * RAY(1) * RAY(2)
      B16   = RAY(3) * RAY(2)**2
      B17   = RAY(4)**3
      B18   = RAY(4) * RAY(1)**2
      B19   = RAY(4) * RAY(1) * RAY(2)
      B20   = RAY(4) * RAY(2)**2
      SUM1  = E1 *B1  + E2 *B2  + E3 *B3  + E4 *B4  + E5 *B5
     X      + E6 *B6  + E7 *B7  + E8 *B8  + E9 *B9  + E10*B10
      SUM2  = E11*B1  + E12*B2  + E13*B3  + E14*B4  + E15*B5
     X      + E16*B6  + E17*B7  + E18*B8  + E19*B9  + E20*B10
      SUM3  = E1 *B11 + E2 *B12 + E3 *B13 + E4 *B14 + E5 *B15
     X      + E6 *B16 + E7 *B17 + E8 *B18 + E9 *B19 + E10*B20
      SUM4  = E11*B11 + E12*B12 + E13*B13 + E14*B14 + E15*B15
     X      + E16*B16 + E17*B17 + E18*B18 + E19*B19 + E20*B20
      RAY2(1) = RAY2(1) + SUM1
      RAY2(2) = RAY2(2) + SUM2
      RAY2(3) = RAY2(3) + SUM3
      RAY2(4) = RAY2(4) + SUM4
   10 CALL RSETR (RAY, RAY2)
      RETURN
      END

      INTEGER FUNCTION NEXTI(JJ,ITYPE)
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
C
      J = JJ
      ISH = NU(ITYPE)
  100 J = J + ISH
      IF (J .GT. NND) THEN
       NEXTI = -1
       RETURN
      ENDIF
      NTYPE = IDATA(J)
      IF (NTYPE .EQ. ITYPE) THEN
       NEXTI = J
       RETURN
      ELSE
       ISH = NU(NTYPE)
       GO TO 100
      ENDIF
C
      END

      SUBROUTINE getfield(x,y,z,FX,FY,FZ)
c
c     compute magnetic field values from type code 28.-cards
c
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC2/  UNIT(12)
      COMMON /BLOC3/ NIN, NOUT
      COMMON /BLOC11/ QAP(3), ELLIPS, HYPER
      LOGICAL         ELLIPS, HYPER
      COMMON /BLOC15A/ EQUAD, EBEND, BSCAL, BSCAL2, NSCAL, ISWITCH
      LOGICAL EQUAD, EBEND
      COMMON /BLOC60/ NCT
C
      LOGICAL OVERLAP
C
      DATA ITTC28 /0/
C
      R   = SQRT(X * X + Y * Y)
      RAP = ABS(DATA(I+8))
      ZL  = DATA(I+1)
      SF1 = BSCAL
      SF2 = BSCAL2
      OVERLAP = .FALSE.
C
C     RADIAL FIELD CLIPPING BECAUSE OF EXP-FUNCTION
C
      RA = R
      IF (RA .GT. RAP) RA = RAP
      R2 = RA * RA
      R4 = R2 * R2
C
      FR1 = DATA(I+5) * RA + DATA(I+6) * (EXP(DATA(I+7) * RA) - 1.0)
      FX1 = FR1 * X / R
      FY1 = FR1 * Y / R
      FZ1 = DATA(I+2) + DATA(I+3) * R2 + DATA(I+4) * R4 
C
      FX1 = FX1 * SF1
      FY1 = FY1 * SF1
      FZ1 = FZ1 * SF1
c
      IF (NCT .LE. ITTC28) THEN
        write(2,*) 'NEL=',NEL,' R=',R/UNIT(1),' Rclipped=',RA/UNIT(1)
        write(2,*)  'Br1=',DATA(I+5)*UNIT(1)/UNIT(9),
     1             ' Br2=',DATA(I+6)/UNIT(9),
     2             ' Br3=',DATA(I+7)*UNIT(1)
        write(2,*)  'Bz0=',DATA(I+2)/UNIT(9),
     1             ' Bz1=',DATA(I+3)*UNIT(1)**2/UNIT(9),
     2             ' Bz2=',DATA(I+4)*UNIT(1)**4/UNIT(9)
        write(2,*) 'Fz1=',FZ1/UNIT(9),'  Fr1=',FR1/UNIT(9)
      ENDIF
C
C     FIND NEXT 28. CARD
C
      J = NEXTI(I,28)
      IF (J .EQ. -1) GO TO 2000
C
C     IS LENGTH NEGATIVE (OVERLAPPING FIELD REGION)
C
      IF (DATA(J+1) .LT. 0.0) THEN
       OVERLAP = .TRUE.
       FR1A = DATA(J+5) * RA + DATA(J+6) * (EXP(DATA(J+7) * RA) - 1.0)
       FX1A = FR1A * X / R
       FY1A = FR1A * Y / R
       FZ1A = DATA(J+2) + DATA(J+3) * R2 + DATA(J+4) * R4
C
       FX1A = FX1A * SF2
       FY1A = FY1A * SF2
       FZ1A = FZ1A * SF2
       J2 = NEXTI(J,28)
       IF (J2 .EQ. -1) GO TO 2000
C
C      FIND NEXT POSITIVE LENGTH
C
       IF (DATA(J2+1) .GE. 0.0) THEN
        J = J2
        GO TO 100
       ELSE
        GO TO 2001
       ENDIF
      ENDIF
C
C     POSITIVE LENGTH     
C
 100  IF (DATA(J+1) .GE. 0.0) THEN
       FR2 = DATA(J+5) * RA + DATA(J+6) * (EXP(DATA(J+7) * RA) - 1.0)
       FX2 = FR2 * X / R
       FY2 = FR2 * Y / R
       FZ2 = DATA(J+2) + DATA(J+3) * R2 + DATA(J+4) * R4
C
       FX2 = FX2 * SF1
       FY2 = FY2 * SF1
       FZ2 = FZ2 * SF1
C
C      FIND NEXT CARD WITH NEGATIVE LENGTH
C
       IF (OVERLAP) THEN
        J2 = NEXTI(J,28)
        IF (J2 .EQ. -1) GO TO 2000
C
C       IF LAST CARD WITH NEGATIVE LENGTH WAS PREVIOUS ONE, TAKE ZEROS
C
        IF (DATA(J2+1) .GT. 0.) THEN
         FX2A = 0.0
         FY2A = 0.0
         FZ2A = 0.0
C
C        AND RESCALE (IF CARD BELONGS TO SECOND SOLENOID)
C        SIGNAL TO SOLORUKA TO PERFORM IT FOR THE REMAINING CODES
C
         ISWITCH = 0
         IF (NSCAL .EQ. 2) THEN
          FX2 = FX2 * SF2 / SF1
          FY2 = FY2 * SF2 / SF1
          FZ2 = FZ2 * SF2 / SF1
          ISWITCH = 1
         ENDIF
        ELSE
         J = J2
         FR2A = DATA(J+5) * RA + DATA(J+6) * (EXP(DATA(J+7) * RA) - 1.0)
         FX2A = FR2A * X / R
         FY2A = FR2A * Y / R
         FZ2A = DATA(J+2) + DATA(J+3) * R2 + DATA(J+4) * R4
C
         FX2A = FX2A * SF2
         FY2A = FY2A * SF2
         FZ2A = FZ2A * SF2
        ENDIF
       ENDIF
      ENDIF
C
      IF (NCT .LE. ITTC28) THEN 
       write(2,*) 'NEL=',NEL+1,' R=',R/UNIT(1),' Rclipped=',RA/UNIT(1)
       write(2,*)  'Br1=',DATA(J+5)*UNIT(1)/UNIT(9),
     1             ' Br2=',DATA(J+6)/UNIT(9),
     2             ' Br3=',DATA(J+7)*UNIT(1)
       write(2,*)  'Bz0=',DATA(J+2)/UNIT(9),
     1             ' Bz1=',DATA(J+3)*UNIT(1)**2/UNIT(9),
     2             ' Bz2=',DATA(J+4)*UNIT(1)**4/UNIT(9)
       write(2,*)  'Fz2=',FZ2/UNIT(9),'  Fr2=',FR2/UNIT(9)
      ENDIF
c
c     Linear interpolation
c
      zfrac = z / ZL
      FX = (1.-zfrac) * FX1 + zfrac * FX2
      FY = (1.-zfrac) * FY1 + zfrac * FY2
      FZ = (1.-zfrac) * FZ1 + zfrac * FZ2
c      
      IF (OVERLAP) THEN
       FXA = (1.-zfrac) * FX1A + zfrac * FX2A
       FYA = (1.-zfrac) * FY1A + zfrac * FY2A
       FZA = (1.-zfrac) * FZ1A + zfrac * FZ2A
       FX  = FX + FXA
       FY  = FY + FYA
       FZ  = FZ + FZA
      ENDIF
c
      IF (NCT .LE. ITTC28) THEN
       WRITE(2,*)  'x=', X/UNIT(1),
     1            ' y=', Y/UNIT(1),
     2            ' zfrac=',zfrac 
       WRITE(2,*)  'Bx=',FX/UNIT(9),
     1            ' By=',FY/UNIT(9),
     2            ' Bz=',FZ/UNIT(9)
       WRITE(2,*) ' '
      ENDIF
      return
C
 2000 WRITE(NOUT,1000)
 1000 FORMAT('Type-code 28: sequence inconsistent:')
      WRITE(NOUT,1010)
 1010 FORMAT('Type-code 28: e.g. last card with zero length missing.')
      GO TO 2010
C
 2001 WRITE(NOUT,1001)
 1001 FORMAT('Type-code 28: overlap sequence expects positive length.')
      GO TO 2010
C
 2010 CALL MENU(1)
      RETURN
C
      end

      SUBROUTINE SOLORUKA
C
C     TRACK CHARGED PARTICLES THROUGH A SOLENOID WITH RUNGE-KUTTA METHOD
C
c     PARTICLE TRACKING CODE by F. Foroughi, PSI
c     see: Equation of motion of a charged particle in a magnetic and
c     electrical field, PSI internal paper, May 1990
c     only magnetic part extracted by U. Rohrer, PSI, Feb. 2004
c
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC2/  UNIT(12)
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC15A/ EQUAD, EBEND, BSCAL, BSCAL2, NSCAL, ISWITCH
      LOGICAL EQUAD, EBEND
      COMMON /BLOC46/ SM, GAMMA0, BETA0, CHARGE
      COMMON /BLOC60/ NCT
C
      DATA ITTC28 /0/
C
      real x0(3), u0(3)
      real x(3),  u(3)
c
      real F(3)
c
      real k1x(3), k2x(3), k3x(3), k4x(3)
      real k1u(3), k2u(3), k3u(3), k4u(3)
c
      real kx(3), tx(3)
      real ku(3), tu(3)
c
c     LAST CARD ZERO LENGTH
c
      IF (DATA(I+1) .eq. 0.0) THEN
       NSCAL = 0
       RETURN
      ENDIF
c
      x0(1) = RAY(1)
      x0(2) = RAY(3)
      x0(3) = 0.0
      u0(1) = RAY(2)
      u0(2) = RAY(4)
      u0(3) = SQRT(1. - RAY(2) * RAY(2) - RAY(4) * RAY(4))
C
c     zeroth step
c
      h = DATA(I+1) / u0(3)
      do 100 ii = 1, 3
        k1x(ii) = h * u0(ii)
  100 continue
      h1 = h * CHARGE / (33.356 * P)
c
c     first step
c
      call getfield(x0(1),x0(2),x0(3), F(1),F(2),F(3))
c
      k1u(1) = h1 * (F(3) * u0(2) - F(2) * u0(3))
      k1u(2) = h1 * (F(1) * u0(3) - F(3) * u0(1))
      k1u(3) = h1 * (F(2) * u0(1) - F(1) * u0(2))
      do 101 ii = 1, 3
        tu(ii)  = u0(ii) + k1u(ii)
        tx(ii)  = x0(ii) + k1x(ii)
        k2x(ii) = h * tu(ii)
  101 continue
c
c     second step
c
      call getfield(tx(1),tx(2),tx(3), F(1),F(2),F(3))
c
      k2u(1) = h1 * (F(3) * tu(2) - F(2) * tu(3))
      k2u(2) = h1 * (F(1) * tu(3) - F(3) * tu(1))
      k2u(3) = h1 * (F(2) * tu(1) - F(1) * tu(2))
      do 102 ii = 1, 3
        tu(ii)  = u0(ii) + k2u(ii)
        tx(ii)  = x0(ii) + k2x(ii)
        k3x(ii) = h * tu(ii)
  102 continue
c
c     third step
c
      call getfield(tx(1),tx(2),tx(3), F(1),F(2),F(3))
c
      k3u(1) = h1 * (F(3) * tu(2) - F(2) * tu(3))
      k3u(2) = h1 * (F(1) * tu(3) - F(3) * tu(1))
      k3u(3) = h1 * (F(2) * tu(1) - F(1) * tu(2))
      do 103 ii = 1, 3
        tu(ii)  = u0(ii) + 0.5 * k1u(ii)
        tx(ii)  = x0(ii) + 0.5 * k1x(ii)
        k4x(ii) = h * tu(ii)
  103 continue
c
c     forth step
c
      call getfield(tx(1),tx(2),tx(3), F(1),F(2),F(3))
c
      k4u(1) = h1 * (F(3) * tu(2) - F(2) * tu(3))
      k4u(2) = h1 * (F(1) * tu(3) - F(3) * tu(1))
      k4u(3) = h1 * (F(2) * tu(1) - F(1) * tu(2))
      do 104 ii = 1, 3
        kx(ii)  = (k1x(ii) + 4.0 * k4x(ii) + k3x(ii)) / 6.
        ku(ii)  = (k1u(ii) + 4.0 * k4u(ii) + k3u(ii)) / 6.
        x(ii)   = x0(ii) + kx(ii)
        u(ii)   = u0(ii) + ku(ii)
  104 continue
c
      RAY(1) = x(1)
      RAY(2) = u(1)
      RAY(3) = x(2)
      RAY(4) = u(2)
c
      IF (NCT .LE. ITTC28) THEN
       WRITE(2,1000) NEL, RAY(1)/UNIT(1),RAY(3)/UNIT(1),
     1                    RAY(2)/UNIT(2),RAY(4)/UNIT(2)
 1000  FORMAT('NEL=',I3,' x='  ,F7.2,' y=',  F7.2,
     1                  ' x''=',F7.2,' y''=',F7.2)
      ENDIF
C
C     GETFIELD REQUESTS A SWITCH TO SCALING FACTOR 2
C
      IF (ISWITCH .EQ. 1) BSCAL = BSCAL2
C
      RETURN
      END

      SUBROUTINE SOLO
C
C     TRACK CHARGED PARTICLES THROUGH A SOLENOID.
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC15/ LL, KH2, KV2, KH, KV, KHL, KVL, RAY2(6),
     A                RH(4), RV(4), LILENS, SOLSEG
      LOGICAL LILENS, SOLSEG
      REAL LL, KH2, KV2, KH, KV, KHL, KVL
C
      KH = DATA(I+2) / P
      IF (LL .EQ. 0.) THEN
C
C     ENTRANCE OR EXIT FRINGE FIELD ALONE (LL = 0.)
C
       IF (SOLSEG) KH  = - KH
       RAY(2) = RAY(2) + KH * RAY(3)
       RAY(4) = RAY(4) - KH * RAY(1)
       IF (SOLSEG) THEN
        SOLSEG = .FALSE.
       ELSE
        SOLSEG = .TRUE.
       ENDIF
       RETURN
C
      ELSE
       IF (SOLSEG) KH = 2. * KH
       KHL  = LL * KH
       C    = COS(KHL)
       S    = SIN(KHL)
       SK   = S * KH
       IF (KHL .LT. 0.01) THEN
        SOK = LL * (1.0 - KHL * KHL / 6.0)
       ELSE
        SOK = S / KH
       ENDIF
      ENDIF
      IF (SOLSEG) THEN
C
C     HOMOGENEOUS REGION
C
       BBB     = (1. - C) / KH
       RAY2(1) = RAY(1) + SOK * RAY(2) + BBB * RAY(4)
       RAY2(2) =          C   * RAY(2) + S   * RAY(4)
       RAY2(3) = RAY(3) + SOK * RAY(4) - BBB * RAY(2)
       RAY2(4) =          C   * RAY(4) - S   * RAY(2)
       CALL RSETR(RAY,RAY2)
      ELSE
C
C     WITH FRINGE FIELD (DEFAULT)
C
       RAY2(1) =   C  * RAY(1)  + SOK * RAY(2)
       RAY2(2) = - SK * RAY(1)  + C   * RAY(2)
       RAY2(3) =   C  * RAY(3)  + SOK * RAY(4)
       RAY2(4) = - SK * RAY(3)  + C   * RAY(4)
       RAY(1)  =   C  * RAY2(1) + S   * RAY2(3)
       RAY(3)  = - S  * RAY2(1) + C   * RAY2(3)
       RAY(2)  =   C  * RAY2(2) + S   * RAY2(4)
       RAY(4)  = - S  * RAY2(2) + C   * RAY2(4)
      ENDIF
C
      RETURN
      END
      LOGICAL FUNCTION SOSTOP(LFLAG)
C
      COMMON /BLOC5/ SEC, CAP(3), MPA, THIRD
      LOGICAL         SEC, CAP, MPA, THIRD
      COMMON /BLOC11/ QAP(3), ELLIPS, HYPER
      LOGICAL         ELLIPS, HYPER
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
C
C     ELLIPTICAL APERTURES FOR SOLENOID AND SEXTUPOLE
C
      IF (.NOT.CAP(LFLAG+1) .OR. .NOT.ELLIPS) THEN
      SOSTOP = .FALSE.
      RETURN
      ELSE IF((RAY(1)/QAP(1))**2 + (RAY(3)/QAP(2))**2 .GT. 1.0) THEN
      SOSTOP = .TRUE.
      RETURN
      ELSE
      SOSTOP = .FALSE.
      RETURN
      END IF
      END

      LOGICAL FUNCTION SOSTOP2(LFLAG)
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC5/ SEC, CAP(3), MPA, THIRD
      LOGICAL         SEC, CAP, MPA, THIRD
      COMMON /BLOC11/ QAP(3), ELLIPS, HYPER
      LOGICAL         ELLIPS, HYPER
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
C
C     APERTURES FOR SOLENOID (TYPE CODE 28, RUNGE-KUTTA)
C
      IF ( .NOT. CAP(LFLAG+1) ) GO TO 30
      IF (DATA(I+8) .LT. 0.0) GO TO 30 
      IF ((RAY(1)/DATA(I+8))**2+(RAY(3)/DATA(I+8))**2 .GT. 1.0) GO TO 40
   30 SOSTOP2 = .FALSE.
      RETURN
   40 SOSTOP2 = .TRUE.
      RETURN
      END

      SUBROUTINE SPSHLR(NM,LFLAG)
C
C     CALLED FROM SUBROUTINE RAYRUN
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC2/  UNIT(12)
      COMMON /BLOC2A/ NAME(12), NOM(12), NOM1(4), DSTOR(20)
      CHARACTER*4     NAME, NOM, NOM1, DSTOR
      COMMON /BLOC3/ NIN, NOUT
      COMMON /BLOC4/ RAYMAX(6), PBEAM, P0, NORAYS
      COMMON /BLOC10/ APB(2), LAYL, LAYX, RAB1, RAB2, FACE
      REAL            LAYL, LAYX
      COMMON /BLOC11/ QAP(3), ELLIPS, HYPER
      LOGICAL         ELLIPS, HYPER
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC15/ LL, KH2, KV2, KH, KV, KHL, KVL, RAY2(6),
     A                RH(4), RV(4), LILENS, SOLSEG
      LOGICAL LILENS, SOLSEG
      REAL LL, KH2, KV2, KH, KV, KHL, KVL
      COMMON /BLOC15A/ EQUAD, EBEND, BSCAL, BSCAL2, NSCAL, ISWITCH
      LOGICAL EQUAD, EBEND
      COMMON /BLOC19/ CONE, ISTOR(100), SLIT1(100), SLIT2(100), NSLIT,
     A                ORIG, ISLT, IFF, IFG, A, B, RECTA
      LOGICAL CONE, ORIG, RECTA
      COMMON /BLOC20/ BALLS, BDIAM, WTHIK
      LOGICAL         BALLS
      COMMON /BLOC21/ PIPES, DIST, PTHIK, PRAD, PPER, TTHIK
      LOGICAL         PIPES
      COMMON /BLOC22/ ODIMX, ODIMY, OUTREC, OUTDIM
      LOGICAL OUTREC, OUTDIM
      COMMON /BLOC44/ LINV, SINV, SINV2, MULTSC
      LOGICAL LINV, SINV, SINV2, MULTSC
      COMMON /BLOC46/ SM, GAMMA0, BETA0, CHARGE
      COMMON /BLOC52/ W, POLX(0:2), POLY(0:2), POLZ(0:2), POLCAL
      LOGICAL POLCAL
      COMMON /BLOC60/ NCT
      COMMON /BLOC61/ DBQ, DBQQ, OLDG, DPP0, P0SV
C
      INTEGER   REMUNIT(10)
      SAVE      REMUNIT   
      INTEGER   UNIT2
      SAVE      UNIT2
      CHARACTER FILNAM*10
      LOGICAL   FIRST
      SAVE      FIRST
      DATA      FIRST  /.TRUE./
      DATA      FILNAM /'FOR000.DAT'/
      DATA      REMUNIT /10*0/
C
C     HORIZONTAL AND VERTICAL APERTURES
C
      IF (NM.EQ.4 .OR. NM.EQ.5) THEN
       APB(NM-3) = DATA(I+2)
       RETURN
C
C     ELLIPTICAL APERTURES
C
      ELSE IF (NM.EQ.100) THEN
       ELLIPS = .TRUE.
       QAP(1) = DATA(I+2)
       QAP(2) = DATA(I+3)
       RETURN
C
C     HYPERBOLIC APERTURES
C
      ELSE IF (NM.EQ.101) THEN
       HYPER = .TRUE.
       QAP(3) = DATA(I+2)
       RETURN
C
C     NEW CENTRAL MOMENTUM P0
C
      ELSE IF (NM.EQ.11) THEN
       P0 = DATA(I+2)
       IF (SM .NE. 0.) THEN
        BG0 = P0 / SM
        GAMMA0 = SQRT( 1. + BG0 ** 2 )
        BETA0 = BG0 / GAMMA0
       ENDIF
       RAY(6) = (P - P0) / P0
       RETURN
C
C     PARTICLE CHARGE IN ELECTRON UNITS
C
      ELSE IF(NM.EQ.29) THEN
       CHARGE = DATA(I+2)
       RETURN
C
C     RANDOM AMPLITUDE FOR QUADS
C
      ELSE IF (NM.EQ.35) THEN
       DBQ = DATA(I+2)
       OLDG = 0.123456789E+15
       RETURN
C
C     RANDOM AMPLITUDE FOR P0
C
      ELSE IF (NM.EQ.36) THEN
       DPP0 = DATA(I+2) * UNIT(6)
       RETURN
C
C     FIELD SCALING FACTOR FOR TYPE CODE 28 (SOLENOID) TRACKING
C
      ELSE IF (NM .EQ. 50) THEN
       BSCAL = DATA(I+2)
       RETURN
C
      ELSE IF (NM .EQ. 51) THEN
       BSCAL2 = DATA(I+2)
       RETURN
C
C     SLIT CONTOURES ARE TO BE TAKEN RECTANGULAR
C
      ELSE IF (NM.EQ.162) THEN
       RECTA = .TRUE.
       RETURN
C
C     SLIT CONTOURES ARE TO BE TAKEN ELLIPITCAL
C
      ELSE IF (NM.EQ.163) THEN
       RECTA = .FALSE.
       RETURN
C
C     SLITS ARE TO BE TAKEN INVERSE
C
      ELSE IF (NM.EQ.160) THEN
       LINV= .TRUE.
       RETURN
C
C     SLITS ARE TO BE TAKEN NORMAL
C
      ELSE IF (NM.EQ.161) THEN
       LINV= .FALSE.
       RETURN
C
C     SIGN OF X'- OR Y'-SHIFTS DEPEND ON X- OR Y-SIGN
C
      ELSE IF (NM.EQ.170) THEN
       SINV= .TRUE.
       RETURN
C
C     SHIFTS ARE TO BE TAKEN NORMAL
C
      ELSE IF (NM.EQ.171) THEN
       SINV= .FALSE.
       SINV2= .FALSE.
       RETURN
C
C     X' AND Y' SHIFTS APPLY ONLY FOR POSITIVE X AND Y
C
      ELSE IF (NM.EQ.172) THEN
       SINV2= .TRUE.
       RETURN
C
C     BENDS ASE USUAL
C
      ELSE IF (NM.EQ.93) THEN
       EBEND = .FALSE.
       RETURN
C
C     BENDS ARE ELECTROSTATIC PRISMS
C
      ELSE IF (NM.EQ.94) THEN
       EBEND = .TRUE.
       RETURN
C
C     QUADS ASE USUAL
C
      ELSE IF (NM.EQ.95) THEN
       EQUAD = .FALSE.
       RETURN
C
C     QUADS ARE ELECTROSTATIC QUADS
C
      ELSE IF (NM.EQ.96) THEN
       EQUAD = .TRUE.
       RETURN
C
C     QUADS ASE USUAL
C
      ELSE IF (NM.EQ.97) THEN
       LILENS = .FALSE.
       RETURN
C
C     QUADS HAVE TO BEHAVE LIKE LITHIUM LENSES
C
      ELSE IF (NM.EQ.98) THEN
       LILENS = .TRUE.
       RETURN
C
C     OUTPUT ONE RAY ONTO UNIT2 (UP TO 10 DIFFERENT UNITS)
C     FIRST TIME OPEN FILE
C
      ELSE IF (NM.EQ.180 .OR. NM.EQ.181) THEN

       IF (FIRST) THEN
         DO 44 K = 1, 10
           REMUNIT(K) = 0
   44    CONTINUE
         FIRST = .FALSE.
       ENDIF

       UNIT2=IDATA(I+2)
       DO 48 K=1,10
        IF (REMUNIT(K) .EQ. UNIT2) GO TO 50
        IF (REMUNIT(K) .EQ. 0) GO TO 49
   48  CONTINUE
       RETURN
   49  CONTINUE
       REMUNIT(K) = UNIT2
       CALL UNIFIL(FILNAM,UNIT2)
       OPEN(UNIT=UNIT2,FILE=FILNAM,FORM='FORMATTED',
     X      ACCESS='APPEND')
C
   50  IF (LFLAG .EQ. IDATA(I+3)/100) THEN
        PX=P/UNIT(11)
        RAYX1=RAY(1)/UNIT(1)
        RAYX2=RAY(2)/UNIT(2)
        RAYX3=RAY(3)/UNIT(3)
        RAYX4=RAY(4)/UNIT(4)
        IF (NM .EQ. 180)
     X  WRITE(UNIT2,2000) RAYX1, RAYX2, RAYX3, RAYX4, PX, W, POLZ(LFLAG)
        IF (NM .EQ. 181)
     X  WRITE(UNIT2,2001) RAYX1, RAYX2, RAYX3, RAYX4, PX, W, NCT
 2000   FORMAT(7F12.5)
 2001   FORMAT(6F12.5,I12)
       ENDIF
       RETURN
C
C     MULTIPLE SCATTERING
C
      ELSE IF (NM.EQ.165) THEN
       MULTSC= .TRUE.
       RETURN
C
C     RMS SCATTERING
C
      ELSE IF (NM.EQ.166) THEN
       MULTSC= .FALSE.
       RETURN
C
C     INCREMENT SLIT X AND/OR Y DIMENSIONS (CONE)
C
      ELSE IF (NM.EQ.177) THEN
       IF (ISLT .EQ. 0) GO TO 100
       DATA(ISLT+2) = A + DATA(I+2) * UNIT(IFF)
       IF (IFG .NE. 0) DATA(ISLT+4) = B + DATA(I+3) * UNIT(IFG)
       ORIG = .FALSE.
       RETURN
  100  WRITE(NOUT,110)
  110  FORMAT(' The 16. 177. DX. DY. card has to be preceeded by
     X a slit card.')
       CALL MENU(1)
C
C     OUTER DIMENSIONS OF COLLIMATOR
C
      ELSE IF (NM.EQ.176) THEN
       IF (DATA(I+2).EQ.0.0 .AND. DATA(I+3).EQ.0.0) THEN
        OUTDIM = .FALSE.
       ELSE IF (DATA(I+2) .EQ. -1.) THEN
        OUTDIM = .TRUE.
        OUTREC = .TRUE.
        ODIMX  = DATA(I+3) * UNIT(1)
        IF (ODIMY .EQ. 0.0) ODIMY = 1.E+10
       ELSE IF (DATA(I+2) .EQ. -3.) THEN
        OUTDIM = .TRUE.
        OUTREC = .TRUE.
        ODIMY  = DATA(I+3) * UNIT(3)
        IF (ODIMX .EQ. 0.0) ODIMX = 1.E+10
       ELSE IF (DATA(I+2).GT.0.0 .AND. DATA(I+3).GT.0.0) THEN
        OUTDIM = .TRUE.
        OUTREC = .FALSE.
        ODIMX  = DATA(I+2) * UNIT(1)
        ODIMY  = DATA(I+3) * UNIT(3)
       ELSE
        STOP ' wrong parameters on 16. 176. xx yy card.'
       ENDIF
C
C     FOR COLLIMATORS FILLED WITH BALLS
C
      ELSE IF (NM.EQ.178) THEN
       IF (DATA(I+2).EQ.0.0 .AND. DATA(I+3).EQ.0.0) THEN
        BALLS = .FALSE.
       ELSE
        BALLS = .TRUE.
        BDIAM = DATA(I+3) * UNIT(1)
        WTHIK = DATA(I+2) * UNIT(1)
       ENDIF
      RETURN
C
C     FOR COLLIMATORS CUT BY COOLING PIPES
C
      ELSE IF (NM.EQ.179) THEN
       IF (DATA(I+2).EQ.0.0 .AND. DATA(I+3).EQ.0.0) THEN
        PIPES = .FALSE.
        IPOIN = 0
       ELSE
        IF (.NOT.PIPES) THEN
         IPOIN = 0
         PIPES = .TRUE.
        ENDIF
        IPOIN = IPOIN + 1
        IF (IPOIN .EQ. 1) THEN
         DIST  = DATA(I+2) * UNIT(1)
         PTHIK = DATA(I+3) * UNIT(1)
        ELSE IF (IPOIN .EQ. 2) THEN
         PPER  = DATA(I+2) * UNIT(1)
         PRAD  = DATA(I+3) * UNIT(1)
        ELSE IF (IPOIN .EQ. 3) THEN
         TTHIK = DATA(I+2) * UNIT(1)
        ELSE
         STOP 'more than three 16. 179. x. y. ; cards'
        ENDIF
       ENDIF
      RETURN
C
C     ALL OTHERS
C
      ELSE
       RETURN
      END IF
      END
      SUBROUTINE SPSHLS(NM,*,*)
C
C     CALLED FROM SUBROUTINE SETUP
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC2/  UNIT(12)
      COMMON /BLOC2A/ NAME(12), NOM(12), NOM1(4), DSTOR(20)
      CHARACTER*4     NAME, NOM, NOM1, DSTOR
      COMMON /BLOC3/ NIN, NOUT
      COMMON /BLOC4/ RAYMAX(6), PBEAM, P0, NORAYS
      COMMON /BLOC9/ L, H, N, BDB
      REAL            L, N
      COMMON /BLOC10/ APB(2), LAYL, LAYX, RAB1, RAB2, FACE
      REAL            LAYL, LAYX
      COMMON /BLOC11/ QAP(3), ELLIPS, HYPER
      LOGICAL         ELLIPS, HYPER
      COMMON /BLOC12/ VALUE(100), XMOM(100), XMOM2(100), NFLAG(100),
     A                SET(100), KFLAG(100), IFLAG(3,0:9), ZFLAG(9),
     A                WZ(100), UFLAG(100), INVFL, ZC
      LOGICAL SET, IFLAG, UFLAG, INVFL
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC15A/ EQUAD, EBEND, BSCAL, BSCAL2, NSCAL, ISWITCH
      LOGICAL EQUAD, EBEND
      COMMON /BLOC16/ ISTOP(3,9998)
      REAL ISTOP
      COMMON /BLO16A/ KPART(3)
      CHARACTER*4     KPART
      COMMON /BLOC19/ CONE, ISTOR(100), SLIT1(100), SLIT2(100), NSLIT,
     A                ORIG, ISLT, IFF, IFG, A, B, RECTA
      LOGICAL CONE, ORIG, RECTA
      COMMON /BLOC20/ BALLS, BDIAM, WTHIK
      LOGICAL         BALLS
      COMMON /BLOC21/ PIPES, DIST, PTHIK, PRAD, PPER, TTHIK
      LOGICAL         PIPES
      COMMON /BLOC22/ ODIMX, ODIMY, OUTREC, OUTDIM
      LOGICAL OUTREC, OUTDIM
      COMMON /BLOC23/ NCOUNT
      COMMON /BLOC41/ LW, FLUSH, INDIC, NTYPE, LENGTH,
     A                NWORD, NVARY, DATUM(30), VARY(30)
      INTEGER VARY
      LOGICAL FLUSH
      COMMON /BLO41A/ IMAGE(80), LABLE
      CHARACTER       IMAGE*1, LABLE*4
      COMMON /BLOC44/ LINV, SINV, SINV2, MULTSC
      LOGICAL LINV, SINV, SINV2, MULTSC
      COMMON /BLOC45/ CHIX, SNCHIX, CSCHX2, CHIY, SNCHIY,
     A                CSCHY2, GAUSS, VOL4
      LOGICAL GAUSS, VOL4
      COMMON /BLOC46/ SM, GAMMA0, BETA0, CHARGE
      COMMON /BLOC47/ IRAN
      COMMON /BLOC48/ XI1, XI2, XI3, XI4
      COMMON /BLOC50/ NOSUP
      COMMON /BLO50A/ LABSUP(20)
      CHARACTER*4     LABSUP
      COMMON /BLOC51/ IOCASE(5), IOUNIT(5), IONUM, UNIT1
      INTEGER UNIT1
      COMMON /BLOC53/ ENERGY
      LOGICAL ENERGY
      COMMON /BLOC54/ BINOM, XM, YM, ZM, XNORM, YNORM, ZNORM
      LOGICAL BINOM
      COMMON /BLOC62/ IUNIT3RD, NUMLIM, ZZ
      COMMON /hal/ halton, ipn(10) ,iseries(10)
      LOGICAL HALTON
C
      REAL WORK(30)
      EQUIVALENCE(WORK, DATUM)
      CHARACTER*10 FILNAM
      DATA FILNAM  /'FOR000.DAT'/
C
C     DEFINE SECOND ORDER MEASURE OF BEND FIELD INHOMOGENEITY
C
      IF (NM.EQ.1) THEN
       BDB = WORK(3)/UNIT(1)**2
       RETURN 1
C
C     DEFINE MASS OF PARTICLE
C
      ELSE IF (NM.EQ.3) THEN
       SM=WORK(3)*UNIT(10)*0.0005108
       RETURN 1
C
C     DEFINE HORIZONTAL AND VERTICAL HALF APERTURES
C
      ELSE IF (NM.EQ.4 .OR. NM.EQ.5) THEN
       APB(NM-3) = WORK(3)*UNIT(2*NM-7)
       IDATA(I+1) = NM
       DATA(I+2) = APB(NM-3)
       RETURN 2
C
C     Z FOR HISTOGRAMMING
C
      ELSE IF (NM.EQ.6) THEN
       ZC = WORK(3) * UNIT(8)
       RETURN 1
C
C     K1 COEFFICIENT
C
      ELSE IF (NM.EQ.7) THEN
       LAYL = WORK(3)
       RETURN 1
C
C     K2 COEFFICIENT
C
      ELSE IF (NM.EQ.8) THEN
       LAYX = WORK(3)
       RETURN 1
C
C     FORCE DECAY LENGTH
C
      ELSE IF (NM.EQ.9) THEN
       ZMAX = WORK(3) * UNIT(8)
       RETURN 1
C
C     DEFINE P0 OR E0
C
      ELSE IF (NM.EQ.11) THEN
       IF (ENERGY) THEN
        E0 = WORK(3) * UNIT(12)
        P0 = SQRT(E0 * (2.0 * SM + E0))
       ELSE
        P0 = WORK(3) * UNIT(11)
       ENDIF
       IDATA(I+1) = NM
       DATA(I+2) = P0
       RETURN 2
C
C     ENTRANCE FACE CURVATURE
C
      ELSE IF (NM.EQ.12) THEN
       RAB1 = WORK(3)/UNIT(8)
       RETURN 1
C
C     EXIT FACE CURVATURE
C
      ELSE IF (NM.EQ.13) THEN
       RAB2 = WORK(3)/UNIT(8)
       RETURN 1
C
C     ELLIPTICAL QUAD APERTUE
C
      ELSE IF (NM.EQ.100) THEN
       IDATA(I+1) = NM
       DATA(I+2) = WORK(3)*UNIT(1)
       DATA(I+3) = WORK(4)*UNIT(3)
       RETURN 2
C
C     DIFFERENT FLAGS
C
      ELSE IF (NM.EQ.93  .OR. NM.EQ.94
     X   .OR.  NM.EQ.95  .OR. NM.EQ.96
     X   .OR.  NM.EQ.97  .OR. NM.EQ.98  .OR. NM.EQ.160 .OR. NM.EQ.161
     X   .OR.  NM.EQ.162 .OR. NM.EQ.163 .OR. NM.EQ.170 .OR. NM.EQ.171
     X   .OR.  NM.EQ.172) THEN
       IDATA(I+1) = NM
       IF (NM.EQ.93) EBEND = .FALSE.
       IF (NM.EQ.94) EBEND = .TRUE.
       IF (NM.EQ.95) EQUAD = .FALSE.
       IF (NM.EQ.96) EQUAD = .TRUE.
       RETURN 2
C
C     OUTPUT RAYS ON FILE
C     WORK(3) = I/O-UNIT
C     WORK(4) = PARTICLE ID (0, 1, 2)
C
      ELSE IF (NM.EQ.180 .OR. NM.EQ.181 .OR. NM.EQ.185) THEN
       IDATA(I+1) = NM
       IDATA(I+2) = WORK(3)+0.001
       IDATA(I+3) = WORK(4)+0.001
       RETURN 2
C
C     FOR HISTOGRAM STORAGE ON FILE
C
      ELSE IF (NM .EQ. 190) THEN
       IONUM         = MIN(IONUM+1,5)
       IOCASE(IONUM) = WORK(3) + SIGN(0.001,WORK(3))
       IOUNIT(IONUM) = WORK(4) + 0.001
       RETURN 1
C
C     FILE FOR 3RD ORDER STORAGE
C
      ELSE IF (NM .EQ. 191) THEN
       IUNIT3RD = WORK(3) + 0.001
       NUMLIM = WORK(4) + 0.001
       CALL UNIFIL(FILNAM,IUNIT3RD)
       OPEN(UNIT=IUNIT3RD,FILE=FILNAM,FORM='FORMATTED',
     X      STATUS='UNKNOWN')
       REWIND(UNIT=IUNIT3RD)
       WRITE(IUNIT3RD,*) 'Turtle third order info:'
       WRITE(IUNIT3RD,*) '========================'
       RETURN 1

C
C     HYPERBOLIC QUAD APERTURES
C
      ELSE IF (NM.EQ.101) THEN
       IDATA(I+1) = NM
       DATA(I+2) = 0.5 * (WORK(3) * UNIT(1)) ** 2
       RETURN 2
C
C     NAMES FOR DAUGHTERS
C
      ELSE IF (NM.GE.200) THEN
       KPART(NM-199) = LABLE
       RETURN 1
C
C     TAKE MULTIPLE SCATTERING
C
      ELSE IF (NM.EQ.165) THEN
       MULTSC=.TRUE.
       IDATA(I+1) = NM
       RETURN 2
C
C     TAKE RMS ADDITION FOR SLIT SCATTERING
C
      ELSE IF (NM.EQ.166) THEN
       MULTSC=.FALSE.
       IDATA(I+1) = NM
       RETURN 2
C
C     FOR SUPPRESSION OF ENTRIES IN LOSS DIAGRAMME
C
      ELSE IF (NM.EQ.195) THEN
       NOSUP=NOSUP+1
       LABSUP(NOSUP)=LABLE
       RETURN 1
C
C     TAKE ISOTROPIC DISTRIBUTION FOR PARTICLES
C
      ELSE IF (NM.EQ.20) THEN
       GAUSS=.FALSE.
       RETURN 1
C
C     TAKE 4VOL DISTRIBUTION FOR PARTICLES
C
      ELSE IF(NM.EQ.24) THEN
       VOL4=.TRUE.
       GAUSS=.FALSE.
       RETURN 1
C
C     FRINGE FIELD INTEGRALS I1 TO I4 FOR QUADS
C
      ELSE IF(NM.EQ.25) THEN
       XI1 = WORK(3)
       RETURN 1
      ELSE IF(NM.EQ.26) THEN
       XI2 = WORK(3)
       RETURN 1
      ELSE IF(NM.EQ.27) THEN
       XI3 = WORK(3)
       RETURN 1
      ELSE IF(NM.EQ.28) THEN
       XI4 = WORK(3)
       RETURN 1
C
C     PARTICLE CHARGE IN ELECTRON UNITS
C
      ELSE IF (NM.EQ.29) THEN
       CHARGE = WORK(3)
       IDATA(I+1) = NM
       DATA(I+2) = CHARGE
       RETURN 2
C
C     SET SEED FOR RANDOM GENERATOR
C
      ELSE IF (NM.EQ.30) THEN
       IRAN=WORK(3)+SIGN(0.001,WORK(3))
       RETURN 1
C
C     USE HALTON GENERATOR IN EMIT INSTEAD OF RANDOM GENERATOR
C
      ELSE IF (NM.EQ.31) THEN
       HALTON = .TRUE.
       RETURN 1   
C
C     RANDOM FIELD AMPLIDUDE FOR QUADS AND P0
C
      ELSE IF (NM.EQ.35 .OR. NM.EQ.36) THEN
       IDATA(I+1)=NM
       DATA(I+2)=WORK(3)
       RETURN 2
C
C     TYPE CODE 28 (SOLENOID) FIELD SCALING
C
      ELSE IF (NM .EQ. 50) THEN
       IDATA(I+1)=NM
       DATA(I+2)=WORK(3)
       RETURN 2
C
      ELSE IF (NM .EQ. 51) THEN
       IDATA(I+1)=NM
       DATA(I+2)=WORK(3)
       RETURN 2
C
C     FOR OUTER APERTURES
C
      ELSE IF (NM.EQ.176) THEN
       IDATA(I+1)=NM
       DATA(I+2)=WORK(3)
       DATA(I+3)=WORK(4)
       RETURN 2
C
C     FOR CONICAL APERTURES
C
      ELSE IF (NM.EQ.177) THEN
       IDATA(I+1)=NM
       DATA(I+2)=WORK(3)
       DATA(I+3)=WORK(4)
       CONE=.TRUE.
       RETURN 2
C
C     FOR COLLIMATOR FILLED WITH BALLS
C
      ELSE IF (NM.EQ.178) THEN
       IDATA(I+1)=NM
       DATA(I+2)=WORK(3)
       DATA(I+3)=WORK(4)
       BALLS=.TRUE.
       RETURN 2
C
C     FOR COLLIMATOR FILLED WITH BALLS
C
      ELSE IF (NM.EQ.179) THEN
       IDATA(I+1)=NM
       DATA(I+2)=WORK(3)
       DATA(I+3)=WORK(4)
       PIPES=.TRUE.
       RETURN 2
C
C     SET TO INVERS HISTOGRAM FLAGGING
C
      ELSE IF (NM.EQ.196) THEN
       INVFL = .TRUE.
       RETURN 1
C
C     RESET TO NORMAL HISTOGRAM FLAGGING
C
      ELSE IF (NM.EQ.197) THEN
       INVFL = .FALSE.
       RETURN 1
C
C     CONCATINATION FACTOR FOR SLIT LOSS SUMARY IN SBR APLIM
C
      ELSE IF (NM.EQ.198) THEN
       IDATA(I+1)=NM
       DATA(I+2)=WORK(3)
       RETURN 2
C
C     ENERGY INSTEAD OF MOMENTUM
C
      ELSE IF (NM.EQ.10) THEN
       ENERGY=.TRUE.
       RETURN 1
C
C     M FOR BINOMIAL DISTRIBUTION IN (X,X')
C
      ELSE IF (NM.EQ.21) THEN
       BINOM = .TRUE.
       XM = ABS(WORK(3))
       XNORM = SQRT((XM+1.)/2.)
       IF(YM.EQ.0.) THEN
        YM = XM
        YNORM = XNORM
       ENDIF
       IF(ZM.EQ.0.) THEN
        ZM = XM
        ZNORM = XNORM
       ENDIF
       RETURN 1
C
C     M FOR BINOMIAL DISTRIBUTION IN (Y,Y')
C
      ELSE IF (NM.EQ.22) THEN
       BINOM = .TRUE.
       YM = ABS(WORK(3))
       YNORM = SQRT((YM+1.)/2.)
       IF(XM.EQ.0.) THEN
        XM = YM
        XNORM = YNORM
       ENDIF
       IF(ZM.EQ.0.) THEN
        ZM = YM
        ZNORM = YNORM
       ENDIF
       RETURN 1
C
C     M FOR BINOMIAL DISTRIBUTION IN DP/P
C
      ELSE IF (NM.EQ.23) THEN
       BINOM = .TRUE.
       ZM = ABS(WORK(3))
       ZNORM = SQRT((ZM+1.)/2.)
       IF(XM.EQ.0.) THEN
        XM = ZM
        XNORM = ZNORM
       ENDIF
       IF(YM.EQ.0.) THEN
        YM = ZM
        YNORM = ZNORM
       ENDIF
       RETURN 1
C
C     ALL OTHER NM ARE UNKNOWN
C
      ELSE
       RETURN 1
      ENDIF
      END
      SUBROUTINE TRHIST (NHST, M, A, D)
C
C     PRINT ONE DIMENSIONAL HISTOGRAM
C
      REAL    NHST(2000)
      COMMON /BLOC3/ NIN, NOUT
      CHARACTER*1     HIST(100)
C
      CALL NEWSUM1(NHST(1),M)
      NSUM = NINT(NHST(M+3))
      MORE = M+1
      LIM = M+2
      AA = A
      IF(NHST(M+3) .NE. 0.0) GO TO 100
C
C     UNFILLED HISTOGRAM
C
      WRITE (NOUT, 9005)
 9005 FORMAT(5(//),/' Histogram is unfilled.',5(//))
      RETURN
C
C     DETERMINATION OF SCALE
C
  100 XSCALE = 0.0
      DO 200 I = 1, M
      IF(NHST(I) .GT. XSCALE) XSCALE = NHST(I)
  200 CONTINUE
      WRITE (NOUT, 9010) XSCALE
 9010 FORMAT(//11X,'interval',30X,'scale factor.. 100 X"s equal ',
     AG10.3,' entries.')
      IF(XSCALE.EQ.0.0) XSCALE=1.0
C
C     PLOTTING OF HISTOGRAM
C
      NUM = (NHST(LIM)*100.)/XSCALE
      IF(NUM.LE.100) CALL LOADX(HIST, NUM)
      IF(NUM.LE.100) WRITE (NOUT,9020) AA, NHST(LIM), HIST
      IF(NUM.GT.100) WRITE (NOUT,9060) AA, NHST(LIM)
 9020 FORMAT (/' less than  ',F8.3,F10.1,3X,100A1/)
 9060 FORMAT (/' less than  ',F8.3,F10.1,3X,100('O')/)
      DO 300 I = 1,M
      AB =AA + D
      NUM = (NHST(I)*100.)/XSCALE
      CALL LOADX ( HIST, NUM)
      WRITE (NOUT,9030) AA, AB, NHST(I), HIST
 9030 FORMAT ('  ',F8.3,' :',F8.3,F10.1,3X,100A1)
      AA= AB
  300 CONTINUE
      NUM = (NHST(MORE)* 100.) / XSCALE
      IF(NUM.LE.100) CALL LOADX(HIST, NUM)
      IF(NUM.LE.100) WRITE (NOUT,9040) AA, NHST(MORE), HIST
      IF(NUM.GT.100) WRITE (NOUT,9070) AA, NHST(MORE)
 9040 FORMAT (/' more than  ',F8.3,F10.1,3X,100A1)
 9070 FORMAT (/' more than  ',F8.3,F10.1,3X,100('O'))
C
C     SUMMARY
C
      WRITE (NOUT, 9050) NSUM
 9050 FORMAT(/10X,'total number of entries =',I10,5X,
     A       'including underflow and overflow.')
 5000 RETURN
      END
      SUBROUTINE WIEN
C
C     TRACK CHARGED PARTICLES THROUGH A WIEN FILTER
C
      PARAMETER (NND=5001, NNL=1250)
      COMMON /BLOC1/ DATA(NND), I, I1, NEL
      INTEGER         IDATA(NND)
      EQUIVALENCE     (IDATA, DATA)
      COMMON /BLOC1A/ LABEL(NNL)
      CHARACTER*4     LABEL
      COMMON /BLOC4/ RAYMAX(6), PBEAM, P0, NORAYS
      COMMON /BLOC5/ SEC, CAP(3), MPA, THIRD
      LOGICAL         SEC, CAP, MPA, THIRD
      COMMON /BLOC9/ L, H, N, BDB
      REAL            L, N
      COMMON /BLOC13/ RAY(6), RAYC(6), RAYN(6), P, PC, PN, FLD, MASS,
     A                MASSC, MASSN, FC, FN, PSTAR, ZMAX, DKFLAG, Z
      REAL MASS, MASSC, MASSN
      LOGICAL DKFLAG
      COMMON /BLOC15/ LL, KH2, KV2, KH, KV, KHL, KVL, RAY2(6),
     A                RH(4), RV(4), LILENS, SOLSEG
      LOGICAL LILENS, SOLSEG
      REAL LL, KH2, KV2, KH, KV, KHL, KVL
      COMMON /BLOC46/ SM, GAMMA0, BETA0, CHARGE
C
      BETA0W = DATA(I+3)
      IF (BETA0W .NE. 0.0) GO TO 200
C
C     SPIN ROTATOR
C
      H = DATA(I+2) / P0
      KH2 = (H / GAMMA0) ** 2
      CALL FOCSG(KH2,LL,KH,KHL,RH)
      DDP = RAY(6) / H
      RAY2(1) = RH(1) * RAY(1) + RH(2) * RAY(2) - (1. - RH(1)) * DDP
      RAY2(2) = RH(3) * RAY(1) + RH(4) * RAY(2) + RH(3) * DDP
  100 RAY2(3) = RAY(3) + LL * RAY(4)
      RAY2(4) = RAY(4)
      CALL RSETR(RAY,RAY2)
      RETURN
C
C     SEPARATOR
C
  200 BGSQ = ( P / SM ) ** 2
      BETA = SQRT( BGSQ / ( 1. + BGSQ ) )
      H = DATA(I+2) / P
      A = H * ( BETA0W / BETA - 1. )
      RAY2(1) = RAY(1) + RAY(2) * LL + A / 2. * LL ** 2
      RAY2(2) = RAY(2) + A * LL
      GO TO 100
      END
      SUBROUTINE ZERO
C
      COMMON /BLOC6/ NHISTS, NHIST, LIMNO
      COMMON /BLOC8/ MTABLE(50000)
      REAL MTABLE
      COMMON /BLOC12/ VALUE(100), XMOM(100), XMOM2(100), NFLAG(100),
     A                SET(100), KFLAG(100), IFLAG(3,0:9), ZFLAG(9),
     A                WZ(100), UFLAG(100), INVFL, ZC
      LOGICAL SET, IFLAG, UFLAG, INVFL
      COMMON /BLOC16/ ISTOP(3,9998)
      REAL ISTOP
      COMMON /BLO16A/ KPART(3)
      CHARACTER*4     KPART
C
      DO 50 NH = 1, NHISTS
      XMOM(NH) = 0.0
   50 XMOM2(NH) = 0.0
      DO 100 KK = 1, LIMNO
  100 MTABLE(KK) = 0.0
      DO 150 K = 1, 1000
      DO 150 L = 1, 3
  150 ISTOP(L,K) = 0
      RETURN
      END

      SUBROUTINE   UNIFIL(FILNAM,UNIT)
      CHARACTER*10 FILNAM
      INTEGER      UNIT
      IF (UNIT .LT. 10) THEN
       WRITE(FILNAM(6:6),1000) UNIT
       RETURN
      ENDIF
      IF (UNIT .LT. 100) THEN
       WRITE(FILNAM(5:6),1001) UNIT
       RETURN
      ENDIF
       WRITE(FILNAM(4:6),1002) UNIT
       RETURN
 1000 FORMAT(I1)
 1001 FORMAT(I2)
 1002 FORMAT(I3)
      END

      SUBROUTINE MENU(IFLAG)
C
      COMMON /BLOC62/ IUNIT3RD, NUMLIM, ZZ
C
      IF (IFLAG .EQ. 1) THEN
       OPEN(UNIT=99,FILE='ERROR.TRA',STATUS='UNKNOWN')
        write(99,*) 'error'
       CLOSE(UNIT=99)
       write(*,1000)
 1000  format(' error in FOR001.DAT input ')
       CALL GETCHA(key)
       IRET = 1
      ELSE IF (IFLAG .EQ. 2) THEN
       OPEN(UNIT=99,FILE='ERROR.TRA',STATUS='UNKNOWN')
       write(99,*) 'error'
       CLOSE(UNIT=99)
       write(*,1001)
 1001  format(' input FOR001.DAT not found ')
       CALL GETCHA(key)
       IRET = 2
      ELSE
       write(*,*) ' '
       IRET = 0
      ENDIF
      CLOSE(UNIT=0)
      CLOSE(UNIT=5)
      CLOSE(UNIT=6)
      CLOSE(UNIT=7)
      IF (IUNIT3RD .NE. 0) CLOSE(UNIT=IUNIT3RD)
      CALL EXIT(IRET)
      STOP
C
      RETURN
      END

      real function haltons(i)
C
      COMMON /hal/ halton, ipn(10) ,iseries(10)
      LOGICAL HALTON
C
      real halton_generator
C
      haltons = halton_generator(ipn(i),iseries(i))
      iseries(i) = iseries(i) + 1
C
      return
      end

      real function halton_generator(p,ij)
C
C     Pascal source from http://www.kt-algorithms.com/samples/quashalt.pas
C     see also: Press et al, 1992, Numerical Recipes, Chapter 7.
C     Fortran translation by Urs Rohrer (PSI), April 2002
C
C     Return the ij^th Halton quasi-random number in the range 0...1 with
C     prime radix p. When used in several dimensions, the ij^th dimension
C     should be assigned the ij^th prime (2,3,5,7,11,13,17,19,23,29,31,37,
C     41,43,47,53,59,61,67,71) as radix.
C
C     ij is written as a number in radix p. Then the digits are reversed
C     and a 'decimal' point is put in front of the sequence. This
C     fractional  radix p number is then returned as a floating point
C     number.
C
C     Algorithm: Synthetic division.
C 
      integer p, ij
      integer d(32)
      double precision ip, y
      integer j, dd, m, ii, k, i
C
C     Table relevant powers of p
C
      i = ij
      j = 1
      d(1) = 1
      ii = i / p
C
 1    continue
      if (ii .ge. d(j)) then
       j = j + 1
       d(j) = d(j-1) * p
       go to 1
      endif
C
C     Synthetic division
C
      ip = 1.0 / p
      y = 0.0
C
      k = j
      do 10 j = k, 1, -1
       dd = d(j)
       m = 0
 5     continue
       if (i .ge. dd) then
        i = i - dd
        m = m + 1
        go to 5
       endif
       y = (y + m) * ip
 10   continue
C 
      halton_generator = real(y)
C
      return
      end

      SUBROUTINE ERATOS
C
C     COMPUTE THE FIRST 10000 PRIME NUMBERS
C
      COMMON /hal/ halton, ipn(10) ,iseries(10)
      LOGICAL HALTON
C
      PARAMETER (N = 13)
      DIMENSION FLAGS(0:N+1)
      LOGICAL FLAGS
C
      FLAGS(0) = .FALSE.
      FLAGS(1) = .FALSE.
      DO 10 I   = 2, N
       FLAGS(I) = .TRUE.
   10 CONTINUE
C
      I = 2
   20 IF (I*I .LT. N) THEN
       J = 2
30     IF (I*J .LT. N) THEN
        FLAGS(I*J) = .FALSE.
        J = J + 1
        GO TO 30
       ENDIF
       I = I + 1
       GO TO 20
      ENDIF
C
      ICOUNT = 1
      DO 200 I = 0, N
       IF (FLAGS(I)) THEN
        ipn(ICOUNT) = I
        ICOUNT = ICOUNT + 1
       ENDIF
  200 CONTINUE
C
      RETURN
      END

      SUBROUTINE ABOUT
C
      COMMON /BLOC3/ NIN, NOUT
C
      WRITE(NOUT,*) ' '
      WRITE(NOUT,1000)
 1000 FORMAT('TURTLE computational part for Turtle',
     X     ' for Linux, compiled by U. Rohrer (PSI), 16-Apr-2008')
      WRITE(NOUT,*) ' '
C
      RETURN
      END

      SUBROUTINE NEWSUM2(IPLOT, NA, ND)
C
C     RECOMPUTE SUM(S) OF 2-DIM HISTOGRAM IN DOUBLE PRECISSION
C
      REAL*4 IPLOT(2000)
      REAL*8 SUM, SUMT
C
      MT = (NA + 1) * (ND + 1)
C
      SUM = 0.0
      DO 101 J = 1, ND
       DO 100 I = 1, NA
        K = (J-1) * (NA+1) + I
        SUM = SUM + DBLE(IPLOT(K))
  100  CONTINUE
  101 CONTINUE
      IPLOT(MT) = SUM
      IPLOT(MT+5) = SUM+IPLOT(MT+1)+IPLOT(MT+2)+IPLOT(MT+3)+IPLOT(MT+4)
C
      SUMT = 0.0
      DO 201 J = 1, ND
       SUM = 0.0
       DO 200 I = 1, NA
        K = (J-1) * (NA+1) + I
        SUM = SUM + DBLE(IPLOT(K))
  200  CONTINUE
       IPLOT(K+1) = SUM
       SUMT = SUMT + SUM
  201 CONTINUE
C
      SUMT = 0.0
      DO 301 I = 1, NA
       SUM = 0.0
       DO 300 J = 1, ND
        K = (J-1) * (NA+1) + I
        SUM = SUM + DBLE(IPLOT(K))
  300  CONTINUE
       IPLOT((NA+1)*ND+I) = SUM
       SUMT = SUMT + SUM
  301 CONTINUE
C
      RETURN
      END

      SUBROUTINE NEWSUM1(NHST,N)
C
C     RECOMPUTE SUM OF 1-DIM HISTOGRAM IN DOUBLE PRECISSION
C
      REAL*4 NHST(1)
      REAL*8 SUM
C
      SUM = 0.0
      DO 100 I = 1, N + 2
       SUM = SUM + DBLE(NHST(I))
  100 CONTINUE
      NHST(N+3) = SUM
C
      RETURN
      END

      SUBROUTINE MEAN(IPLOT, AMIN, NA, DA, SUM, XM, XXM, IER)
C
      REAL IPLOT(1)      
      REAL*8 SUMD, SUMX, SUMXX
      REAL*8 XMD, XXMD
C
      IER = 0

      SUMD=0.0
      SUMX=0.0
      SUMXX=0.0
      DO 5 I=1,NA
        X=AMIN+(FLOAT(I-1)+0.5)*DA
        Z=IPLOT(I)
        SUMD=SUMD+DBLE(Z)
        SUMX=SUMX+DBLE(X*Z)
        SUMXX=SUMXX+DBLE(X*X*Z)
    5 CONTINUE
      IF (SUMD .LE. 0.0) THEN
       SUM = 0.0
       IER = 1
       RETURN
      ENDIF
      XMD=SUMX/SUMD
      XXMD=SUMXX/SUMD
      SUM=SUMD
      IF (XXMD-XMD*XMD .LE. 0.0) THEN
       XXM = 0.0
       XM  = XMD
       IER = 1
       RETURN
      ENDIF
      XXM=DSQRT(XXMD-XMD*XMD)
      XM=XMD
C
      RETURN
      END
